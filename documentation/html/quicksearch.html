<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"store_recordSearch.js.html":{"id":"store_recordSearch.js.html","title":"Source: store/recordSearch.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: store/recordSearch.js import Client from \"@/lib/GraphClient/GraphClient.js\" import recordsQuery from \"@/lib/GraphClient/queries/getRecords.json\" import filterMapping from \"@/data/FiltersLabelMapping.json\" let client = new Client(); export const mutations = { setRecords(state, data) { state.records = data['records']; state.facets = buildFacets(data[\"aggregations\"]); state.totalPages = data[\"totalPages\"]; state.perPage = data[\"perPage\"]; state.currentPage = data[\"currentPage\"]; state.hits = data[\"totalCount\"]; }, resetRecords(state) { recordsQuery.queryParam = null; state.records = []; }, resetPages(state) { state.hits = null; state.perPage = null; state.currentPage = null; state.totalPages = null; }, setLoadingStatus(state, status) { state.loading = status; }, cleanRecordsStore(state) { state.records = []; state.facets = []; state.hits = null; state.loading = false; state.totalPages = null; state.perPage = null; state.currentPage = null; } }; export const actions = { async fetchRecords(state, params) { this.commit(\"records/setLoadingStatus\", true); this.commit(\"records/resetRecords\"); this.commit(\"records/resetPages\"); if (Object.keys(params).length &gt; 0) { recordsQuery.queryParam = params; } const data = await client.executeQuery(recordsQuery); this.commit('records/setRecords', data[\"searchFairsharingRecords\"]); this.commit(\"records/setLoadingStatus\", false); }, resetRecords() { this.commit(\"records/resetRecords\"); }, }; export const getters = { getFilter: (state) =&gt; (facetName) =&gt; { if (state.facets.length &gt; 0) { let currentFacet = JSON.parse(JSON.stringify(state.facets.find(facet =&gt; facet.filterName === facetName))); currentFacet['values'] = currentFacet['buckets']; return currentFacet; } return []; }, getRecordsLength: (state) =&gt; { return state.records.length; } }; /** * The records store handles the requests related to records (searchFairsharingRecords and fairsharingRecord). * @type {Object} */ let recordsStore = { namespaced: true, state: { records: [], facets: [], hits: null, loading: false, totalPages: null, perPage: null, currentPage: null }, mutations: mutations, actions: actions, getters: getters }; export default recordsStore; /** * Given an object containing the raw facets coming from the client and a mapping object , build the ready to use facets * for usage by the Vue components. * @param {Object} rawFacets - the aggregation object coming from the API response as data['aggregations'] * @returns {Array} output - the array of ready to use facets containing a name, a label and values */ export const buildFacets = function (rawFacets) { let output = []; const mapper = filterMapping[\"autocomplete\"]; Object.keys(rawFacets).forEach(function (facetName) { if (Object.prototype.hasOwnProperty.call(mapper, facetName)) { let localFacet = mapper[facetName]; rawFacets[facetName][\"buckets\"].forEach(function (bucket) { if (Object.prototype.hasOwnProperty.call(bucket, \"key_as_string\")) { bucket[\"key\"] = bucket[\"key_as_string\"]; } }); localFacet['buckets'] = rawFacets[facetName]['buckets']; output.push(localFacet); } }); return output; }; × Search results Close "},"store_searchFilters.js.html":{"id":"store_searchFilters.js.html","title":"Source: store/searchFilters.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: store/searchFilters.js import filterMapping from \"@/data/FiltersLabelMapping.json\" import GraphQLClient from \"@/lib/GraphClient/GraphClient.js\" import query from \"@/lib/GraphClient/queries/getFilters.json\"; import {isEqual} from 'lodash' import buttonOptions from '@/data/ButtonOptions.json' const graphClient = new GraphQLClient(); export const mutations = { setFilters(state, data) { state.filtersStatistic = data['searchFairsharingRecords']['aggregations']; state.rawFilters = buildFilters(state.filtersStatistic); state.filters = state.rawFilters.filter(item =&gt; (item.type !== 'Boolean' &amp;&amp; item.filterName !== 'status')); }, setFilterButtons(state) { state.filterButtons.push({ \"data\": [ { \"title\": \"Match all terms\", \"active\": true, \"filterName\": \"searchAnd\", \"value\": true }, { \"title\": \"Match any term\", \"active\": false, \"filterName\": \"searchAnd\", \"value\": false } ], \"curator_only\": false }); state.rawFilters.forEach(item =&gt; { // TODO: Return here if the button is marked as curator-only and the user isn't logged in as a curator. if (item.type === 'Boolean') { let ObjectModel = buttonOptions[item.filterName]; state.filterButtons.push(ObjectModel); } else if (item.filterName === 'status') { let ObjectModel = buttonOptions.status.data; ObjectModel.forEach(function (button) { if (Object.prototype.hasOwnProperty.call(button, 'apiIndex')) { button.value = item.values[button[\"apiIndex\"]]; } }); state.filterButtons.push({data: ObjectModel, curator_only: false}); } }); }, setLoadingStatus(state, status){ state.isLoadingFilters = status; }, resetFilterButtons(state, itemParentIndex) { state.filterButtons[itemParentIndex].data.map((item) =&gt; { item.active = false; }); }, activateButton(state, item) { state.filterButtons[item.itemParentIndex].data.map((filterItem) =&gt; { if (isEqual(filterItem, item.activeItem)) { filterItem.active = true; } }); } }; export const actions = { resetFilterButtons(state, itemParentIndex) { this.commit('searchFilters/resetFilterButtons', itemParentIndex) }, activateButton(state, item) { this.commit('searchFilters/activateButton', item) }, async assembleFilters(){ this.commit(\"searchFilters/setLoadingStatus\", true); let data = await graphClient.executeQuery(query); this.commit('searchFilters/setFilters', data); this.commit('searchFilters/setFilterButtons'); this.commit(\"searchFilters/setLoadingStatus\", false); } }; export const getters = { getFilters: (state) =&gt; { let output = []; state.filters.forEach(function (filter) { output.push({ filterName: filter.filterName, filterLabel: filter.filterLabel }) }); return output }, getFiltersStatisticCount: (state) =&gt; (option) =&gt; { return state.filtersStatistic[option.filterName].buckets.find(item =&gt; item.key === option.key)['doc_count']; } }; /** * The searchFilters store trigger a single field query to searchFairsharingRecords, gets the aggregation array and * builds the filtering system to be used by advanced search functions. * @type {Object} */ let filtersStore = { namespaced: true, state: { rawFilters: [], filters: [], filtersStatistic: [], filterButtons: [], isLoadingFilters: false }, mutations: mutations, actions: actions, getters: getters }; export default filtersStore; /** * Given a searchFairsharingRecords aggregations array, build the values used by the advanced search widgets * @param {Array} val - an array of raw filters coming from the api as data['searchFairsharingRecords']['aggregations'] * @returns {Array} filters - ready to use filters for the advanced search components */ export const buildFilters = function (val) { let filters = []; let filtersLabels = filterMapping['autocomplete']; Object.keys(val).forEach(function (key) { if (Object.prototype.hasOwnProperty.call(filtersLabels, key)) { let filter = filtersLabels[key]; filter.values = null; let filterValues = []; let buckets = val[key]['buckets']; buckets.forEach(function (bucket) { if (Object.prototype.hasOwnProperty.call( bucket, \"key_as_string\")) { filterValues.push(bucket[\"key_as_string\"]); } else { filterValues.push(bucket['key']); } }); filter.values = filterValues; filters.push(filter); } }); return filters; }; × Search results Close "},"lib_Client_ExternalClients.js.html":{"id":"lib_Client_ExternalClients.js.html","title":"Source: lib/Client/ExternalClients.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: lib/Client/ExternalClients.js import axios from \"axios\" class ExternalRESTClients { /** * The RESTClient is a singleton class that handles the connection and data exchange from the back-end * REST API. */ constructor() { if (ExternalRESTClients._instance) { return ExternalRESTClients._instance } ExternalRESTClients._instance = this; this.doiBaseURL = 'https://dx.doi.org/'; this.headers = { 'Accept': 'application/x-bibtex', }; this.pmidBaseURL = \"https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&amp;retmode=json&amp;id=\"; this.tessBaseURL = \"https://tess.elixir-europe.org/materials.json?q=\"; this.orcidBaseURL = \"https://pub.orcid.org/v2.0/\"; } async getDOI(doi){ let localHeaders = this.headers; localHeaders['Accept'] = 'application/json'; const request = { url: this.doiBaseURL + doi, headers: localHeaders }; let response = await this.executeQuery(request); return response.data; } async getPMID(id){ const request = { url: this.pmidBaseURL + id, headers: { 'Accept': 'application/json', } }; let response = await this.executeQuery(request); return response.data; } async getTessRecords(string){ const request = { url: this.tessBaseURL + string, headers: this.headers }; let response = await this.executeQuery(request); return response.data; } async getOrcidUser(user){ this.headers['Accept'] = \"application/orcid+json\"; const request = { url: this.orcidBaseURL + user, headers: this.headers }; let response = await this.executeQuery(request); this.headers['Accept'] = 'application/x-bibtex'; return response.data; } /** * Trigger the given query with Axios * @param query * @returns {Promise&lt;*&gt;} */ async executeQuery(query) { try { return await axios.get(query.url, {headers: query.headers}); } catch(e){ return({data: {error: e}}); } } } export default ExternalRESTClients; × Search results Close "},"lib_GraphClient_GraphClient.js.html":{"id":"lib_GraphClient_GraphClient.js.html","title":"Source: lib/GraphClient/GraphClient.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: lib/GraphClient/GraphClient.js const axios = require(\"axios\"); import Fragments from \"./queries/fragments/fragments.json\" class GraphQLClient { /** The GraphQLClient retrieves data from the FAIRSharing API and sends it to the front-end. * Be careful, this is a singleton and trying to cast new instances will return the existing instance. Be * also careful, its constructor is async !! * @returns {Promise} - to use this object you need to do \"await new ClassName()\" or use .then(callback) */ constructor(){ this.initalizeHeader(); if (GraphQLClient._instance){ return GraphQLClient._instance } GraphQLClient._instance = this; this.url = process.env.VUE_APP_API_ENDPOINT + \"/graphql\"; } /** * Execute the given query (coming from a json file, see /queries/getRecords.json) * @param {Object} query - the query coming from the JSON file * sending to the API. * @returns {Promise} */ async executeQuery(query){ let client = this; let queryString = { query: `{${client.buildQuery(query)}}` }; let resp = await this.getData(queryString); if (resp.data.errors) { return resp.data.errors; } return resp.data.data } /** * Takes the query, post it with axios and returns the raw data * @param {Object} queryString - processed request coming out of buildQuery() or a GraphQL query string * @returns {Promise} - an axios promise representing the server response. */ async getData(queryString){ let client = this; const fullQuery = { method: \"post\", baseURL: client.url, data: queryString, headers: client.headers }; return await axios(fullQuery); } /** * Transform the JSON query into a string for graphQL * @param {Object} query - the query coming from the JSON file * @returns {Object} {query: queryString} - a valid graphQL query string to execute */ buildQuery(query){ let client = this; let queryString = `${query[\"queryName\"]}`; // query name // Handle query parameters if (query.queryParam) { queryString += \"(\"; Object.keys(query.queryParam).forEach(function(key){ if (typeof query.queryParam[key] === \"boolean\" || typeof query.queryParam[key] === \"number\"){ queryString += `${key}:${query.queryParam[key]} `; } else if (typeof query.queryParam[key] === \"string\") { queryString += `${key}:\"${query.queryParam[key]}\" `; } else { let param = []; query.queryParam[key].forEach(function(paramVal){ param.push(\"\\\"\" + paramVal + \"\\\"\"); }); queryString += `${key}:[${param.join(\",\")}]`; } }); queryString += \")\"; } // Handle query fields if (query.fields){ queryString += \"{\"; query.fields.forEach(function(field){ if (typeof field === \"string\"){ queryString += ` ${field}`; } if (typeof field === \"object\"){ if (\"$ref\" in field){ let myRef = Fragments[field[\"$ref\"]]; for (let subField of myRef){ if (typeof subField === \"string\"){ queryString += ` ${subField}`; } else { queryString += ` ${client.buildQuery(subField)}`; } } } else { queryString += ` ${field.name}{`; field.fields.forEach(function(subField){ if (typeof subField === \"string\"){ queryString += `${subField} `; } else { queryString += `${client.buildQuery(subField)}`; } }); queryString += \"}\"; } } }); queryString += \"}\"; } return queryString; } /** * Add the authorization token to the headers * @param {String} jwt - the user json web token */ setHeader(jwt){ this.headers['Authorization'] = `Bearer ${jwt}`; } initalizeHeader(){ this.headers = { \"Accept\": \"application/json\", \"Content-Type\": \"application/json\", }; this.headers['X-Client-Id'] = process.env.VUE_APP_CLIENT_ID; /* istanbul ignore if */ if (this.headers['X-Client-Id'] === undefined){ delete this.headers['X-Client-Id'] } } } export default GraphQLClient; × Search results Close "},"utils_rules.js.html":{"id":"utils_rules.js.html","title":"Source: utils/rules.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: utils/rules.js /** * Assess if the string is of a certain value (useful to compare passwords) * @param {String} val - the value to evaluate the string against * @returns {function(*): (boolean|string)} */ export function hasValue(val){ return value =&gt; value === val || \"Invalid repeated password\" } /** * Assess email patterns. * @returns {function(*): (boolean|string)} */ export function isEmail(){ return value =&gt; { const pattern = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/ return pattern.test(value) || 'Invalid e-mail.' } } /** * Assess the presence of the field * @returns {function(*=): (boolean|string)} */ export function isRequired(){ return value =&gt; !!value || 'Required.' } /** * Assess URL patterns. * @returns {function(*): (boolean|string)} */ export function isUrl() { return value =&gt; { if (!value) return true; const pattern = /[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&amp;//=]*)?/gi; return pattern.test(value) || 'Invalid URL.' } } /** * Assess if the string is long enough. * @param {Number} length - the length to evaluate the string against. * @returns {function(*): (boolean|string)} */ export function isLongEnough(length) { return value =&gt; { let error = (value) ? `Value is not long enough (${value.length}/${length})` : `Value is not long enough (0/${length})`; if (!value) return error; return value.length &gt;= length || error; } } /** * Assess ORCID patterns. Can be empty if required is false. * @params {Boolean} required - is the field required or not. * @returns {function(*): (boolean|string)} */ export function isOrcid(required) { return value =&gt; { if (!value &amp;&amp; !required) return true; // because this is an optional Orcid ID const pattern = /^(\\d|X){4}-(\\d|X){4}-(\\d|X){4}-(\\d|X){4}$/gi; return pattern.test(value) || \"Doesn't look like a valid ORCID ID.\" } } /** * Assess if the given file has the correct extension * @returns {function(*): (boolean|string)} */ export function isImage(){ const accept = [\"image/png\", \"image/jpeg\"]; return value =&gt; { return (!value || accept.indexOf(value.type) &gt; -1) || \"File type should be PNG or JPEG\" } } × Search results Close "},"store_introspector.js.html":{"id":"store_introspector.js.html","title":"Source: store/introspector.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: store/introspector.js import Client from \"../lib/GraphClient/GraphClient.js\" import introspectionQuery from \"../lib/GraphClient/queries/introspection.json\" import {isEqual} from 'lodash' let client = new Client(); export const mutations = { setParameters(state, data) { try { if (Object.keys(data).includes(\"errors\")) { state.error = data.errors[0].message } else { localStorage.introspectionQuery = JSON.stringify(data); let queryParams = data.data[\"__schema\"][\"types\"].filter(param =&gt; param.name === \"Query\")[0]; state.searchQueryParameters = queryParams.fields.filter(param =&gt; param.name === \"searchFairsharingRecords\")[0]; if (!localStorage.searchQueryParameters) { localStorage.searchQueryParameters = JSON.stringify(state.searchQueryParameters); } else { if (!isEqual(JSON.parse(localStorage.searchQueryParameters), JSON.parse(JSON.stringify(state.searchQueryParameters)))) { localStorage.searchQueryParameters = JSON.stringify(state.searchQueryParameters); } else { state.searchQueryParameters = JSON.parse(localStorage.searchQueryParameters); } } } } catch (e) { state.error = \"Can't initialize application\" } }, setLocalStorageExpiryTime: function () { let now = new Date(); localStorage.expiryDate = now; return now; } }; export const actions = { async fetchParameters(state, timer) { let expirationTimer = (timer) ? timer : 24; if (localStorage.expiryDate) { const expiration = paramsAreExpired(localStorage.expiryDate, expirationTimer); if (expiration) { let data = await client.getData(introspectionQuery); this.commit(\"introspection/setLocalStorageExpiryTime\"); this.commit(\"introspection/setParameters\", data.data); } else { this.commit(\"introspection/setParameters\", JSON.parse(localStorage.introspectionQuery)); } } if (!localStorage.introspectionQuery) { let data = await client.getData(introspectionQuery); this.commit(\"introspection/setLocalStorageExpiryTime\"); this.commit(\"introspection/setParameters\", data.data); } } }; export const getters = { buildQueryParameters: (state) =&gt; (params) =&gt; { let queryParameters = {}; Object.keys(params[1]).forEach(function (param) { let currentParam = state.searchQueryParameters.args.filter(arg =&gt; arg.name === param)[0]; const expectedTypeObject = currentParam.type; if (expectedTypeObject.kind !== \"LIST\") { queryParameters[param] = parseParam(expectedTypeObject, params[1][param]); } else { const currentVal = params[1][param]; const expectedType = expectedTypeObject[\"ofType\"][\"ofType\"].name; queryParameters[param] = []; if (currentVal.indexOf(\",\") &gt; 0) { currentVal.split(\",\").forEach(function (val) { queryParameters[param].push(decodeURIComponent(parseParam(expectedType, val))) }); } else { queryParameters[param] = decodeURIComponent(parseParam(expectedType, currentVal)) } } }); if (params[0] !== \"Search\") { queryParameters[\"fairsharingRegistry\"] = params[0]; } return queryParameters; } }; /** * The introspection store is related to the introspection query that let us know which fields/types are allowed by the searchFairsharingRecords query * @type {Object} * */ let introspectionStore = { namespaced: true, /** * @name states * @type {Object} * @property {String} errors - collects errors while introspecting. * @property {object} searchQueryParameters - filters query parameters object coming from API. */ state: { errors: String, searchQueryParameters: {}, }, modules: {}, mutations: mutations, actions: actions, getters: getters }; export default introspectionStore; /** * Given a type and a value, parse the value with the expected type. * @param {Object} param - the parameter types allowed * @param {String} paramVal - the value to be parsed * @returns {String | Number | Boolean} paramVal - the parse value * @example &lt;caption&gt; Example usage of parseParam &lt;/caption&gt; * parseParam({name: \"Boolean\"}, \"true\"); * // return True */ const parseParam = function (param, paramVal) { if (param.name === \"Int\") { return parseFloat(paramVal) } else if (param.name === \"Boolean\") { return JSON.parse(paramVal) } return paramVal }; /** * Compares the given date with now and returns true if it greater than the given timer * @param {Date} expiryDate - the date to compare * @param {Number} expirationTimer - the timer to determine if the date has been expired or not * @returns {boolean} - is the data expired or not */ export const paramsAreExpired = function (expiryDate, expirationTimer) { const limit = expirationTimer * 3600; const expiration = new Date(expiryDate); const now = new Date(); return ((now - expiration) - limit) &gt;= 0 }; × Search results Close "},"components_Records_Record_Collections.vue.html":{"id":"components_Records_Record_Collections.vue.html","title":"Source: components/Records/Record/Collections.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: components/Records/Record/Collections.vue &lt;template xmlns:v-slot=\"http://www.w3.org/1999/XSL/Transform\"&gt; &lt;v-card class=\"pa-4 d-flex flex-column\" outlined color=\"bg_record_card\" tile elevation=\"3\" &gt; &lt;SectionTitle title=\"Collections\" :inactive-section=\"tabsDataExist\" /&gt; &lt;div class=\"d-flex flex-column ml-2 min-height-40\"&gt; &lt;div class=\"d-flex flex-wrap mt-5\"&gt; &lt;!-- search autocomplete --&gt; &lt;v-autocomplete v-if=\"!tabsDataExist\" v-model=\"selectedValues\" :disabled=\"tabsData.tabs[Object.keys(tabsData.tabs)[tabsData.selectedTab]].data.length&lt;5\" :items=\"getValues\" solo :attach=\"true\" dense clearable prepend-inner-icon=\"fa-search\" :placeholder=\"`Search through ${cleanString(Object.keys(tabsData.tabs)[tabsData.selectedTab])}`\" item-text=\"name\" item-value=\"name\" &gt; &lt;template #item=\"data\"&gt; &lt;span class=\"filterValueName\"&gt; {{ data.item.name }} &lt;/span&gt; &lt;/template&gt; &lt;/v-autocomplete&gt; &lt;/div&gt; &lt;!-- tabs --&gt; &lt;v-tabs v-if=\"!tabsDataExist\" v-model=\"tabsData.selectedTab\" background-color=\"transparent\" grow color=\"accent3\" slider-color=\"accent3\" class=\"mb-5\" :hide-slider=\"tabsData.tabs[Object.keys(tabsData.tabs)[tabsData.selectedTab]].data.length===0\" &gt; &lt;v-tab v-for=\"(tabName,tabIndex) in Object.keys(tabsData.tabs)\" :key=\"tabName+'_'+tabIndex\" :disabled=\"tabsData.tabs[tabName].data.length===0\" @change=\"selectedValues=null\" &gt; {{ cleanString(tabName) }} &lt;/v-tab&gt; &lt;/v-tabs&gt; &lt;!-- tab content --&gt; &lt;v-tabs-items v-if=\"!tabsDataExist\" v-model=\"tabsData.selectedTab\" :class=\"['transparent',tabsDataExist]\" &gt; &lt;v-tab-item v-for=\"(tabItem,tabItemIndex) in filterList\" :key=\"tabItem+'_'+tabItemIndex\" &gt; &lt;v-virtual-scroll :items=\"tabItem.data\" height=\"400\" item-height=\"130\" class=\"ma-4 overflow-x-hidden\" &gt; &lt;template #default=\"{ item,index }\"&gt; &lt;v-card :key=\"item.id + '_' + index\" class=\"pa-4 d-flex flex-column v-card-hover mx-2 height-120\" flat outlined &gt; &lt;div class=\"d-flex align-center\"&gt; &lt;record-status :record=\"item\" :show-status=\"false\" /&gt; &lt;div class=\"ml-10 text-ellipses-height-2lines line-height-20\"&gt; {{ item.name }} &lt;/div&gt; &lt;/div&gt; &lt;p class=\"grey--text relation-style text-ellipses-height-2lines line-height-14\"&gt; {{ item.name }} &lt;v-tooltip top&gt; &lt;template #activator=\"{ on }\"&gt; &lt;span class=\"red--text mouse-info\" v-on=\"on\" &gt; {{ item.recordAssocLabel }} &lt;/span&gt; &lt;/template&gt; &lt;span&gt;{{ relationDefinition[item.recordAssocLabel] }}&lt;/span&gt; &lt;/v-tooltip&gt; {{ item.subject }} &lt;/p&gt; &lt;/v-card&gt; &lt;/template&gt; &lt;/v-virtual-scroll&gt; &lt;/v-tab-item&gt; &lt;/v-tabs-items&gt; &lt;/div&gt; &lt;/v-card&gt; &lt;/template&gt; &lt;script&gt; import SectionTitle from '@/components/Records/Record/SectionTitle'; import {mapState} from \"vuex\"; import stringUtils from \"@/utils/stringUtils\" import RecordStatus from \"@/components/Records/Shared/RecordStatus\"; import recordTabUtils from \"@/utils/recordTabUtils\"; import recordRelationShipsDefinitions from \"@/data/RecordRelationShipsDefinitions.json\"; export default { name: \"Collections\", components: { RecordStatus, SectionTitle, }, mixins:[stringUtils,recordTabUtils], data: () =&gt; { return { relationDefinition: recordRelationShipsDefinitions, selectedValues: null, tabsData: { selectedTab: 0, tabs: { in_collections: {relation: 'collects', data: []}, in_recommendations: {relation: 'recommends', data: []}, } } } }, computed: { ...mapState(\"record\", [\"currentRecord\"]), }, methods: { /** Dynamically sets data for each tabs based on the data received from recordAssociations and reverseAssociations*/ prepareTabsData() { const _module = this; if (Object.keys(_module.currentRecord['fairsharingRecord']).includes('recordAssociations') || Object.keys(_module.currentRecord['fairsharingRecord']).includes('reverseRecordAssociations')) { Object.keys(_module.tabsData.tabs).forEach(tabName =&gt; { _module.tabsData.tabs[tabName].data = _module.prepareAssociations(_module.currentRecord['fairsharingRecord'].recordAssociations, _module.currentRecord['fairsharingRecord']['reverseRecordAssociations']) .filter(item =&gt; item.recordAssocLabel === _module.tabsData.tabs[tabName].relation) }) } else { return false } }, } } &lt;/script&gt; × Search results Close "},"components_Records_Search_Input_FilterAutocomplete.vue.html":{"id":"components_Records_Search_Input_FilterAutocomplete.vue.html","title":"Source: components/Records/Search/Input/FilterAutocomplete.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: components/Records/Search/Input/FilterAutocomplete.vue &lt;template&gt; &lt;v-expansion-panel v-if=\"filter.filterName\" :id=\"filter.filterName + 'AutocompleteList' \" &gt; &lt;v-expansion-panel-header&gt; {{ filter.filterLabel }}&lt;/v-expansion-panel-header&gt; &lt;v-expansion-panel-content class=\"pl-5 pr-5\"&gt; &lt;div :class=\"['d-flex',{'flex-column':$vuetify.breakpoint.mdAndDown}]\"&gt; &lt;v-autocomplete v-model=\"selectedValues\" :attach=\"true\" :items=\"getValues\" solo dense clearable multiple prepend-inner-icon=\"fa-search\" :placeholder=\"`Search through ${filter.filterLabel}`\" item-text=\"key\" item-value=\"key\" @focus=\"scrollTo(filter.filterName)\" @click:clear=\"reset(filter)\" &gt; &lt;template #selection=\"data\"&gt; &lt;v-chip class=\"blue white--text mb-1 \"&gt; &lt;span class=\"chipsValueName\"&gt; {{ cleanString(data.item.key) }} &lt;/span&gt; &lt;/v-chip&gt; &lt;/template&gt; &lt;template #item=\"data\"&gt; &lt;div class=\"d-flex full-width\"&gt; &lt;span class=\"filterValueName\"&gt; {{ cleanString(data.item.key) }}&lt;/span&gt; &lt;span class=\"filterValueCount\"&gt; {{ data.item['doc_count'] }}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/v-autocomplete&gt; &lt;v-btn color=\"primary\" class=\"ml-lg-2 custom-btn\" @click=\"applyFilters(filter)\" &gt; Apply &lt;/v-btn&gt; &lt;/div&gt; &lt;/v-expansion-panel-content&gt; &lt;/v-expansion-panel&gt; &lt;/template&gt; &lt;script&gt; import {mapGetters, mapState} from 'vuex' import clearString from '@/utils/stringUtils' export default { name: \"FilterAutocomplete\", mixins: [clearString], props: { filter: {default: null, type: Object}, lastItem:{default:false, type:Boolean} }, data: () =&gt; { return { selectedValues: [] } }, computed: { ...mapGetters('records', ['getFilter']), ...mapState('uiController', ['stickToTop']), getValues: function () { let _module = this; let output = _module.getFilter(this.filter.filterName); if (output.values &amp;&amp; typeof output.values === 'object') { return output.values; } return [] } }, methods: { /** * Apply the filters by building the new query parameters using the form data. */ applyFilters: function () { let _module = this; let filterName = _module.filter.filterName; let currentParams = JSON.parse(JSON.stringify(_module.$route.query)); if (Object.keys(currentParams).indexOf(filterName) === -1) { if (_module.selectedValues !== null &amp;&amp; _module.selectedValues.length &gt; 0) { if (_module.selectedValues.length === 1) { currentParams[filterName] = encodeURIComponent(_module.selectedValues.join(',')); } else { let newParam = []; _module.selectedValues.forEach(function (val) { newParam.push(encodeURIComponent(val)); }); currentParams[filterName] = newParam.join(\",\"); } _module.$router.push({ name: _module.$route.name, query: currentParams }); } } else { if (_module.selectedValues === null || _module.selectedValues.length === 0) { delete currentParams[_module.filter.filterName]; _module.$router.push({ name: _module.$route.name, query: currentParams }); } else { let newParams = []; let existingValues = currentParams[_module.filter.filterName].split(\",\"); _module.selectedValues.forEach(function (selectedValue) { const filterVal = encodeURIComponent(selectedValue); if (existingValues.indexOf(filterVal) === -1) { newParams.push(filterVal); } }); currentParams[_module.filter.filterName] += `,${newParams.join(\",\")}`; if (newParams.length &gt; 0) { _module.$router.push({ name: _module.$route.name, query: currentParams }); } } } _module.selectedValues = []; }, /** * Reset the form/filters/parameters to default (go so /search?page=1) */ reset: function (selectedItem) { selectedItem.filterSelected = {}; }, /* istanbul ignore next */ scrollTo(name) { let _module = this; _module.$scrollTo(\"#\" + name + 'AutocompleteList', 450, { container: '#scrollable-holder', easing: 'ease-in', }) } } } &lt;/script&gt; &lt;style scoped&gt; .filterValueName { text-overflow: ellipsis; overflow: hidden; white-space: nowrap; flex: 1; } .chipsValueName { width: 100%; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } .filterValueCount { background: #2196F3; color: white; padding: 0 7px; } .custom-btn { height: 38px; } &lt;/style&gt; × Search results Close "},"components_Records_Search_Input_FilterButton.vue.html":{"id":"components_Records_Search_Input_FilterButton.vue.html","title":"Source: components/Records/Search/Input/FilterButton.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: components/Records/Search/Input/FilterButton.vue &lt;template&gt; &lt;v-tooltip bottom :disabled=\"itemModified.tooltip===undefined || $vuetify.breakpoint.smAndDown\" &gt; &lt;template #activator=\"{ on }\"&gt; &lt;v-btn color=\"primary\" class=\"mr-1 mr-lg-2\" :outlined=\"!itemModified.active\" :class=\"[isFirstItem &amp;&amp; !doubleItems ? 'first-child' : 'flex-1', {'button-style-md-screens' : mdScreens, 'buttons-md-style' : multipleItems &amp;&amp; !isFirstItem}]\" @click=\"selectFilter(itemModified)\" v-on=\"on\" &gt; &lt;span v-if=\"itemModified.title!=='ALL'\"&gt;{{ itemModified.title }}&lt;/span&gt; &lt;v-icon v-else small color=\"primary\" &gt; {{ $vuetify.icons.values.loading }} &lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/template&gt; &lt;span&gt;{{ itemModified.tooltip }}&lt;/span&gt; &lt;/v-tooltip&gt; &lt;/template&gt; &lt;script&gt; import { isEqual } from \"lodash\"; import { mapActions } from 'vuex' import currentParameter from \"@/utils/currentParameterMixin.js\" export default { name: \"FilterButton\", mixins: [currentParameter], props: { item: {default: null, type: Object}, isFirstItem: {default: false, type: Boolean}, mdScreens: {default: null, type: Boolean}, itemParentIndex: {default: 0, type: Number}, multipleItems: {default: false, type: Boolean}, doubleItems: {default: false, type: Boolean}, }, data: () =&gt; { return { itemModified: {default: null, type: Object} } }, watch: { currentParameter: { handler(newVal) { const _module = this; const fieldName = _module.itemModified.filterName; const fieldValue = newVal[fieldName]; const currentValue = _module.itemModified.value; const title = _module.itemModified.title; _module.checkCurrentParameters(title, fieldValue, currentValue); }, deep: true } }, mounted(){ this.$nextTick(function () { const _module = this; _module.itemModified = JSON.parse(JSON.stringify(this.item)); const fieldValue = _module.currentParameter[this.itemModified.filterName]; const currentValue = _module.itemModified.value; const title = _module.itemModified.title; _module.checkCurrentParameters(title, fieldValue, currentValue); }); }, methods: { checkCurrentParameters: function(title, fieldValue, currentValue) { if (fieldValue === null) { this.itemModified.active = title === 'all' || title === 'match all terms'; } else { if (currentValue === undefined) { this.itemModified.active = false; } else { this.itemModified.active = currentValue.toString() === fieldValue; } } }, /** * Apply the filters by building the new query parameters using the form data. */ applyFilters: function (selectedItem) { const _module = this; let currentQuery = {}; let oldQuery = {}; Object.keys(_module.$route.query).forEach(function (param) { currentQuery[param] = _module.$route.query[param]; oldQuery[param] = _module.$route.query[param] }); Object.prototype.hasOwnProperty.call(selectedItem, 'value') ? currentQuery[selectedItem.filterName] = encodeURIComponent(selectedItem.value) : delete currentQuery[selectedItem.filterName]; if (!isEqual(currentQuery, oldQuery)) { this.$router.push({ name: _module.$route.name, query: currentQuery }); } }, selectFilter: function (selectedItem) { let _module = this; _module.resetFilterButtons(_module.itemParentIndex); _module.activateButton({ 'activeItem': selectedItem, 'itemParentIndex': _module.itemParentIndex }); this.applyFilters(selectedItem); }, ...mapActions(\"searchFilters\", [\"resetFilterButtons\", \"activateButton\"]) } } &lt;/script&gt; &lt;style scoped&gt; .button-style-md-screens { font-size: 9px !important; } .first-child { font-size: 11px; width: 16.5%; } .flex-1 { font-size: 11px; flex: 1; } .buttons-md-style { min-width: 32px !important; } &lt;/style&gt; × Search results Close "},"components_Records_Search_Header_FilterChips.vue.html":{"id":"components_Records_Search_Header_FilterChips.vue.html","title":"Source: components/Records/Search/Header/FilterChips.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: components/Records/Search/Header/FilterChips.vue &lt;template&gt; &lt;v-row class=\"mr-2 ml-2\"&gt; &lt;v-chip v-if=\"getChips.length\" class=\"ma-2\" color=\"red\" text-color=\"white\" @click=\"removeAllParams\" &gt; Clear All &lt;/v-chip&gt; &lt;div v-for=\"(chip, index) in getChips\" :key=\"'Chips_' + index\" &gt; &lt;v-chip class=\"ma-2\" close color=\"white\" text-color=\"secondary\" @click:close=\"removeParam(chip.paramName, chip.paramVal)\" &gt; {{ getFilteredLabel[chip.paramName] }}:&lt;b class=\"ml-1\"&gt; {{ decodeURIComponent(chip.paramVal).replace(/_/g, \" \") }}&lt;/b&gt; &lt;/v-chip&gt; &lt;/div&gt; &lt;/v-row&gt; &lt;/template&gt; &lt;script&gt; import {throttle} from \"lodash\" import filterChipsUtils from \"@/utils/filterChipsUtils\"; import filterMapping from \"@/data/FiltersLabelMapping.json\" export default { name: \"FilterChips\", mixins: [filterChipsUtils], computed: { /** * get the Filtered label that correponds to the name using the map FilterLabel * @returns {Object} - object with the mapping names and labels */ getFilteredLabel: function () { let filterLabels = { q: \"Query string\" }; Object.keys(filterMapping[\"autocomplete\"]).forEach((filterName) =&gt; { let field = filterMapping[\"autocomplete\"][filterName]; filterLabels[field.filterName] = field.filterLabel; }); return filterLabels; } }, methods: { /** * Removes the parameter value from the router query with a 2000ms throttle * @param {String} paramName - name of the parameter to remove * @param {String} paramVal - value of the parameter to remove */ removeParam: throttle(async function (paramName, paramVal) { let _module = this; let query = this.buildNewQuery(paramName, paramVal); await _module.$router.push({ name: _module.$route.name, query: query }) }, 2000), /** * Removes all the parameters value from the router query with a 2000ms throttle */ removeAllParams: throttle(async function () { let _module = this; let query = {}; await _module.$router.push({ name: _module.$route.name, query: query }) }, 2000), /** * Build the new query given a parameter name a value by getting the current query and removing the key/value given * @param {String} paramName - name of the parameter to remove * @param {String} paramVal - value of the parameter to remove * @returns {Object} - the new query to replace in the router */ buildNewQuery: function (paramName, paramVal) { let _module = this; let query = {}; Object.keys(_module.$route.query).forEach(function (queryParam) { if (queryParam !== paramName) { query[queryParam] = _module.$route.query[queryParam] } else { if (_module.$route.query[queryParam].includes(',')) { let currentValues = _module.$route.query[queryParam].split(\",\"); if (currentValues.includes(paramVal)) { currentValues.splice(currentValues.indexOf(paramVal), 1) } query[paramName] = currentValues.join(\",\"); } } }); query[\"page\"] = 1; return query; } } } &lt;/script&gt; × Search results Close "},"views_Home_Home.vue.html":{"id":"views_Home_Home.vue.html","title":"Source: views/Home/Home.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/Home/Home.vue &lt;template&gt; &lt;v-main&gt; &lt;v-container fluid class=\"text-center pa-0\" &gt; &lt;Jumbotron /&gt; &lt;Carousel /&gt; &lt;InfoBlock class=\"mb-12\" /&gt; &lt;SearchBlock /&gt; &lt;CategoryBlock class=\"mt-12 mb-12\" /&gt; &lt;/v-container&gt; &lt;!-- This html is from a safe source --&gt; &lt;!-- eslint-disable vue/no-v-html --&gt; &lt;script type=\"application/ld+json\" v-html=\"JSONLD\" /&gt; &lt;!-- eslint-enable vue/no-v-html --&gt; &lt;/v-main&gt; &lt;/template&gt; &lt;script&gt; import Jumbotron from \"@/components/Home/Jumbotron\"; import Carousel from \"@/components/Home/Carousel\"; import InfoBlock from \"@/components/Home/InfoBlock\"; import SearchBlock from \"@/components/Home/SearchBlock\"; import CategoryBlock from \"@/components/Home/CategoryBlock\"; /** Component to handle the front page (landing page) * */ export default { name: \"Home\", components:{ Jumbotron, Carousel, InfoBlock, SearchBlock, CategoryBlock }, computed: { JSONLD: () =&gt; { return JSON.stringify( { \"@context\": \"http://schema.org\", \"@type\": \"DataCatalog\", \"identifier\":\"https://identifiers.org/MIR:00000364\", \"name\": \"FAIRsharing.org\", \"description\": \"A manually curated, informative and educational resource on data and metadata standards, inter-related to databases/data repositories and funder and journal publisher data policies from across disciplines. FAIRsharing is an ELIXIR-UK node resource and has an active role in the RDA and Force11 data initiatives.\", \"url\": \"https://fairsharing.org/\", \"dataset\": [ { \"@type\" : \"Dataset\", \"name\" : \"Metadata Standard\", \"description\" : \"A manually curated registry of standards, split into three types - Terminology Artifacts (ontologies, e.g. Gene Ontology), Models and Formats (conceptual schema, formats, data models, e.g. FASTA), and Reporting Guidelines (e.g. the ARRIVE guidelines for in vivo animal testing). These are linked to the databases that implement them and the funder and journal publisher data policies that recommend or endorse their use.\", \"identifier\": \"https://www.fairsharing.org/bsg-sXXXXXX\", \"url\" : \"https://fairsharing.org/standards\", \"keywords\" : \"Standards, Metadata, Formats, Ontologies, Terminology Artifacts, Reporting Guidelines\", \"includedInDataCatalog\" : \"https://www.fairsharing.org\" }, { \"@type\" : \"Dataset\", \"name\" : \"Database\", \"description\": \"A manually curated registry of databases/data repositories, conforming to the BioDBcore standard (from the Life Sciences). These are linked to the standards that they use and the funder and journal publisher data policies that recommend or endorse their use.\", \"identifier\": \"https://www.fairsharing.org/bsg-dXXXXXX\", \"url\": \"https://fairsharing.org/databases\", \"keywords\": \"Database, Data repository\", \"includedInDataCatalog\" : \"https://www.fairsharing.org\" }, { \"@type\" : \"Dataset\", \"name\" : \"Data Policy\", \"description\": \"A manually curated registry of data policies from research funders, journal publishers, societies, and other organisations. These are linked to the databases and standards that they recommend for use\", \"identifier\": \"https://www.fairsharing.org/bsg-pXXXXXX\", \"url\": \"https://fairsharing.org/policies\", \"keywords\": \"Data policy, journal, funder, society\" } ], \"keywords\": \"registry, life science, natural science, social science, \", \"provider\": [ { \"@type\":\"Person\", \"name\": \"FAIRsharing.org support\", \"email\": \"contact@fairsharing.org\" }, { \"@type\":\"Organization\", \"name\": \"Oxford e-Research Centre, University of Oxford\", \"url\": \"http://www.oerc.ox.ac.uk/\" }, { \"@type\":\"Organization\", \"name\": \"ELIXIR-UK\", \"url\": \"http://www.elixir-uk.org\" }, { \"alternateName\": [\"FAIRsharing.org Registry\", \"BioSharing.org\"] } ], \"license\": { \"@type\": \"CreativeWork\", \"name\": \"Creative Commons CC BY-SA 4.0 Attribution\", \"url\": \"https://creativecommons.org/licenses/by-sa/4.0/\" }, \"publication\":[ { \"@type\":\"PublicationEvent\", \"name\": \"BioSharing: curated and crowd-sourced metadata standards, databases and data policies in the life sciences.\", \"url\": \"https://academic.oup.com/database/article-lookup/doi/10.1093/database/baw075\" } ] }); } } }; &lt;/script&gt; × Search results Close "},"views_Users_Login_Login.vue.html":{"id":"views_Users_Login_Login.vue.html","title":"Source: views/Users/Login/Login.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/Users/Login/Login.vue &lt;template&gt; &lt;v-form id=\"loginPage\" ref=\"loginPage\" v-model=\"formValid\" class=\"login\" style=\"background: white\" &gt; &lt;v-container&gt; &lt;!-- forms --&gt; &lt;v-row justify=\"center\"&gt; &lt;v-col cols=\"12\" sm=\"12\" :md=\"!popUp ? '8' : '12' \" :lg=\"!popUp ? '8' : '12' \" :xl=\"!popUp ? '5' : '12' \" &gt; &lt;v-card :flat=\"popUp\"&gt; &lt;v-card-title :class=\"{'blue white--text mb-5': !popUp, 'py-0 mb-5': popUp}\"&gt; &lt;h2 class=\"ma-0\"&gt; {{ currentPanel | capitalize }} &lt;/h2&gt; &lt;/v-card-title&gt; &lt;v-card-text&gt; &lt;!-- message handler --&gt; &lt;MessageHandler field=\"login\" /&gt; &lt;!-- button to re-send confirmation if login failed --&gt; &lt;div v-if=\"resendButton\" class=\"d-flex flex-row justify-center\" &gt; &lt;v-btn class=\"text-center teal white--text px-2\" href=\"#/users/resendConfirmation\" @click=\"()=&gt;{$emit('ClosePopup', true)}\" &gt; Resend me the confirmation email &lt;/v-btn&gt; &lt;/div&gt; &lt;v-divider v-if=\"resendButton\" class=\"pb-0 mb-0\" /&gt; &lt;!-- OAUTH --&gt; &lt;v-list&gt; &lt;v-list-item v-for=\"(provider, providerIndex) in oauthLogin\" :key=\"'provider_' + providerIndex\" style=\"justify-content: center\" &gt; &lt;v-btn width=\"250px\" :class=\"provider.color\" class=\"text-left\" :href=\"provider.callback + returnTo()\" &gt; &lt;v-layout width=\"100%\"&gt; &lt;v-icon left class=\"mr-5\" &gt; {{ 'fab fa-' + provider.name.toLowerCase() }} &lt;/v-icon&gt; &lt;v-layout&gt;with {{ provider.name }}&lt;/v-layout&gt; &lt;/v-layout&gt; &lt;/v-btn&gt; &lt;/v-list-item&gt; &lt;/v-list&gt; &lt;/v-card-text&gt; &lt;!-- card content // Form --&gt; &lt;v-card-text v-if=\"currentPanel === 'login'\"&gt; &lt;v-form id=\"loginForm\" ref=\"loginForm\" v-model=\"formValid\" &gt; &lt;!-- account --&gt; &lt;v-text-field v-model=\"loginData.name\" label=\"Username or email\" required outlined :rules=\"[rules.isRequired()]\" @keyup.enter=\"logUser()\" /&gt; &lt;!-- password --&gt; &lt;v-text-field v-model=\"loginData.password\" :append-icon=\"show1 ? 'fa-eye' : 'fa-eye-slash'\" :type=\"show1 ? 'text' : 'password'\" label=\"Password\" counter required outlined :rules=\"[rules.isRequired()]\" @click:append=\"show1 = !show1\" @keyup.enter=\"logUser()\" /&gt; &lt;v-card-text class=\"text-center py-1\"&gt; &lt;router-link to=\"/accounts/forgotPassword\"&gt; &lt;span @click=\"()=&gt;{$emit('ClosePopup', true)}\"&gt;Forgot your password ?&lt;/span&gt; &lt;/router-link&gt; &lt;v-divider /&gt; &lt;router-link to=\"/accounts/signup\"&gt; &lt;span @click=\"()=&gt;{$emit('ClosePopup', true)}\"&gt;Create a new account&lt;/span&gt; &lt;/router-link&gt; &lt;/v-card-text&gt; &lt;v-card-actions class=\"mt-2 justify-center\"&gt; &lt;v-btn class=\" px-4\" light color=\"primary\" :disabled=\"!formValid\" @click=\"logUser()\" &gt; LOGIN &lt;/v-btn&gt; &lt;/v-card-actions&gt; &lt;/v-form&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/v-container&gt; &lt;/v-form&gt; &lt;/template&gt; &lt;script&gt; import {mapActions, mapState} from 'vuex' import MessageHandler from \"@/components/Users/MessageHandler\"; import stringUtils from '@/utils/stringUtils'; import { isRequired } from \"@/utils/rules.js\" /** This component handles the login page * */ export default { name: \"Login\", components: {MessageHandler}, mixins: [stringUtils], props: { redirect: { type: Boolean, default: true, }, popUp: { type: Boolean, default: false, }, }, data: () =&gt; { return { show1: false, resendButton: false, currentPanel: \"login\", loginData: {}, oauthLogin: [ { name: \"ORCID\", color: \"green white--text\", callback: process.env.VUE_APP_API_ENDPOINT + \"/users/auth/orcid\", }, { name: \"Twitter\", color: \"blue white--text\", callback: process.env.VUE_APP_API_ENDPOINT + \"/users/auth/twitter\", }, { name: \"GitHub\", color: \"black white--text\", callback: process.env.VUE_APP_API_ENDPOINT + \"/users/auth/github\", } ], rules: { isRequired: function(){return isRequired()}, }, formValid: false } }, computed: { ...mapState(\"users\", [\"messages\", \"user\"]), }, methods: { ...mapActions('users', ['login', 'logout']), async logUser() { const _module = this; const user = { \"name\": _module.loginData.name, \"password\": _module.loginData.password }; _module.$emit('ClosePopup',false); await _module.login(user); if (_module.messages().login.error) { const confirmationError = \"You have to confirm your email address before continuing.\"; if (_module.messages().login.message === confirmationError) { _module.resendButton = true; } } else { const goTo = _module.$route.query.goTo; if (_module.redirect) { if (goTo) { _module.$router.push({ path: goTo }) } else { _module.$router.push({ path: \"/accounts/profile\" }) } } } }, returnTo() { const _module = this; const goTo = _module.$route.query.goTo; if (goTo) { return `?return_to=${goTo}`; } return ''; } } } &lt;/script&gt; &lt;style scoped&gt; #loginPage a { text-decoration: none !important; } .v-card__text { width: auto; } &lt;/style&gt; × Search results Close "},"views_CreateRecord_NewRecord.vue.html":{"id":"views_CreateRecord_NewRecord.vue.html","title":"Source: views/CreateRecord/NewRecord.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/CreateRecord/NewRecord.vue &lt;template&gt; &lt;v-container id=\"createRecord\" fluid &gt; &lt;v-form id=\"createRecord\" ref=\"createRecord\" v-model=\"formValid\" &gt; &lt;v-row&gt; &lt;v-col cols=\"12\"&gt; &lt;v-card v-if=\"loaded\"&gt; &lt;v-card-title class=\"primary white--text\"&gt; &lt;h3 class=\"white--text\"&gt; Creating a new FAIRsharing record &lt;/h3&gt; &lt;/v-card-title&gt; &lt;v-card-text v-if=\"message.error\" class=\"pt-4\" &gt; &lt;v-alert type=\"error\"&gt; {{ message.value }}&lt;v-icon class=\"px-3\"&gt; fa-arrow-right &lt;/v-icon&gt; {{ message.value.response.data }} &lt;/v-alert&gt; &lt;/v-card-text&gt; &lt;v-card-text class=\"pt-3\"&gt; &lt;v-container fluid&gt; &lt;v-row&gt; &lt;base-fields /&gt; &lt;/v-row&gt; &lt;/v-container&gt; &lt;/v-card-text&gt; &lt;v-card-actions&gt; &lt;v-btn class=\"primary\" :disabled=\"!formValid\" @click=\"createRecord()\" &gt; Create Record &lt;/v-btn&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt; &lt;v-fade-transition&gt; &lt;v-overlay v-if=\"!loaded\" :absolute=\"false\" opacity=\"0.8\" &gt; &lt;loaders /&gt; &lt;/v-overlay&gt; &lt;/v-fade-transition&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/v-form&gt; &lt;/v-container&gt; &lt;/template&gt; &lt;script&gt; import { mapState, mapActions, mapGetters } from \"vuex\" import RESTClient from \"@/lib/Client/RESTClient.js\" import status from \"@/data/status.json\" import BaseFields from \"../../components/Editor/GeneralInformation/BaseFields\"; import Loaders from \"../../components/Navigation/Loaders\"; let restClient = new RESTClient(); /** Component to generate the new record page and its buttons to redirect to new collection, standard, policy and database * */ export default { name: \"NewRecordPage\", components: {Loaders, BaseFields}, data(){ return { record: {}, recordsTypes: [], formValid: false, loaded: false, message: { error: false, value: null } } }, computed: { ...mapState('users', [\"user\"]), ...mapGetters('record', ['getSection']) }, async mounted(){ this.$nextTick(async function () { this.loaded = false; this.resetRecord(); await this.getData(); this.loaded = true; this.$store.commit(\"record/setCreatingNewRecord\"); }); }, methods: { ...mapActions(\"editor\", [\"getCountries\", \"getRecordTypes\", \"getTags\"]), ...mapActions(\"record\", [\"resetRecord\"]), async getData(){ await this.getCountries(); await this.getRecordTypes(); await this.getTags(); }, async createRecord(){ this.message = { error: false, value: null }; let record = JSON.parse(JSON.stringify(this.getSection(\"generalInformation\").data)); record.record_type_id = record.type.id; record.metadata.status = status; record.country_ids = record.countries.map(obj =&gt; obj.id); record.metadata.status = record.status; delete record.status; delete record.countries; delete record.type; let new_record = await restClient.createRecord(record, this.user().credentials.token); if (!new_record.error) { this.$router.push({ path: new_record.data.id + \"/edit\" }); } else { this.message = { error: true, value: new_record.error } } } }, } &lt;/script&gt; &lt;style scoped&gt; .v-autocomplete__content .v-subheader { font-size: 2rem; text-transform: capitalize; } #autocompleteSelect .v-list-item { min-height: 0 !important; } &lt;/style&gt; × Search results Close "},"components_Records_Search_Header_Pagination.vue.html":{"id":"components_Records_Search_Header_Pagination.vue.html","title":"Source: components/Records/Search/Header/Pagination.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: components/Records/Search/Header/Pagination.vue &lt;template&gt; &lt;v-pagination v-model=\"page\" :length=\"totalPages\" :total-visible=\"($vuetify.breakpoint.mdAndUp) ? 7 : 3\" /&gt; &lt;/template&gt; &lt;script&gt; import {throttle} from 'lodash'; /** Component to handle the advanced search filters for the searchFairsharingRecords query. * @vue-prop {Number} [totalPages = 0] - the total number of pages to display * @vue-data {Number} [currentQuery = null] - the current page number */ export default { name: \"Pagination\", props: { totalPages: { type: Number, default: 0 }, }, data() { return { currentPage: null, allowPaginate: true, disable: false, page: 1 } }, watch: { '$route.name': function () { this.currentPage = 1; }, '$route.query': function (newVal) { let _module = this; if (!Object.prototype.hasOwnProperty.call(newVal, \"page\")) { _module.currentPage = 1; } else { _module.currentPage = Number(newVal.page); } }, 'page': function (newPage) { this.paginate(newPage); } }, created() { let currentPage = (this.$route.query.page !== undefined) ? Number(this.$route.query.page ) : 1; this.currentPage = currentPage; this.page = currentPage; }, methods: { /** * Set the current query page parameter value to the given input for vueJs router * @param {Number} pageNumber - the page to go to */ paginate: async function (pageNumber) { if (this.allowPaginate) { if (pageNumber !== this.currentPage &amp;&amp; this.allowPaginate) { let _module = this; let currentQuery = {}; _module.currentPage = pageNumber; Object.keys(_module.$route.query).forEach(function (param) { currentQuery[param] = _module.$route.query[param] }); currentQuery.page = pageNumber; this.disableThrottle(this.disable); await _module.$router.push({ name: _module.$route.name, query: currentQuery }); } } }, /** * Postpone the pagination buttons to be clickable */ PaginatePermission: throttle(function () { this.allowPaginate = true }, 1200), /** * Set the environment ready for testing or development * @param {Boolean} disable - should disable or not the throttle for the next call */ disableThrottle: function (disable) { if (!disable) { this.allowPaginate = false; this.PaginatePermission(); } else { this.allowPaginate = true; } } }, } &lt;/script&gt; &lt;style scoped&gt; button { outline: none; } #advancedSearch { top: 20px; } &lt;/style&gt; × Search results Close "},"views_Records_Record.vue.html":{"id":"views_Records_Record.vue.html","title":"Source: views/Records/Record.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/Records/Record.vue &lt;template xmlns:v-slot=\"http://www.w3.org/1999/XSL/Transform\"&gt; &lt;v-main&gt; &lt;v-container v-if=\"queryTriggered\" fluid &gt; &lt;!-- error --&gt; &lt;div v-if=\"error\"&gt; {{error}} &lt;NotFound /&gt; &lt;/div&gt; &lt;!-- Action Menu &amp; Alert --&gt; &lt;v-row v-if=\"!target &amp;&amp; queryTriggered\" class=\"mx-1\" &gt; &lt;v-col cols=\"12\" &gt; &lt;div v-if=\"alreadyClaimed || claimedTriggered || user().is_curator\" class=\"d-flex flex-column\" &gt; &lt;v-alert v-if=\"user().is_curator &amp;&amp; currentRecord.fairsharingRecord['isHidden']\" dense type=\"info\" class=\"mb-2 flex-grow-1\" &gt; &lt;span&gt;This record is hidden!&lt;/span&gt; &lt;/v-alert&gt; &lt;v-alert v-if=\"alreadyClaimed\" dense type=\"warning\" class=\"mb-1 flex-grow-1\" &gt; &lt;span&gt; You have already requested to maintain this record. We will be getting back to you between 48 and 72h.&lt;/span&gt; &lt;/v-alert&gt; &lt;v-snackbar v-model=\"claimedTriggered\" color=\"success\" class=\"text-body\" &gt; Thank you for claiming this record. We will be getting back to you between 48 and 72h. &lt;/v-snackbar&gt; &lt;/div&gt; &lt;div v-if=\"currentRecord.fairsharingRecord['isHidden']!==undefined\" class=\"text-right\" &gt; &lt;v-menu offset-y &gt; &lt;template #activator=\"{ on, attrs }\"&gt; &lt;v-btn class=\"mt-1\" color=\"primary\" v-bind=\"attrs\" v-on=\"on\" @click=\"getMenuButtons()\" &gt; Actions &lt;v-icon small right &gt; fa-chevron-down &lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/template&gt; &lt;v-list&gt; &lt;v-list-item v-for=\"(button, index) in buttons\" :key=\"'button_' + index\" :disabled=\"button.isDisabled()\" @click=\"button.method()\" &gt; &lt;v-list-item-title&gt; {{ button.name() }} &lt;/v-list-item-title&gt; &lt;/v-list-item&gt; &lt;/v-list&gt; &lt;/v-menu&gt; &lt;/div&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- Content --&gt; &lt;div v-if=\"currentRecord['fairsharingRecord'] &amp;&amp; !error\"&gt; &lt;!-- Top Block --&gt; &lt;GeneralInfo class=\"ma-4\" :can-claim=\"canClaim\" @requestOwnership=\"requestOwnership\" /&gt; &lt;v-row no-gutters&gt; &lt;!--Left Block--&gt; &lt;v-col :cols=\"$vuetify.breakpoint.mdAndDown?'12':'6'\"&gt; &lt;!-- COLLECTIONS --&gt; &lt;Collections class=\"ma-4 mb-8\" /&gt; &lt;!-- SUPPORT --&gt; &lt;Support class=\"ma-4 mb-8\" /&gt; &lt;!-- Data Conditions --&gt; &lt;DataCondtions class=\"ma-4 mb-4\" /&gt; &lt;/v-col&gt; &lt;!--Right Block--&gt; &lt;v-col :cols=\"$vuetify.breakpoint.mdAndDown?'12':'6'\"&gt; &lt;!-- Related Content --&gt; &lt;RelatedContent class=\"ma-4 mb-8\" /&gt; &lt;!-- Tools --&gt; &lt;Tools class=\"ma-4 mb-8\" /&gt; &lt;!-- Organisations --&gt; &lt;Organisations class=\"ma-4 mb-6 mb-sm-4 \" /&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- Bottom Block --&gt; &lt;Publications class=\"mb-10 ma-4\" /&gt; &lt;/div&gt; &lt;/v-container&gt; &lt;!-- This html is from a safe source --&gt; &lt;!-- eslint-disable vue/no-v-html --&gt; &lt;script type=\"application/ld+json\" v-html=\"JSONLD\" /&gt; &lt;!-- eslint-enable vue/no-v-html --&gt; &lt;/v-main&gt; &lt;/template&gt; &lt;script&gt; import {mapActions, mapState, mapGetters, mapMutations} from 'vuex' import Client from '@/lib/GraphClient/GraphClient.js' import RestClient from \"@/lib/Client/RESTClient.js\" import stringUtils from '@/utils/stringUtils'; import GeneralInfo from \"@/components/Records/Record/GeneralInfo\"; import Tools from '@/components/Records/Record/Tools'; import DataCondtions from '@/components/Records/Record/DataConditions'; import Publications from '@/components/Records/Record/Publications'; import Support from '@/components/Records/Record/Support'; import NotFound from \"@/views/Errors/404\" import Organisations from \"@/components/Records/Record/Organisations\"; import Collections from \"@/components/Records/Record/Collections\"; import RelatedContent from \"@/components/Records/Record/RelatedContent\"; const client = new RestClient(); export default { name: \"Record\", components: { RelatedContent, Collections, Organisations, GeneralInfo, Tools, DataCondtions, Publications, Support, NotFound }, mixins: [stringUtils], props: { target: {type: Number, default: null} }, data: () =&gt; { return { error: null, queryTriggered: false, showScrollToTopButton: false, canEdit: false, canClaim: false, alreadyClaimed: false, claimedTriggered: false, buttons: [] } }, computed: { JSONLD () { return JSON.stringify(this.getField(\"schemaOrg\")); }, currentRoute() { let id = this.$route.params['id']; if (id.includes(\"FAIRsharing.\")) { return \"10.25504/\" + id; } return this.target || this.$route.params['id']; }, ...mapState('record', [\"currentRecord\", \"currentRecordHistory\"]), ...mapState('users', [\"user\", \"messages\"]), ...mapGetters(\"record\", [\"getField\"]), userIsLoggedIn(){ return this.user().isLoggedIn; }, getTitle() { return 'FAIRsharing | ' + this.currentRoute; }, }, watch: { async currentRoute() { await this.getData(); await this.checkClaimStatus(); }, async userIsLoggedIn() { await this.canEditRecord(); await this.checkClaimStatus(); } }, destroyed() { // minor change in the y axis can fix a serious bug after going back to records.. this.$scrollTo('body',5,{}) }, mounted() { this.$nextTick(async function () { this.client = new Client(); await this.getData(); await this.canEditRecord(); await this.checkClaimStatus(); }) }, methods: { ...mapActions('record', ['fetchRecord', 'fetchRecordHistory', 'fetchPreviewRecord']), ...mapActions('users', ['updateWatchedRecords']), ...mapMutations('users', ['changeWatched']), goToEdit(){ let _module = this; const recordID = '/' + _module.currentRecord['fairsharingRecord'].id; if (_module.userIsLoggedIn) { this.$router.push({ path: recordID + '/edit', params: { fromRecordPage: true } }) } else { this.$router.push({ path: \"/accounts/login\", query: { goTo: `/${_module.currentRecord['fairsharingRecord'].id}` } }) } }, /** * Method to create a maintenance_request; sets canClaim and (on fail) error. * @returns {undefined} * */ async requestOwnership() { let _module = this; const recordID = _module.currentRecord['fairsharingRecord'].id; const claim = await client.claimRecord(recordID, _module.user().credentials.token); if (claim.error) { _module.error = \"Sorry, your request to claim this record failed. Please contact us.\"; _module.canClaim = false; } else { // show modal here _module.canClaim = false; _module.claimedTriggered = true; } }, /** * Method to set the canClaim status for this record. * @returns {undefined} * */ async checkClaimStatus() { let _module = this; if (_module.user().isLoggedIn) { const recordID = _module.currentRecord['fairsharingRecord'].id; const claim = await client.canClaim(recordID, _module.user().credentials.token); if (claim.error) { if (claim.error.response.data.existing){ let maintainer = _module.getField(\"maintainers\").filter(maintainer =&gt; maintainer.username === _module.user().credentials.username); if (maintainer.length === 0){ _module.alreadyClaimed = true; } } _module.canClaim = false; } else { // show modal here _module.canClaim = !claim.existing; } } }, /** * Method to set the current record in the store * @returns {Promise} - the current record * */ async getData() { let _module = this; this.queryTriggered = false; this.error = null; this.alreadyClaimed = false; this.claimedTriggered = false; try { if (this.target) await _module.fetchPreviewRecord(this.target); else await _module.fetchRecord({ id: this.currentRoute, token: (_module.user().credentials) ? _module.user().credentials.token : null }); } catch (e) { this.error = e.message; } this.queryTriggered = true; }, /** * Method to dispatch the current record history into the store * @returns {Promise} - the current record history * */ async getHistory() { await this.$store.dispatch(\"record/fetchRecordHistory\", this.currentRoute); }, async canEditRecord(){ const _module = this; _module.canEdit = false; if (_module.user().isLoggedIn) { const recordID = _module.currentRecord['fairsharingRecord'].id; const canEdit = await client.canEdit(recordID, _module.user().credentials.token); _module.canEdit = !canEdit.error; } }, async changeWatchRecord(watch) { const _module = this; this.loading = true; let records = _module.user().watchedRecords.slice(); if (watch) { records.push(_module.currentRecord['fairsharingRecord'].id) } else { records = records.filter(function(value){ return value !== _module.currentRecord['fairsharingRecord'].id; }); } let data = { watched_record_ids: records }; let response = await this.updateWatchedRecords(data); // Refresh user data to reload followed record status. if (response.modification === 'success'){ _module.changeWatched(records); } this.loading = false; }, isWatching() { return this.currentRecord['fairsharingRecord'].id &amp;&amp; this.user().watchedRecords.includes(this.currentRecord['fairsharingRecord'].id) || false; }, getMenuButtons(){ let _module = this; _module.buttons = [ { name: function() { return \"Edit record\" }, isDisabled: function(){ if (!_module.userIsLoggedIn){ return false } return !_module.canEdit }, method: function(){return _module.goToEdit()} }, { name: function() { return \"Request ownership\" }, isDisabled: function(){ if (!_module.userIsLoggedIn){ return false } return !_module.canClaim }, method: function(){ if (!_module.userIsLoggedIn){ _module.$router.push({ path: \"/accounts/login\", query: { goTo: `/${_module.currentRecord['fairsharingRecord'].id}` } }) } else { return _module.requestOwnership() } } }, { name: () =&gt; { if (!_module.userIsLoggedIn){ return \"Watch record\" } else { if (!_module.isWatching()){ return \"Watch record\" } else { return \"Unwatch record\" } } }, isDisabled: function() { return false }, method: function(){ if (!_module.userIsLoggedIn){ _module.$router.push({ path: \"/accounts/login\", query: { goTo: `/${_module.currentRecord['fairsharingRecord'].id}` } }) } else { if (_module.isWatching()) { _module.changeWatchRecord(false); } else { _module.changeWatchRecord(true); } } } }, { name: function() { return \"View Relation Graph\" }, isDisabled: function(){ return false }, method: function(){ _module.$router.push({ path: \"/graph/\" + _module.currentRecord['fairsharingRecord'].id }) } }, { name: function() { return \"Have a suggestion/question ?\" }, isDisabled: function(){ return true}, method: function(){return null} } ]; } }, metaInfo() { try { if (!this.target) { return { title: 'FAIRsharing | ' + this.currentRecord.fairsharingRecord.abbreviation } } } catch (e) { //error } }, } &lt;/script&gt; × Search results Close "},"views_Records_Records.vue.html":{"id":"views_Records_Records.vue.html","title":"Source: views/Records/Records.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/Records/Records.vue &lt;template&gt; &lt;v-main&gt; &lt;transition name=\"fade\"&gt; &lt;jump-to-top v-if=\"scrollStatus\" /&gt; &lt;/transition&gt; &lt;v-container fluid class=\"pa-0\" &gt; &lt;!-- Title banner --&gt; &lt;div&gt; &lt;section id=\"banner\" class=\"secondary\" &gt; &lt;h1 class=\"text-center white--text\"&gt; {{ getTitle }} &lt;/h1&gt; &lt;p class=\"text-center white--text\"&gt; {{ recordsSubTitles[getTitle] }} &lt;/p&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- Content --&gt; &lt;v-row no-gutters&gt; &lt;v-col v-if=\"$vuetify.breakpoint.lgAndUp\" cols=\"12\" lg=\"4\" md=\"4\" xl=\"3\" class=\"d-flex mt-2 ml-2\" &gt; &lt;SearchInput :class=\"['search-input-mb', responsiveClassObject]\" /&gt; &lt;/v-col&gt; &lt;v-col v-else cols=\"12\" class=\"ml-3 mt-2\" &gt; &lt;v-btn class=\"info\" @click=\"showFiltersSM = true\" &gt; &lt;span class=\"mr-2\"&gt;Show filters&lt;/span&gt; &lt;v-icon small&gt; fa-filter &lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/v-col&gt; &lt;v-col class=\"mt-2\"&gt; &lt;SearchOutput class=\"pb-5 mr-0 mr-md-2 px-3\" /&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/v-container&gt; &lt;v-fade-transition&gt; &lt;v-dialog v-model=\"showFiltersSM\" fullscreen hide-overlay scrollable &gt; &lt;v-card&gt; &lt;v-card-title class=\"primary white--text pb-5\"&gt; Add a filter &lt;v-spacer /&gt; &lt;v-btn fab x-small @click=\"showFiltersSM = false\" &gt; &lt;v-icon&gt;fa-times&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/v-card-title&gt; &lt;SearchInput class=\"pa-5\" /&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;/v-fade-transition&gt; &lt;v-fade-transition&gt; &lt;v-overlay v-if=\"isLoading\" :absolute=\"false\" opacity=\"0.8\" &gt; &lt;Loaders /&gt; &lt;/v-overlay&gt; &lt;/v-fade-transition&gt; &lt;/v-main&gt; &lt;/template&gt; &lt;script&gt; import SearchInput from \"@/components/Records/Search/Input/SearchInput\"; import SearchOutput from \"@/components/Records/Search/Output/SearchOutput\"; import {mapActions, mapState, mapMutations} from 'vuex' import JumpToTop from \"@/components/Navigation/jumpToTop\"; import recordsLabels from \"@/data/recordsTypes.json\" import filterChipsUtils from \"@/utils/filterChipsUtils\"; import Loaders from \"@/components/Navigation/Loaders\"; export default { name: \"Records\", components: {Loaders, JumpToTop, SearchOutput, SearchInput}, mixins: [filterChipsUtils], data: () =&gt; ({ searchTerm: '', offsetTop: 0, bodyOverflowActive: true, hideOverflow: 'overflow-hidden', showHeader: true, showDrawerLeft: false, labels: recordsLabels, recordsSubTitles: recordsLabels['recordSubTitles'], recordTypes: recordsLabels['recordTypes'], isLoading: false, showFiltersSM: false, }), computed: { ...mapState('uiController', ['scrollStatus', 'stickToTop']), ...mapState('records', ['records']), getTitle: function () { const flipRecordTypes = Object.entries(this.recordTypes).reduce( (obj, [key, value]) =&gt; ({...obj, [value]: key}), {} ); let title = \"Search\"; if (Object.prototype.hasOwnProperty.call(this.$route.query, 'fairsharingRegistry')) { if (Object.prototype.hasOwnProperty.call(flipRecordTypes, this.$route.query.fairsharingRegistry)) { title = flipRecordTypes[this.$route.query.fairsharingRegistry]; } } return title; }, responsiveClassObject: function () { return { 'left-panel-fixed-lg': this.stickToTop &amp;&amp; this.$vuetify.breakpoint.xlOnly, 'left-panel-default-lg': !this.stickToTop &amp;&amp; this.$vuetify.breakpoint.xlOnly, 'left-panel-default': !this.stickToTop &amp;&amp; !this.$vuetify.breakpoint.xlOnly, 'left-panel-fixed': this.stickToTop &amp;&amp; !this.$vuetify.breakpoint.xlOnly } }, currentPath: function () { let title = this.$route.path.replace('/', ''); const client = this; let queryParams = {}; Object.keys(this.$route.query).forEach(function (prop) { let queryVal = client.$route.query[prop]; if (queryVal) { queryParams[prop] = decodeURI(queryVal); } }); if (this.recordTypes[title.charAt(0).toUpperCase() + title.slice(1)]) { title = this.recordTypes[title.charAt(0).toUpperCase() + title.slice(1)] } else title = title.charAt(0).toUpperCase() + title.slice(1); return [title, queryParams]; }, }, watch: { currentPath: async function () { this.$scrollTo('body',50,{}); await this.tryRedirect(); } }, mounted: function () { window.addEventListener(\"scroll\", this.onScroll); this.$nextTick(async function () { await this.tryRedirect(); this.$scrollTo('body',50,{}) }); }, beforeDestroy() { this.cleanRecordsStore(); }, destroyed() { this.$scrollTo('body', 50, {}) window.removeEventListener(\"scroll\", this.onScroll); this.setStickToTop(false); this.$store.dispatch(\"uiController/setGeneralUIAttributesAction\", { drawerVisibilityState: false, headerVisibilityState: true, }); }, methods: { ...mapMutations('records',['cleanRecordsStore']), ...mapActions('records', ['fetchRecords']), ...mapActions('uiController', ['setScrollStatus', 'setStickToTop']), onScroll: function () { let _module = this; _module.offsetTop = window.top.scrollY; if (_module.offsetTop &gt; 100 &amp;&amp; _module.records.length &gt; 1) { _module.setStickToTop(true); _module.$store.dispatch(\"uiController/setGeneralUIAttributesAction\", { headerVisibilityState: false, }); } else { _module.setStickToTop(false); _module.$store.dispatch(\"uiController/setGeneralUIAttributesAction\", { drawerVisibilityState: false, headerVisibilityState: true, }); } _module.offsetTop &gt; 500 ? _module.setScrollStatus(true) : _module.setScrollStatus(false); }, /** * Try to redirect to search of the page that is hit is /standards /databases * /policies or /collections * */ tryRedirect: async function () { if (Object.keys(this.recordTypes).includes(this.$route.name)) { let fairsharingRegistry = this.recordTypes[this.$route.name]; let query = this.$route.params; if (query &amp;&amp; query !== {}) { query.fairsharingRegistry = fairsharingRegistry; try { await this.$router.push({ name: \"search\", query: query }); return true; } catch (e) { // } } } await this.getData(); }, /** This methods get the data from the client. * @returns {Promise} */ getData: async function () { this.$scrollTo('body',50,{}); this.isLoading = true; this.errors = null; const _module = this; try { this.showFiltersSM = false; await _module.fetchRecords(this.getParameters()); } catch (e) { this.errors = e.message; } this.isLoading = false; }, /** * Get the parameters that are allowed for this query * @returns {Object} parameters - parameters and types allowed for this query */ getParameters: function () { return this.$store.getters[\"introspection/buildQueryParameters\"](this.currentPath); }, }, /** * Setting up the metaInfo of the page * @returns {{title: String}} * */ metaInfo() { return { title: 'FAIRsharing | ' + this.getTitle } }, } &lt;/script&gt; &lt;style scoped lang=\"scss\"&gt; .left-panel-fixed { position: sticky; top: 0; width: 32vw; } .left-panel-default { position: relative; width: 32vw; } .left-panel-fixed-lg { position: sticky; top: 0; width: 24vw; } .left-panel-default-lg { position: relative; width: 24vw; } .content-custom-new-height { height: calc(100vh - 40px); scroll-behavior: smooth; padding: 0; } .content-custom { height: 100vh; scroll-behavior: smooth; padding: 0; } #banner { display: flex; justify-content: center; flex-direction: column; padding: 1em; } .search-input-mb{ margin-bottom: 105px; } &lt;/style&gt; × Search results Close "},"components_Records_Record_RelatedContent.vue.html":{"id":"components_Records_Record_RelatedContent.vue.html","title":"Source: components/Records/Record/RelatedContent.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: components/Records/Record/RelatedContent.vue &lt;template xmlns:v-slot=\"http://www.w3.org/1999/XSL/Transform\"&gt; &lt;v-card class=\"pa-4 d-flex flex-column\" outlined color=\"bg_record_card\" tile elevation=\"3\" &gt; &lt;SectionTitle title=\"Related Content\" :inactive-section=\"tabsDataExist\" /&gt; &lt;div class=\"d-flex flex-column ml-2 min-height-40\"&gt; &lt;div class=\"d-flex flex-wrap mt-5\"&gt; &lt;!-- search autocomplete --&gt; &lt;v-autocomplete v-if=\"!tabsDataExist\" v-model=\"selectedValues\" :disabled=\"tabsData.tabs[Object.keys(tabsData.tabs)[tabsData.selectedTab]].data.length&lt;5\" :items=\"getValues\" solo :attach=\"true\" dense clearable prepend-inner-icon=\"fa-search\" :placeholder=\"`Search through ${cleanString(Object.keys(tabsData.tabs)[tabsData.selectedTab])}`\" item-text=\"name\" item-value=\"name\" &gt; &lt;template #item=\"data\"&gt; &lt;span class=\"filterValueName\"&gt; {{ data.item.name }} &lt;/span&gt; &lt;/template&gt; &lt;/v-autocomplete&gt; &lt;/div&gt; &lt;!-- tabs --&gt; &lt;v-tabs v-if=\"!tabsDataExist\" v-model=\"tabsData.selectedTab\" background-color=\"transparent\" grow color=\"accent3\" slider-color=\"accent3\" class=\"mb-5\" :hide-slider=\"tabsData.tabs[Object.keys(tabsData.tabs)[tabsData.selectedTab]].data.length===0\" &gt; &lt;v-tab v-for=\"(tabName,tabIndex) in Object.keys(tabsData.tabs)\" :key=\"tabName+'_'+tabIndex\" :disabled=\"tabsData.tabs[tabName].data.length===0\" @change=\"selectedValues=null\" &gt; {{ cleanString(tabName) }} &lt;/v-tab&gt; &lt;/v-tabs&gt; &lt;!-- tab content --&gt; &lt;v-tabs-items v-if=\"!tabsDataExist\" v-model=\"tabsData.selectedTab\" class=\"transparent height-430\" &gt; &lt;v-tab-item v-for=\"(tabItem,tabItemIndex) in filterList\" :key=\"tabItem+'_'+tabItemIndex\" &gt; &lt;v-virtual-scroll :items=\"tabItem.data\" height=\"400\" item-height=\"130\" class=\"ma-4 overflow-x-hidden\" &gt; &lt;template #default=\"{ item,index }\"&gt; &lt;v-card :key=\"item.id + '_' + index\" class=\"pa-4 d-flex flex-column v-card-hover mx-2 height-120\" flat outlined &gt; &lt;div class=\"d-flex align-center\"&gt; &lt;record-status :record=\"item\" :show-status=\"false\" /&gt; &lt;div class=\"ml-10 text-ellipses-height-2lines line-height-20\"&gt; {{ item.name }} &lt;/div&gt; &lt;/div&gt; &lt;p class=\"grey--text relation-style text-ellipses-height-2lines line-height-14\"&gt; {{ item.subject }} &lt;v-tooltip top&gt; &lt;template #activator=\"{ on }\"&gt; &lt;span class=\"red--text mouse-info\" v-on=\"on\" &gt; {{ item.recordAssocLabel }} &lt;/span&gt; &lt;/template&gt; &lt;span&gt;{{ relationDefinition[item.recordAssocLabel] }}&lt;/span&gt; &lt;/v-tooltip&gt; {{ item.name }} &lt;/p&gt; &lt;/v-card&gt; &lt;/template&gt; &lt;/v-virtual-scroll&gt; &lt;/v-tab-item&gt; &lt;/v-tabs-items&gt; &lt;/div&gt; &lt;/v-card&gt; &lt;/template&gt; &lt;script&gt; import SectionTitle from '@/components/Records/Record/SectionTitle'; import {mapState} from \"vuex\"; import stringUtils from \"@/utils/stringUtils\" import RecordStatus from \"@/components/Records/Shared/RecordStatus\"; import recordTabUtils from \"@/utils/recordTabUtils\"; import recordRelationShipsDefinitions from \"@/data/RecordRelationShipsDefinitions.json\"; export default { name: \"RelatedContent\", components: { RecordStatus, SectionTitle, }, mixins:[stringUtils,recordTabUtils], data: () =&gt; { return { relationDefinition: recordRelationShipsDefinitions, selectedValues: null, tabsData: { selectedTab: 0, tabs: { related_standards: {relation: ['collects', 'recommends'], registry: \"Standard\", data: []}, related_databases: {relation: ['collects', 'recommends'], registry: \"Database\", data: []} } } } }, computed: { ...mapState(\"record\", [\"currentRecord\"]), }, methods: { /** Dynamically sets data for each tabs based on the data received from recordAssociations and reverseAssociations*/ prepareTabsData() { const _module = this; if (Object.keys(_module.currentRecord['fairsharingRecord']).includes('recordAssociations') || Object.keys(_module.currentRecord['fairsharingRecord']).includes('reverseRecordAssociations')) { Object.keys(_module.tabsData.tabs).forEach(tabName =&gt; { _module.tabsData.tabs[tabName].data = _module.prepareAssociations(_module.currentRecord['fairsharingRecord'].recordAssociations, _module.currentRecord['fairsharingRecord']['reverseRecordAssociations']) .filter(item =&gt; !_module.tabsData.tabs[tabName].relation.includes(item.recordAssocLabel) &amp;&amp; item.registry === _module.tabsData.tabs[tabName].registry) }); } else { return false } }, } } &lt;/script&gt; &lt;style scoped lang=\"scss\"&gt; a { text-decoration: none; &amp;:hover, &amp;:focus { text-decoration: underline; outline: 0; } } .filterValueName { text-overflow: ellipsis; overflow: hidden; white-space: nowrap; flex: 1; } .mt-1-pt { margin-top: 1pt; } &lt;/style&gt; × Search results Close "},"components_Records_Search_Input_SearchInput.vue.html":{"id":"components_Records_Search_Input_SearchInput.vue.html","title":"Source: components/Records/Search/Input/SearchInput.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: components/Records/Search/Input/SearchInput.vue &lt;template&gt; &lt;v-card id=\"scrollable-holder\" :class=\"['pa-2', ($vuetify.breakpoint.mdAndUp) ? responsiveClassObject : 'fullHeight']\" outlined tile elevation=\"3\" width=\"100%\" &gt; &lt;!-- Search Box --&gt; &lt;string-search placeholder=\"Search through all data.\" /&gt; &lt;hr class=\"mb-3 mr-2 ml-2 custom-hr\"&gt; &lt;!-- Filter Buttons --&gt; &lt;FilterButtons /&gt; &lt;!-- expansion Panels --&gt; &lt;v-expansion-panels v-if=\"getFilters.length&gt;0\" v-model=\"panel\" multiple flat hover accordion &gt; &lt;filter-autocomplete v-for=\"filter in setup\" :key=\"filter.filterLabel\" :filter=\"filter\" /&gt; &lt;/v-expansion-panels&gt; &lt;/v-card&gt; &lt;/template&gt; &lt;script&gt; import {mapGetters, mapState} from \"vuex\" import filterMapping from \"@/data/FiltersLabelMapping.json\"; import FilterAutocomplete from \"./FilterAutocomplete\"; import FilterButtons from \"./FilterButtons\"; import StringSearch from \"@/components/Records/Search/Input/StringSearch\"; export default { name: \"SearchInput\", components: {StringSearch, FilterButtons, FilterAutocomplete}, data() { return { panel: [], filterSelected: {}, sortOrder: filterMapping['sort_order'], } }, computed: { ...mapState('uiController', ['UIGeneralStatus']), ...mapGetters(\"searchFilters\", [\"getFilters\"]), setup() { let _module = this; _module.setPanel(); _module.createIndexForFilters(); return _module.getFilters.sort(_module.compareLabels); }, responsiveClassObject: function () { return { 'filters-holder-default': this.UIGeneralStatus.headerVisibilityState, 'filters-holder-after-scroll': !this.UIGeneralStatus.headerVisibilityState, } } }, methods: { setPanel() { this.panel = [...Array(this.getFilters.length).keys()].map((k, i) =&gt; i) }, resetPanel() { this.panel = [] }, createIndexForFilters: function () { this.getFilters.forEach(item =&gt; { this.filterSelected[item.filterName] = []; }); }, /** * This gets the index of the name of the filter from the list above, so that the fields can be sorted on the * users' preferences. But, some terms may not be in the list, so they are given the index of 100 to force * them to appear later. */ compareLabels: function(a, b) { let _module = this; const aIndex = _module.sortOrder.indexOf(a['filterName']); const bIndex = _module.sortOrder.indexOf(b['filterName']); const aOrder = aIndex === -1 ? 100 : aIndex; const bOrder = bIndex === -1 ? 100 : bIndex; let comparison = -1; if (aOrder &gt; bOrder) { comparison = 1; } return comparison; } } } &lt;/script&gt; &lt;style scoped&gt; .filters-holder-default { border-radius: 0; -moz-border-radius: 0; -webkit-border-radius: 0; overflow-x: hidden; height: calc(100vh - 230px); position: sticky; top: 0; transition: height ease-in 500ms; } .filters-holder-after-scroll { border-radius: 0; -moz-border-radius: 0; -webkit-border-radius: 0; overflow-x: hidden; height: 100vh; position: sticky; top: 0; transition: height ease-in 500ms; } .custom-hr { opacity: .5; } .fullHeight { height: 90vh; overflow: scroll; } &lt;/style&gt; × Search results Close "},"views_Users_Signup.vue.html":{"id":"views_Users_Signup.vue.html","title":"Source: views/Users/Signup.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/Users/Signup.vue &lt;template&gt; &lt;Register /&gt; &lt;/template&gt; &lt;script&gt; import Register from \"../../components/Users/Register\"; /** This component handles the sign-up/register page * */ export default { name: \"Signup\", components: {Register} } &lt;/script&gt; × Search results Close "},"components_Records_Search_Header_Sorting.vue.html":{"id":"components_Records_Search_Header_Sorting.vue.html","title":"Source: components/Records/Search/Header/Sorting.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: components/Records/Search/Header/Sorting.vue &lt;template&gt; &lt;v-list&gt; &lt;v-list-item v-for=\"(item, index) in getFilters()\" :key=\"'sorter_' + index\" :class=\"{'v-list-item--active': activeFilter === item.name + ',' + item.order}\" @click=\"applySortQuery(item.name, item.order)\" &gt; &lt;v-list-item-title&gt; {{ item.label }} ({{ item.orderLabel }}) &lt;/v-list-item-title&gt; &lt;/v-list-item&gt; &lt;/v-list&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"Sorting\", data() { return { sortFilters: [ {name: 'name', label: 'name', active: false}, {name: 'abbreviation', label: 'abbreviation', active: false}, {name: '_score', label: 'best-match', active: false}, ], activeFilter: null } }, mounted(){ const _module = this; _module.activeFilter = (_module.$route.query.orderBy) ? _module.$route.query.orderBy : '_score,asc'; }, methods: { /** * Set the orderBy parameter value to the given input for vueJs router * @param {string} activeSortFilterName - sorting under this name * @param {string} sortMethod - can be either ASC or DESC */ applySortQuery: async function (activeSortFilterName, sortMethod) { let _module = this; let inputOrderBy = `${activeSortFilterName},${sortMethod}`; let currentQuery = JSON.parse(JSON.stringify(_module.$route.query)); currentQuery[\"orderBy\"] = inputOrderBy; if (inputOrderBy !== _module.activeFilter){ await _module.$router.push({ name: _module.$route.name, query: currentQuery }); } }, getFilters: function(){ let filters = []; this.sortFilters.forEach(function(filter){ filters.push({ label: filter.label, name: filter.name, order: \"asc\", orderLabel: \"ascending\" }); if (filter.name !== '_score') { filters.push({ label: filter.label, name: filter.name, order: \"desc\", orderLabel: \"descending\" }) } }); return filters; } } } &lt;/script&gt; &lt;style scoped&gt; .highlighted { color: red !important; } &lt;/style&gt; × Search results Close "},"store_recordData.js.html":{"id":"store_recordData.js.html","title":"Source: store/recordData.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: store/recordData.js import Vue from \"vue\" import { isEqual } from \"lodash\" import Client from \"../lib/GraphClient/GraphClient.js\" import RESTClient from \"@/lib/Client/RESTClient.js\" import recordQuery from \"../lib/GraphClient/queries/getRecord.json\" import recordHistory from '../lib/GraphClient/queries/getRecordHistory.json' import recordOrganisationsQuery from \"../lib/GraphClient/queries/getRecordOrganisations.json\" import recordDataAccessQuery from \"../lib/GraphClient/queries/editor/getRecordDataAccess.json\" import recordRelationsQuery from \"../lib/GraphClient/queries/editor/getRecordRelations.json\" import { initEditorSections } from \"./utils.js\" let client = new Client(); let restClient = new RESTClient(); /** * The record store handles the requests related to record (fairsharingRecord). * @type {Object} */ let recordStore = { namespaced: true, state: { currentRecord: { fairsharingRecord: { metadata: { citations: [] } } }, currentRecordHistory: {}, recordUpdate: { error: false, message: null, id: null }, sections: { generalInformation: initEditorSections(false, [\"generalInformation\"]).generalInformation }, editOrganisationLink: { showOverlay: false, data: {}, id: null }, newRecord: false, currentID: null }, mutations: { setCurrentRecord(state, data){ state.currentRecord = data; let tags = ['subjects', 'domains', 'taxonomies', 'userDefinedTags']; tags.forEach(tag =&gt; { if (state.currentRecord['fairsharingRecord'][tag].length &amp;&amp; state.currentRecord['fairsharingRecord'][tag] ) { state.currentRecord['fairsharingRecord'][tag].forEach(item =&gt; { item.type = tag; }) } }) }, setRecordHistory(state, data){ state.currentRecordHistory = data; }, resetCurrentRecordHistory(state){ state.currentRecordHistory = {}; }, setSections(state, data){ state.currentID = data['fairsharingRecord'].id; let sectionsNames = [ \"generalInformation\", \"support\", \"dataAccess\", \"publications\", \"organisations\", \"additionalInformation\", \"relations\" ]; state.sections = initEditorSections(data['fairsharingRecord'], sectionsNames); }, setGeneralInformation(state, data){ state.sections.generalInformation = initEditorSections( data['fairsharingRecord'], [\"generalInformation\"] ).generalInformation; if(data['fairsharingRecord']) state.sections.generalInformation.message = \"Record successfully updated!\"; }, resetMessage(state, sectionName){ state.sections[sectionName].message = null; state.sections[sectionName].message = false; }, setSectionError(state, error){ state.sections[error.section].message = error.value; state.sections[error.section].error = true; }, setChanges(state, diff){ state.sections[diff.section].changes = diff.value; }, setContacts(state, contacts){ state.sections.generalInformation.data.metadata.contacts = contacts; }, setTags(state, field){ state.sections.generalInformation.data[field.target] = field.value; }, resetRegistry(state){ state.sections.generalInformation.data.type = \"\"; }, setPublications(state, publications) { state.sections.publications.data = publications; }, setAdditionalInformation(state, additionalInformation) { if (!additionalInformation.subfieldName){ Vue.set(state.sections.additionalInformation.data, additionalInformation.fieldName, additionalInformation.fieldValue ); } else { Vue.set(state.sections.additionalInformation.data[additionalInformation.fieldName], additionalInformation.subfieldName, additionalInformation.fieldValue ); } }, setAdditionalInformationSubField(state, additionalInformation) { if (additionalInformation.id !== null) { state.sections.additionalInformation.data[additionalInformation.fieldName][additionalInformation.id] = additionalInformation.fieldValue; } else { if (!state.sections.additionalInformation.data[additionalInformation.fieldName]){ Vue.set(state.sections.additionalInformation.data, additionalInformation.fieldName,[]); } Vue.set(state.sections.additionalInformation.data[additionalInformation.fieldName], state.sections.additionalInformation.data[additionalInformation.fieldName].length, additionalInformation.fieldValue ); } }, removeAdditionalInformationSubField(state, additionalInformation){ state.sections.additionalInformation.data[additionalInformation.fieldName].splice(additionalInformation.id, 1) }, updateOrganisationsLinks(state, links){ state.sections.organisations.data = links; state.sections.organisations.initialData = JSON.parse(JSON.stringify(links)); state.sections.organisations.changes = 0; state.sections.organisations.message = \"Record successfully updated!\"; }, setEditOrganisationLink(state, newLink){ state.editOrganisationLink = newLink; }, setEditOrganisationLinkOrganisation(state, organisation){ state.editOrganisationLink.data.organisation = organisation; }, setEditOrganisationLinkGrant(state, grant) { state.editOrganisationLink.data.grant = grant; }, setDataAccess(state, dataAccess){ let record = { licences: dataAccess['licenceLinks'], support_links: dataAccess.metadata.support_links }; state.sections.generalInformation.data.metadata.support_links = JSON.parse(JSON.stringify(record.support_links)); state.sections.generalInformation.initialData.metadata.support_links = JSON.parse(JSON.stringify(record.support_links)); record.support_links.forEach(supportLink =&gt; { if (supportLink.name) supportLink.url = {title: supportLink.name, url: supportLink.url} }); state.sections.dataAccess.data = record; state.sections.dataAccess.initialData = JSON.parse(JSON.stringify(record)); state.sections.dataAccess.changes = 0; state.sections.dataAccess.message = \"Record successfully updated!\"; }, updateAdditionalInformation(state, additionalInformation) { let record = {}; Object.keys(additionalInformation.record).forEach(field =&gt; { record[field] = additionalInformation.record[field]; state.sections.generalInformation.data.metadata[field] = JSON.parse(JSON.stringify(record[field])); state.sections.generalInformation.initialData.metadata[field] = JSON.parse(JSON.stringify(record[field])); }); state.sections.additionalInformation.data = record; state.sections.additionalInformation.initialData = JSON.parse(JSON.stringify(record)); state.sections.additionalInformation.changes = 0; state.sections.additionalInformation.message = \"Record successfully updated!\"; }, setCreatingNewRecord(state){ state.newRecord = true; }, setEditingRecord(state){ state.newRecord = false; }, setRelations(state, relations){ state.sections.relations.data.recordAssociations = relations; state.sections.relations.initialData.recordAssociations = JSON.parse(JSON.stringify(relations)); state.sections.relations.changes = 0; state.sections.relations.message = \"Record successfully updated!\"; state.sections.relations.error = false; }, setMessage(state, message){ state.sections[message.target].message = message.value; }, setNewRecord(state, id){ state.recordUpdate = { error: false, message: \"success\", id: id } }, setError(state, error){ state.recordUpdate = { error: true, message: error, id: null } }, cleanRecordStore(state){ state.sections = null; state.sections = initEditorSections(false, [ \"generalInformation\", \"support\", \"dataAccess\", \"publications\", \"organisations\", \"additionalInformation\" ]); } }, actions: { async fetchRecord(state, options){ state.commit(\"resetCurrentRecordHistory\"); recordQuery.queryParam = { id: options.id }; if (options.token) { client.setHeader(options.token); } let data = await client.executeQuery(recordQuery); client.initalizeHeader() if (!data[\"fairsharingRecord\"]['metadata']['contacts']) { data[\"fairsharingRecord\"]['metadata']['contacts'] = []; } // Citations should be created if empty. if (!data[\"fairsharingRecord\"]['metadata']['citations']) { data[\"fairsharingRecord\"]['metadata']['citations'] = []; } state.commit('setCurrentRecord', JSON.parse(JSON.stringify(data))); state.commit('setSections', JSON.parse(JSON.stringify(data))); }, async fetchPreviewRecord(state, id){ state.commit(\"resetCurrentRecordHistory\"); recordQuery.queryParam = { id: id }; let data = await client.executeQuery(recordQuery); state.commit('setCurrentRecord', data); }, async fetchRecordHistory(state, id){ recordHistory.queryParam = {id: id}; let data = await client.executeQuery(recordHistory); state.commit('setRecordHistory', data[\"fairsharingRecord\"]); }, async updateGeneralInformation({ state, commit}, options) { commit(\"resetMessage\", \"generalInformation\"); let { type, countries, userDefinedTags, domains, subjects, taxonomies, status, ...record } = JSON.parse(JSON.stringify(state.sections.generalInformation.data)), newTags = [], oldTags = [], tags = []; userDefinedTags.forEach(tag =&gt; { if (Object.keys(tag).indexOf(\"id\") === -1){ newTags.push(tag.label) } else { oldTags.push(tag.id) } }); newTags = await Promise.all(newTags.map(tag =&gt; restClient.createNewUserDefinedTag(tag, options.token)) ); newTags.forEach((tag) =&gt; { if (!tag.error) { tags.push(tag.id); } else { commit(\"setSectionError\", { section: \"generalInformation\", value: tag.error }); return tag.error; } }); record.country_ids = countries.map(obj =&gt; obj.id); if (type.id) record.record_type_id = type.id; record.metadata.status = status; record.domain_ids = domains.map(obj =&gt; obj.id); record.subject_ids = subjects.map(obj =&gt; obj.id); record.taxonomy_ids = taxonomies.map(obj =&gt; obj.id); record.user_defined_tag_ids = tags.concat(oldTags.filter(function (el) {return el != null;})); let response = await restClient.updateRecord({ record: record, token: options.token, id: options.id }); if (response.error){ commit(\"setSectionError\", { section: \"generalInformation\", value: response.error }); return response.error; } else { let newRecord = JSON.parse(JSON.stringify(state.sections.generalInformation.data)); let userDefinedTags = []; newRecord.userDefinedTags.forEach(obj =&gt; { if (Object.keys(obj).indexOf(\"id\") === -1) { obj.id = newTags.filter(tag =&gt; {tag.label = obj.label})[0]; userDefinedTags.push(obj); } else userDefinedTags.push(obj); }); newRecord.userDefinedTags = userDefinedTags; commit('setGeneralInformation', {fairsharingRecord: newRecord}); } }, async updatePublications({ state, commit }, options) { commit(\"resetMessage\", \"publications\"); let publications = JSON.parse(JSON.stringify(state.sections.publications.data)); let record_data = { publication_ids: [], citation_ids: [] }; publications.forEach(function (publication) { record_data.publication_ids.push(publication.id); if (publication.isCitation) { record_data.citation_ids.push(publication.id); } delete publication.isCitation; }); const record = { record: record_data, token: options.token, id: options.id }; let response = await restClient.updateRecord(record); if (response.error) { commit(\"setSectionError\", { section: \"publications\", value: response.error }); return response.error; } else { commit(\"setMessage\", {target: \"publications\", value: \"Record successfully updated!\"}); } }, async updateOrganisations({state, commit}, userToken){ commit(\"resetMessage\", \"organisations\"); let deleteItems = [], updateItems = [], createItems = []; state.sections.organisations.initialData.forEach((obj) =&gt; { let found = state.sections.organisations.data.filter(org =&gt; org.id === obj.id)[0]; if (!found) { deleteItems.push(obj); } }); state.sections.organisations.data.forEach(function(obj) { let query = { fairsharing_record_id: state.currentRecord['fairsharingRecord'].id, organisation_id: obj.organisation.id, relation: obj.relation, grant_id: (obj.grant) ? obj.grant.id : null, is_lead: obj.isLead }; if (Object.prototype.hasOwnProperty.call(obj, 'id')) updateItems.push({query: query, id: obj.id}); else createItems.push(query); }); let queries = await Promise.all([ ...deleteItems.map(organisation =&gt; restClient.deleteOrganisationLink(organisation.id, userToken)), ...createItems.map(organisation =&gt; restClient.createOrganisationLink(organisation, userToken)), ...updateItems.map(organisation =&gt; restClient.updateOrganisationLink(organisation.query, organisation.id, userToken)) ]); queries.forEach((org) =&gt; { if (org.error) { commit(\"setSectionError\", { section: \"organisations\", value: org.error }); } }); recordOrganisationsQuery.queryParam = {id: state.currentRecord.fairsharingRecord.id}; let organisations = await client.executeQuery(recordOrganisationsQuery); commit('updateOrganisationsLinks', organisations.fairsharingRecord.organisationLinks); }, async updateAdditionalInformation({ state, commit}, options){ commit(\"resetMessage\", \"additionalInformation\"); let newRecord = { metadata: state.sections.generalInformation.initialData.metadata, }; options.fields.forEach(field =&gt; { if (state.sections.additionalInformation.data[field]) { newRecord.metadata[field] = state.sections.additionalInformation.data[field] } }); let response = await restClient.updateRecord({ record: newRecord, token: options.token, id: options.id }); if (response.error) { commit(\"setSectionError\", { section: \"additionalInformation\", value: response.error }); return response.error; } else { commit(\"setMessage\", {target: \"additionalInformation\", value: \"Record successfully updated!\"}); commit('updateAdditionalInformation', {record: newRecord.metadata, fields: options.fields}); } }, async updateDataAccess({state, commit}, options){ commit(\"resetMessage\", \"dataAccess\"); let newRecord = { metadata: state.sections.generalInformation.initialData.metadata, }; newRecord.metadata.support_links = state.sections.dataAccess.data.support_links; newRecord.metadata.support_links.forEach(supportLink =&gt; { if (typeof supportLink.url !== 'string') { supportLink.url = supportLink.url.url; } }); let initialLicences = state.sections.dataAccess.initialData.licences, currentLicences = state.sections.dataAccess.data.licences, toDelete = [], toUpdate = [], toCreate = []; initialLicences.forEach(licence =&gt; { let found = currentLicences.filter(obj =&gt; obj.id === licence.id)[0]; if (!found) toDelete.push(licence.id); }); currentLicences.forEach(licence =&gt; { let found = initialLicences.filter(obj =&gt; obj.id === licence.id)[0], newLicence = prepareLicence(licence); if (!found){ toCreate.push(newLicence); } else if (found &amp;&amp; !isEqual(licence, found)) { toUpdate.push(newLicence); } }); let responses = await Promise.all([ restClient.updateRecord({ record: newRecord, token: options.token, id: options.id }), ...toCreate.map(licence =&gt; restClient.createLicenceLink(licence, options.token)), ...toUpdate.map(licence =&gt; restClient.updateLicenceLink(licence, options.token)), ...toDelete.map(licence =&gt; restClient.deleteLicenceLink(licence, options.token)) ]); responses.forEach((response) =&gt; { if (response.error) { commit(\"setSectionError\", { section: \"dataAccess\", value: response.error }); return response.error; } }); recordDataAccessQuery.queryParam = {id: state.currentRecord.fairsharingRecord.id}; let dataAccess = await client.executeQuery(recordDataAccessQuery); commit('setDataAccess', dataAccess.fairsharingRecord); }, async updateRelations({state, commit}, options){ commit(\"resetMessage\", \"relations\"); let newAssociations = [], deleteAssociations = [], oldAssociations = []; state.sections.relations.data.recordAssociations.forEach(association =&gt; { if (association.new) { const newAssociation = { fairsharing_record_id: options.source, linked_record_id: association.linkedRecord.id, record_assoc_label_id: association.recordAssocLabel.id }; newAssociations.push(newAssociation); } else { oldAssociations.push(association.linkedRecord.id); } }); state.sections.relations.initialData.recordAssociations.forEach(oldAssociation =&gt; { let id = oldAssociation.linkedRecord.id; if (id &amp;&amp; !oldAssociations.includes(id)) { deleteAssociations.push({ id: oldAssociation.id, _destroy: 1 }); } }); let responses = await Promise.all([ restClient.saveRelations({ token: options.token, relations: newAssociations, target: options.source }), restClient.deleteRelations({ token: options.token, relations: deleteAssociations, target: options.source }) ]); let error = false; for (let response of responses) { if (response.error) { commit(\"setSectionError\", { section: \"relations\", value: response.error }); error = true; } } if (!error){ recordRelationsQuery.queryParam = {id: options.source}; let relations = await client.executeQuery(recordRelationsQuery); commit('setRelations', relations['fairsharingRecord'].recordAssociations); } }, resetRecord(state){ state.commit('setGeneralInformation', {fairsharingRecord: false}); }, async updateRecord(state, newRecord){ let response = await restClient.updateRecord(newRecord); if (response.error){ state.commit(\"setError\", response.error.response) } else { state.commit(\"setNewRecord\", response) } } }, getters: { getField: (state) =&gt; (fieldName) =&gt; { return state.currentRecord['fairsharingRecord'][fieldName]; }, getSection: (state) =&gt; (sectionName) =&gt; { return state.sections[sectionName]; }, getChanges: (state) =&gt; { let changes = {}; Object.keys(state.sections).forEach(section =&gt; { changes[section] = state.sections[section].changes }); return changes; }, getAllChanges: (state) =&gt; { let changes = 0; Object.keys(state.sections).forEach(section =&gt; { changes += state.sections[section].changes; }); return changes; }, getCreatingNewRecord: (state) =&gt; { return state.newRecord; }, getRecordType: (state) =&gt; { return state.sections['generalInformation'].initialData.type } } }; function prepareLicence(rawLicence){ let preparedLicence = { relation: rawLicence.relation }; preparedLicence.fairsharing_record_id = (rawLicence.fairsharingRecord) ? rawLicence.fairsharingRecord.id : rawLicence.fairsharing_record_id; if (rawLicence.id) preparedLicence.id = rawLicence.id; if (rawLicence.licence.id){ preparedLicence.licence_id = rawLicence.licence.id } else { preparedLicence.licence_attributes = rawLicence.licence; } return preparedLicence; } export default recordStore; × Search results Close "},"utils_recordTabUtils.js.html":{"id":"utils_recordTabUtils.js.html","title":"Source: utils/recordTabUtils.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: utils/recordTabUtils.js const recordTabUtils = { computed: { /** Fetch content related to each tab and feed search autocomplete*/ getValues() { let selectedTabKey = Object.keys(this.tabsData.tabs) return this.tabsData.tabs[selectedTabKey[this.tabsData.selectedTab]].data; }, /** Deactivate the section if none of the tabs hold data*/ tabsDataExist() { let inactiveTabs = true for (const [key] of Object.entries(this.filterList)) { if (this.filterList[key].data.length &gt;= 1) { inactiveTabs = false break } } return inactiveTabs }, /** Filter down list if search box value changes unless it returns the whole data in a list*/ filterList() { const _module = this // here I deep copied object so the references are gone and my object is a new object with unique reference const output = JSON.parse(JSON.stringify(_module.tabsData.tabs)); if (this.selectedValues !== null &amp;&amp; this.selectedValues !== \"\" &amp;&amp; this.selectedValues !== undefined) { let foundItem = output[Object.keys(_module.tabsData.tabs)[_module.tabsData.selectedTab]].data.find(item =&gt; item.name === _module.selectedValues) if (foundItem) { output[Object.keys(output)[_module.tabsData.selectedTab]].data = [] output[Object.keys(output)[_module.tabsData.selectedTab]].data.push(foundItem) } return output } return output } }, methods: { /** Combines associations and reserveAssociations into a single array and prepare the data for the search table */ prepareAssociations(associations, reverseAssociations) { let _module = this; let recordAssociations = [] let joinedArrays = associations.concat(reverseAssociations); const properties = ['fairsharingRecord', 'linkedRecord']; joinedArrays.forEach(item =&gt; { let object = {}; properties.forEach(prop =&gt; { if (Object.prototype.hasOwnProperty.call(item, prop)) { object.recordAssocLabel = _module.cleanString(item.recordAssocLabel); object.id = item[prop].id; object.registry = item[prop].registry; object.name = item[prop].name; object.subject = _module.currentRecord['fairsharingRecord'].name; object.type = item[prop].type; } }); recordAssociations.push(object); }); return recordAssociations; }, /** active the very first tab that contains at least one item */ getFirstActiveTab() { let firstActiveTabIndex = 0; let index = -1 for (const [key] of Object.entries(this.filterList)) { index++ if (this.filterList[key].data.length &gt;= 1) { firstActiveTabIndex = index break } } this.tabsData.selectedTab = firstActiveTabIndex } }, beforeMount() { this.prepareTabsData(); this.getFirstActiveTab(); } } export default recordTabUtils; × Search results Close "},"lib_Client_RESTClient.js.html":{"id":"lib_Client_RESTClient.js.html","title":"Source: lib/Client/RESTClient.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: lib/Client/RESTClient.js import axios from \"axios\" class RESTClient { /** * The RESTClient is a singleton class that handles the connection and data exchange from the back-end * REST API. */ constructor(){ if (RESTClient._instance){ return RESTClient._instance } RESTClient._instance = this; this.baseURL = process.env.VUE_APP_API_ENDPOINT; this.headers = { \"Accept\": \"application/json\", \"Content-Type\": \"application/json\", \"Cache-Control\": \"no-cache\" }; } /* USERS: all methods below related to handling user authentication */ /** * Method to add authorisation to the headers. * @param jwt - the user's json web token * @return {JSON} - headers with authorisation field added */ auth_headers(jwt) { let headers = JSON.parse(JSON.stringify(this.headers)); headers['Authorization'] = 'Bearer ' + jwt; return headers; } /** * Method to log in the user * @param username - name of the user * @param password - password of the user * @return {Promise} - the response of the server */ async login(username, password){ const endpoint = \"/users/sign_in\"; const body = { user: { login: username, password: password } }; const request = { method: \"post\", baseURL: this.baseURL + endpoint, data: body, headers: this.headers }; let response = await this.executeQuery(request); return response.data; } /** * Logout the user from the back, expiring the current jwt. * @param {String} jwt - the user token to expire. * @returns {Promise} */ async logout(jwt){ const request = { method: \"delete\", baseURL: this.baseURL + \"/users/sign_out\", headers: this.auth_headers(jwt) }; let response = await this.executeQuery(request); return response.data; } /** * Method to create a new user * @param {Object} userLogin - the user account to create * @returns {Promise} response - server response */ async createAccount(userLogin){ const request = { method: \"post\", baseURL: this.baseURL + \"/users\", data: {user: userLogin}, headers: this.headers }; let response = await this.executeQuery(request); return response.data; } /** * Validate the account given the corresponding token * @param {String} token - the account token to validate * @returns {Promise} */ async confirmAccount(token){ const request = { method: \"get\", baseURL: this.baseURL + \"/users/confirmation?confirmation_token=\" + token, headers: this.headers, }; let response = await this.executeQuery(request); return response.data; } /** * Method to send a reset password link to the given email address * @param {String} email to send the link to * @returns {Promise} */ async requestResetPwd(email){ const request = { method: \"post\", baseURL: this.baseURL + \"/users/password\", headers: this.headers, data: { user: {email: email} } }; let response = await this.executeQuery(request); return response.data; } /** * Resend the validation link for a given user * @param {Object} user - contains the email of the user. * @returns {Promise} */ async resendConfirmation(user) { const request = { method: \"post\", baseURL: this.baseURL + \"/users/confirmation\", headers: this.headers, data: {user: user} }; let response = await this.executeQuery(request); return response.data; } /** * Reset the password of the given user * @param {Object} user - contains the new pwd, repeated pwd and token. * @returns {Promise} */ async resetPassword(user){ const request = { method: \"put\", baseURL: this.baseURL + \"/users/password\", headers: this.headers, data: {user: user} }; let response = await this.executeQuery(request); return response.data; } /** * Changes the password of the logged in user * @param {String} jwt - the user token * @param {Object} user - contains the current, new and repeated new password * @returns {Promise} */ async resetPasswordWithoutToken(jwt, user){ const request = { method: \"put\", baseURL: this.baseURL + \"/users/\", headers: this.auth_headers(jwt), data: {user: user} }; let response = await this.executeQuery(request); return response.data; } /** * Verify the validity of the given password * @param {String} password - the password to test * @returns {Promise} */ async verifyPassword(password){ let headers = JSON.parse(JSON.stringify(this.headers)); const request = { method: \"post\", baseURL: this.baseURL + \"/users/check_password\", headers: headers, data: {password: password} }; let response = await this.executeQuery(request); return response.data; } /** * Get the current user data * @param jwt * @returns {Promise} */ async getUser(jwt){ const request = { method: \"get\", baseURL: this.baseURL + \"/users/edit\", headers: this.auth_headers(jwt) }; let response = await this.executeQuery(request); return response.data; } /** * Edit the current logged in user profile * @param {Object} newUser - the new values for the logged in user * @param {String} jwt - JWT of the logged in user * @returns {Promise} */ async editUser(newUser, jwt){ const request = { method: \"put\", baseURL: this.baseURL + \"/users\", headers: this.auth_headers(jwt), data: {user: newUser} }; let response = await this.executeQuery(request); return response.data; } /** * Verify that the given JWT is still valid * @param {String} jwt - the token to validate * @returns {Promise} */ async validateToken(jwt){ const request = { method: \"get\", baseURL: this.baseURL + \"/users/valid\", headers: this.auth_headers(jwt) }; let response = await this.executeQuery(request); return response.data; } /* EDITORS METHODS */ /** * Post the given object to the API to create the corresponding record. * @param record * @param {String} jwt - JWT of the logged in user * @returns {Promise} */ async createRecord(record, jwt){ const request = { method: \"post\", baseURL: this.baseURL + \"/fairsharing_records\", headers: this.auth_headers(jwt), data: {fairsharing_record: record} }; let response = await this.executeQuery(request); return response.data; } /** * Update the given record * @param {Object} record - the record to update containing the ID to target, the new values * and the user token * @returns {Promise} */ async updateRecord(record){ const request = { method: \"put\", baseURL: this.baseURL + \"/fairsharing_records/\" + record.id, headers: this.auth_headers(record.token), data: {fairsharing_record: record.record} }; let response = await this.executeQuery(request); return response.data; } /** * Determine if a user has permission to edit this record. * @param {Integer} recordID - ID for the relevant FairsharingRecord. * @param {String} userToken - JWT of the logged in user * @returns {Promise} */ async canEdit(recordID, userToken){ const request = { method: \"get\", baseURL: this.baseURL + \"/fairsharing_records/can_edit/\" + recordID, headers: this.auth_headers(userToken), }; let response = await this.executeQuery(request); return response.data; } /** * Attempt to create a MaintenanceRequest for a user for a FairsharingRecord. * @param {Integer} recordID - ID for the relevant FairsharingRecord. * @param {String} userToken - JWT of the logged in user * @returns {Promise} */ async claimRecord(recordID, userToken) { const request = { method: \"post\", baseURL: this.baseURL + \"/maintenance_requests\", headers: this.auth_headers(userToken), data: {maintenance_request: {fairsharing_record_id: recordID}} }; let response = await this.executeQuery(request); return response.data; } /** * Determine if a user has permission to create a MaintenanceRequest for a FairsharingRecord. * @param {Integer} recordID - ID for the relevant FairsharingRecord. * @param {String} userToken - JWT of the logged in user * @returns {Promise} */ async canClaim(recordID, userToken) { const request = { method: \"get\", baseURL: this.baseURL + \"/maintenance_requests/existing/\" + recordID, headers: this.auth_headers(userToken), }; let response = await this.executeQuery(request); return response.data; } /* USER DEFINED TAGS */ /** * Create a new user defined tag in the database for users to tag their records. * @param {String} term - the string value of the term * @param {String} token - the user JWT * @returns {Promise} */ async createNewUserDefinedTag(term, token){ const request = { method: \"post\", baseURL: this.baseURL + \"/user_defined_tags\", headers: this.auth_headers(token), data: {user_defined_tag: {label:term}} }; let response = await this.executeQuery(request); return response.data; } /* LICENCES */ /** * Create new a licence link * @param {Object} licenceLink - the licence link to create * @param {String} token - the user token * @returns {Promise} */ async createLicenceLink(licenceLink, token){ let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/licence_links\", headers: this.auth_headers(token), data: {licence_link: licenceLink} }; let response = await _client.executeQuery(request); return response.data; } /** * Delete the given licence * @param {Number} id - id of the licence link to delete * @param {String} token - the user token * @returns {Promise} */ async deleteLicenceLink(id, token){ let _client = this; const request = { method: \"delete\", baseURL: _client.baseURL + \"/licence_links/\" + id, headers: this.auth_headers(token), }; let response = await _client.executeQuery(request); return response.data; } /** * Update the licenceLink * @param {Object} licenceLink - the new values for the licence link * @param {String} token the user token * @returns {Promise} */ async updateLicenceLink(licenceLink, token){ let _client = this; const request = { method: \"put\", baseURL: _client.baseURL + \"/licence_links/\" + licenceLink.id, headers: this.auth_headers(token), data: {licence_link: licenceLink} }; let response = await _client.executeQuery(request); return response.data; } /* PUBLICATIONS */ async createPublication(publication, token){ let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/publications\", headers: this.auth_headers(token), data: { publication: publication } }; let response = await _client.executeQuery(request); return response.data; } async editPublication(publication, token){ let _client = this; const request = { method: \"put\", baseURL: _client.baseURL + \"/publications/\" + publication.id, headers: this.auth_headers(token), data: { publication: publication } }; let response = await _client.executeQuery(request); return response.data; } /* RELATIONSHIPS BETWEEN RECORDS */ /** * Saves the relationships as an array of items containing a targetID, a sourceID and a labelID * @param {Object} options - the options to pass as {token: String, relations: Array} * @returns {Promise} */ async saveRelations(options){ const request = { method: 'put', baseURL: this.baseURL + '/fairsharing_records/' + options.target, headers: this.auth_headers(options.token), data: {fairsharing_record: {record_associations_attributes: options.relations}} }; let response = await this.executeQuery(request); return response.data; } /** * Deletes the relationships as an array of items containing a targetID, a sourceID and a labelID * @param {Object} options - the options to pass as {token: String, relations: Array} * @returns {Promise} */ async deleteRelations(options){ const request = { method: 'put', baseURL: this.baseURL + '/fairsharing_records/' + options.target, headers: this.auth_headers(options.token), data: {fairsharing_record: {record_associations_attributes: options.relations}} }; let response = await this.executeQuery(request); return response.data; } /* ORGANISATIONS AND GRANTS */ /** * Create a given organisation * @param {Object} organisation * @param {String} userToken - the user jwt * @returns {Promise} */ async createOrganisation(organisation, userToken){ let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/organisations\", headers: this.auth_headers(userToken), data: { organisation: organisation } }; let response = await _client.executeQuery(request); return response.data; } /** * Create a given grant * @param {Object} grant * @param {String} userToken - the user jwt * @returns {Promise} */ async createGrant(grant, userToken){ let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/grants\", headers: this.auth_headers(userToken), data: { grant: grant } }; let response = await _client.executeQuery(request); return response.data; } /** * Create a new link between an organisation, a record and an optional grant. * @param {Object} organisationLink - the organisation link to create * @param {String} userToken - the user jwt * @returns {Promise} */ async createOrganisationLink(organisationLink, userToken){ let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/organisation_links\", headers: this.auth_headers(userToken), data: { organisation_link: organisationLink } }; let response = await _client.executeQuery(request); return response.data; } /** * Update the organisationLink given from linkID input with the given organisationLink * @param {Object} organisationLink - the new organisation link value * @param {Number} linkID - ID of the organisationLink to update * @param {String} userToken - the user jwt * @returns {Promise} */ async updateOrganisationLink(organisationLink, linkID, userToken){ let _client = this; const request = { method: \"put\", baseURL: _client.baseURL + \"/organisation_links/\" + linkID, headers: this.auth_headers(userToken), data: { organisation_link: organisationLink } }; let response = await _client.executeQuery(request); return response.data; } /** * Delete the given organisation link * @param {Number} linkID - the id of the link to remove * @param {String} userToken - the user jwt * @returns {Promise} */ async deleteOrganisationLink(linkID, userToken){ let _client = this; const request = { method: \"delete\", baseURL: _client.baseURL + \"/organisation_links/\" + linkID, headers: this.auth_headers(userToken), }; let response = await _client.executeQuery(request); return response.data; } /** * Get the extra metadata fields for a RecordType * @param {String} type - name of the record type. * @param {String} userToken - the user jwt * @returns {Promise} */ async extraMetadataFields(type, userToken) { const request = { method: \"post\", baseURL: this.baseURL + \"/fairsharing_records/metadata_fields\", headers: this.auth_headers(userToken), data: {type: type} }; let response = await this.executeQuery(request); return response.data; } /* METHODS FOR CURATION */ /** * Update the maintenanceRequest given the new status value * @param {Number} maintenanceRequest ID of the maintenanceRequest to update * @param {string} newStatus - new status to update * @param {String} userToken - the user jwt * @returns {Promise} */ async updateStatusMaintenanceRequest(maintenanceRequest, newStatus, userToken){ let _client = this; const request = { method: \"put\", baseURL: _client.baseURL + \"/maintenance_requests/\" + maintenanceRequest, headers: this.auth_headers(userToken), data: { maintenance_request: {status: newStatus}} }; let response = await _client.executeQuery(request); return response.data; } /** * Delete Record * @param {Number} id - id of the record link to delete * @param {String} token - the user token * @returns {Promise} */ async deleteRecord(id, token){ let _client = this; const request = { method: \"delete\", baseURL: _client.baseURL + \"/fairsharing_records/\" + id, headers: this.auth_headers(token), }; let response = await _client.executeQuery(request); return response.data; } /** * Get the list of allowed relation types for editing record's relationships. * @returns {Promise} */ /* EDITOR DATA */ async getRelationsTypes(){ let _client = this; const request = { method: \"get\", baseURL: _client.baseURL + \"/record_associations/allowed\" }; let response = await _client.executeQuery(request); return response.data; } /** * Get the list of available profile types for a user. * @returns {Promise} */ async getProfileTypes(){ const request = { method: \"get\", baseURL: this.baseURL + \"/users/profile_types\", headers: this.headers, }; let response = await this.executeQuery(request); return response.data; } /* EXTRA METHODS */ /** * Trigger the given query with Axios * @param query * @returns {Promise&lt;*&gt;} */ async executeQuery(query) { try { return await axios(query); } catch(e){ return({data: {error: e}}); } } /** * Get records without DOIS * @param {String} token - the user token that needs to be a curator * @returns {Promise} */ async getRecordsWoDOIs(userToken){ let _client = this; const request = { method: \"get\", baseURL: _client.baseURL + \"/files/no_dois\", headers: this.auth_headers(userToken), }; let response = await _client.executeQuery(request); return response.data; } } export default RESTClient; × Search results Close "},"views_Static_Community_Community.vue.html":{"id":"views_Static_Community_Community.vue.html","title":"Source: views/Static/Community/Community.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/Static/Community/Community.vue &lt;template&gt; &lt;h2&gt;Community&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; /** * All static pages will be handle through this namespace * @namespace Static */ /** This component handles the sign-up/register page * @memberOf Static * @name Community * @type module * @instance * */ export default { name: \"Community\", title: \"This will be the community page\", methods: { greet: function () { return 0 } } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; × Search results Close "},"views_Static_Educational_Educational.vue.html":{"id":"views_Static_Educational_Educational.vue.html","title":"Source: views/Static/Educational/Educational.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/Static/Educational/Educational.vue &lt;template&gt; &lt;div&gt; &lt;h2&gt;This will be the educational page&lt;/h2&gt; &lt;div id=\"faq10-1\" class=\"anchor\" style=\"position:relative;top:5000px;\" &gt; This is a test anchor for internal links &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; /** This component handles the sign-up/register page * @memberOf Static * @name Educational * @type module * @instance * */ export default { name: \"Educational\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; × Search results Close "},"views_Static_License_License.vue.html":{"id":"views_Static_License_License.vue.html","title":"Source: views/Static/License/License.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/Static/License/License.vue &lt;template&gt; &lt;h2&gt;This will be the API/License page&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; /** This component handles the sign-up/register page * @memberOf Static * @name License * @type module * @instance * */ export default { name: \"License\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; × Search results Close "},"views_Static_Stakeholders_Stakeholders.vue.html":{"id":"views_Static_Stakeholders_Stakeholders.vue.html","title":"Source: views/Static/Stakeholders/Stakeholders.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/Static/Stakeholders/Stakeholders.vue &lt;template&gt; &lt;h2&gt;This will be the Stakeholders page&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; /** This component handles the sign-up/register page * @memberOf Static * @name Stakeholders * @type module * @instance * */ export default { name: \"Stakeholders\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; × Search results Close "},"views_Static_Timeline_Timeline.vue.html":{"id":"views_Static_Timeline_Timeline.vue.html","title":"Source: views/Static/Timeline/Timeline.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Source: views/Static/Timeline/Timeline.vue &lt;template&gt; &lt;h2&gt;This will be the time-line page&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; /** This component handles the sign-up/register page * @memberOf Static * @name Timeline * @type module * @instance * */ export default { name: \"Timeline\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Global Members &lt;constant&gt; buildFacets Given an object containing the raw facets coming from the client and a mapping object , build the ready to use facets for usage by the Vue components. Source: store/recordSearch.js, line 96 &lt;constant&gt; buildFilters Given a searchFairsharingRecords aggregations array, build the values used by the advanced search widgets Source: store/searchFilters.js, line 123 filtersStore :Object The searchFilters store trigger a single field query to searchFairsharingRecords, gets the aggregation array and builds the filtering system to be used by advanced search functions. Type: Object Source: store/searchFilters.js, line 102 introspectionStore :Object The introspection store is related to the introspection query that let us know which fields/types are allowed by the searchFairsharingRecords query Type: Object Source: store/introspector.js, line 97 &lt;constant&gt; paramsAreExpired Compares the given date with now and returns true if it greater than the given timer Source: store/introspector.js, line 142 recordsStore :Object The records store handles the requests related to records (searchFairsharingRecords and fairsharingRecord). Type: Object Source: store/recordSearch.js, line 73 recordStore :Object The record store handles the requests related to record (fairsharingRecord). Type: Object Source: store/recordData.js, line 19 states :Object Type: Object Properties: Name Type Description errors String collects errors while introspecting. searchQueryParameters object filters query parameters object coming from API. Source: store/introspector.js, line 99 Methods hasValue(val) Assess if the string is of a certain value (useful to compare passwords) Parameters: Name Type Description val String the value to evaluate the string against Source: utils/rules.js, line 6 Returns: Type function isEmail() Assess email patterns. Source: utils/rules.js, line 14 Returns: Type function isImage() Assess if the given file has the correct extension Source: utils/rules.js, line 70 Returns: Type function isLongEnough(length) Assess if the string is long enough. Parameters: Name Type Description length Number the length to evaluate the string against. Source: utils/rules.js, line 46 Returns: Type function isOrcid() Assess ORCID patterns. Can be empty if required is false. Source: utils/rules.js, line 58 Returns: Type function isRequired() Assess the presence of the field Source: utils/rules.js, line 25 Returns: Type function isUrl() Assess URL patterns. Source: utils/rules.js, line 33 Returns: Type function parseParam(param, paramVal) Given a type and a value, parse the value with the expected type. Parameters: Name Type Description param Object the parameter types allowed paramVal String the value to be parsed Source: store/introspector.js, line 125 Returns: paramVal - the parse value Type String | Number | Boolean Example Example usage of parseParam parseParam({name: \"Boolean\"}, \"true\"); // return True × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Modules Classes ExternalRESTClients GraphQLClient RESTClient Namespaces Static × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Classes Classes ExternalRESTClients GraphQLClient RESTClient Namespaces Static × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Namespaces Classes ExternalRESTClients GraphQLClient RESTClient Namespaces Static × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates FAIRsharing.org Welcome to the new FAIRsharing.org website. Compiles and hot-reloads for development npm run serve Test with vue-cli &amp; generate coverage npm run test:unit Generate the documentation locally npm run doc:full × Search results Close "},"ExternalRESTClients.html":{"id":"ExternalRESTClients.html","title":"Class: ExternalRESTClients","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Class: ExternalRESTClients ExternalRESTClients new ExternalRESTClients() The RESTClient is a singleton class that handles the connection and data exchange from the back-end REST API. Source: lib/Client/ExternalClients.js, line 9 Methods &lt;async&gt; executeQuery(query) Trigger the given query with Axios Parameters: Name Type Description query Source: lib/Client/ExternalClients.js, line 70 Returns: Type Promise.&lt;*&gt; × Search results Close "},"GraphQLClient.html":{"id":"GraphQLClient.html","title":"Class: GraphQLClient","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Class: GraphQLClient GraphQLClient new GraphQLClient() The GraphQLClient retrieves data from the FAIRSharing API and sends it to the front-end. Be careful, this is a singleton and trying to cast new instances will return the existing instance. Be also careful, its constructor is async !! Source: lib/GraphClient/GraphClient.js, line 11 Returns: to use this object you need to do \"await new ClassName()\" or use .then(callback) Type Promise Methods buildQuery(query) Transform the JSON query into a string for graphQL Parameters: Name Type Description query Object the query coming from the JSON file Source: lib/GraphClient/GraphClient.js, line 59 Returns: {query: queryString} - a valid graphQL query string to execute Type Object &lt;async&gt; executeQuery(query) Execute the given query (coming from a json file, see /queries/getRecords.json) Parameters: Name Type Description query Object the query coming from the JSON file sending to the API. Source: lib/GraphClient/GraphClient.js, line 26 Returns: Type Promise &lt;async&gt; getData(queryString) Takes the query, post it with axios and returns the raw data Parameters: Name Type Description queryString Object processed request coming out of buildQuery() or a GraphQL query string Source: lib/GraphClient/GraphClient.js, line 43 Returns: an axios promise representing the server response. Type Promise setHeader(jwt) Add the authorization token to the headers Parameters: Name Type Description jwt String the user json web token Source: lib/GraphClient/GraphClient.js, line 126 × Search results Close "},"module-Curator.html":{"id":"module-Curator.html","title":"Module: Curator","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Module: Curator Data Name Type Default value Description hideFields Object - an array of field to NOT display × Search results Close "},"module-Home.html":{"id":"module-Home.html","title":"Module: Home","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Module: Home Component to handle the front page (landing page) Source: views/Home/Home.vue, line 11 × Search results Close "},"module-Login.html":{"id":"module-Login.html","title":"Module: Login","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Module: Login This component handles the login page Source: views/Users/Login/Login.vue, line 10 × Search results Close "},"module-NewRecord.html":{"id":"module-NewRecord.html","title":"Module: NewRecord","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Module: NewRecord Component to generate the new record page and its buttons to redirect to new collection, standard, policy and database Source: views/CreateRecord/NewRecord.vue, line 13 × Search results Close "},"module-Pagination.html":{"id":"module-Pagination.html","title":"Module: Pagination","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Module: Pagination Component to handle the advanced search filters for the searchFairsharingRecords query. Props Name Type Default value Required? Description totalPages Number 0 No the total number of pages to display Data Name Type Default value Description currentQuery Number null the current page number Methods disableThrottle(disable) Set the environment ready for testing or development Parameters: Name Type Description disable Boolean should disable or not the throttle for the next call Source: components/Records/Search/Header/Pagination.vue, line 88 paginate(pageNumber) Set the current query page parameter value to the given input for vueJs router Parameters: Name Type Description pageNumber Number the page to go to Source: components/Records/Search/Header/Pagination.vue, line 59 × Search results Close "},"module-PublicProfile.html":{"id":"module-PublicProfile.html","title":"Module: PublicProfile","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Module: PublicProfile Data Name Type Default value Description hideFields Object - an array of field to NOT display × Search results Close "},"module-Signup.html":{"id":"module-Signup.html","title":"Module: Signup","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Module: Signup This component handles the sign-up/register page Source: views/Users/Signup.vue, line 6 × Search results Close "},"module-User.html":{"id":"module-User.html","title":"Module: User","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Module: User Data Name Type Default value Description hideFields Object - an array of field to NOT display × Search results Close "},"RESTClient.html":{"id":"RESTClient.html","title":"Class: RESTClient","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Class: RESTClient RESTClient new RESTClient() The RESTClient is a singleton class that handles the connection and data exchange from the back-end REST API. Source: lib/Client/RESTClient.js, line 9 Methods auth_headers(jwt) Method to add authorisation to the headers. Parameters: Name Type Description jwt the user's json web token Source: lib/Client/RESTClient.js, line 29 Returns: headers with authorisation field added Type JSON &lt;async&gt; canClaim(recordID, userToken) Determine if a user has permission to create a MaintenanceRequest for a FairsharingRecord. Parameters: Name Type Description recordID Integer ID for the relevant FairsharingRecord. userToken String JWT of the logged in user Source: lib/Client/RESTClient.js, line 312 Returns: Type Promise &lt;async&gt; canEdit(recordID, userToken) Determine if a user has permission to edit this record. Parameters: Name Type Description recordID Integer ID for the relevant FairsharingRecord. userToken String JWT of the logged in user Source: lib/Client/RESTClient.js, line 279 Returns: Type Promise &lt;async&gt; claimRecord(recordID, userToken) Attempt to create a MaintenanceRequest for a user for a FairsharingRecord. Parameters: Name Type Description recordID Integer ID for the relevant FairsharingRecord. userToken String JWT of the logged in user Source: lib/Client/RESTClient.js, line 295 Returns: Type Promise &lt;async&gt; confirmAccount(token) Validate the account given the corresponding token Parameters: Name Type Description token String the account token to validate Source: lib/Client/RESTClient.js, line 95 Returns: Type Promise &lt;async&gt; createAccount(userLogin) Method to create a new user Parameters: Name Type Description userLogin Object the user account to create Source: lib/Client/RESTClient.js, line 79 Returns: response - server response Type Promise &lt;async&gt; createGrant(grant, userToken) Create a given grant Parameters: Name Type Description grant Object userToken String the user jwt Source: lib/Client/RESTClient.js, line 484 Returns: Type Promise &lt;async&gt; createLicenceLink(licenceLink, token) Create new a licence link Parameters: Name Type Description licenceLink Object the licence link to create token String the user token Source: lib/Client/RESTClient.js, line 350 Returns: Type Promise &lt;async&gt; createNewUserDefinedTag(term, token) Create a new user defined tag in the database for users to tag their records. Parameters: Name Type Description term String the string value of the term token String the user JWT Source: lib/Client/RESTClient.js, line 330 Returns: Type Promise &lt;async&gt; createOrganisation(organisation, userToken) Create a given organisation Parameters: Name Type Description organisation Object userToken String the user jwt Source: lib/Client/RESTClient.js, line 466 Returns: Type Promise &lt;async&gt; createOrganisationLink(organisationLink, userToken) Create a new link between an organisation, a record and an optional grant. Parameters: Name Type Description organisationLink Object the organisation link to create userToken String the user jwt Source: lib/Client/RESTClient.js, line 502 Returns: Type Promise &lt;async&gt; createRecord(record, jwt) Post the given object to the API to create the corresponding record. Parameters: Name Type Description record jwt String JWT of the logged in user Source: lib/Client/RESTClient.js, line 245 Returns: Type Promise &lt;async&gt; deleteLicenceLink(id, token) Delete the given licence Parameters: Name Type Description id Number id of the licence link to delete token String the user token Source: lib/Client/RESTClient.js, line 368 Returns: Type Promise &lt;async&gt; deleteOrganisationLink(linkID, userToken) Delete the given organisation link Parameters: Name Type Description linkID Number the id of the link to remove userToken String the user jwt Source: lib/Client/RESTClient.js, line 539 Returns: Type Promise &lt;async&gt; deleteRecord(id, token) Delete Record Parameters: Name Type Description id Number id of the record link to delete token String the user token Source: lib/Client/RESTClient.js, line 593 Returns: Type Promise &lt;async&gt; deleteRelations(options) Deletes the relationships as an array of items containing a targetID, a sourceID and a labelID Parameters: Name Type Description options Object the options to pass as {token: String, relations: Array} Source: lib/Client/RESTClient.js, line 447 Returns: Type Promise &lt;async&gt; editUser(newUser, jwt) Edit the current logged in user profile Parameters: Name Type Description newUser Object the new values for the logged in user jwt String JWT of the logged in user Source: lib/Client/RESTClient.js, line 210 Returns: Type Promise &lt;async&gt; executeQuery(query) Trigger the given query with Axios Parameters: Name Type Description query Source: lib/Client/RESTClient.js, line 640 Returns: Type Promise.&lt;*&gt; &lt;async&gt; extraMetadataFields(type, userToken) Get the extra metadata fields for a RecordType Parameters: Name Type Description type String name of the record type. userToken String the user jwt Source: lib/Client/RESTClient.js, line 556 Returns: Type Promise &lt;async&gt; getProfileTypes() Get the list of available profile types for a user. Source: lib/Client/RESTClient.js, line 623 Returns: Type Promise &lt;async&gt; getRecordsWoDOIs(token) Get records without DOIS Parameters: Name Type Description token String the user token that needs to be a curator Source: lib/Client/RESTClient.js, line 654 Returns: Type Promise &lt;async&gt; getUser(jwt) Get the current user data Parameters: Name Type Description jwt Source: lib/Client/RESTClient.js, line 194 Returns: Type Promise &lt;async&gt; login(username, password) Method to log in the user Parameters: Name Type Description username name of the user password password of the user Source: lib/Client/RESTClient.js, line 41 Returns: the response of the server Type Promise &lt;async&gt; logout(jwt) Logout the user from the back, expiring the current jwt. Parameters: Name Type Description jwt String the user token to expire. Source: lib/Client/RESTClient.js, line 64 Returns: Type Promise &lt;async&gt; requestResetPwd(email) Method to send a reset password link to the given email address Parameters: Name Type Description email String to send the link to Source: lib/Client/RESTClient.js, line 110 Returns: Type Promise &lt;async&gt; resendConfirmation(user) Resend the validation link for a given user Parameters: Name Type Description user Object contains the email of the user. Source: lib/Client/RESTClient.js, line 128 Returns: Type Promise &lt;async&gt; resetPassword(user) Reset the password of the given user Parameters: Name Type Description user Object contains the new pwd, repeated pwd and token. Source: lib/Client/RESTClient.js, line 144 Returns: Type Promise &lt;async&gt; resetPasswordWithoutToken(jwt, user) Changes the password of the logged in user Parameters: Name Type Description jwt String the user token user Object contains the current, new and repeated new password Source: lib/Client/RESTClient.js, line 161 Returns: Type Promise &lt;async&gt; saveRelations(options) Saves the relationships as an array of items containing a targetID, a sourceID and a labelID Parameters: Name Type Description options Object the options to pass as {token: String, relations: Array} Source: lib/Client/RESTClient.js, line 430 Returns: Type Promise &lt;async&gt; updateLicenceLink(licenceLink, token) Update the licenceLink Parameters: Name Type Description licenceLink Object the new values for the licence link token String the user token Source: lib/Client/RESTClient.js, line 385 Returns: Type Promise &lt;async&gt; updateOrganisationLink(organisationLink, linkID, userToken) Update the organisationLink given from linkID input with the given organisationLink Parameters: Name Type Description organisationLink Object the new organisation link value linkID Number ID of the organisationLink to update userToken String the user jwt Source: lib/Client/RESTClient.js, line 521 Returns: Type Promise &lt;async&gt; updateRecord(record) Update the given record Parameters: Name Type Description record Object the record to update containing the ID to target, the new values and the user token Source: lib/Client/RESTClient.js, line 262 Returns: Type Promise &lt;async&gt; updateStatusMaintenanceRequest(maintenanceRequest, newStatus, userToken) Update the maintenanceRequest given the new status value Parameters: Name Type Description maintenanceRequest Number ID of the maintenanceRequest to update newStatus string new status to update userToken String the user jwt Source: lib/Client/RESTClient.js, line 575 Returns: Type Promise &lt;async&gt; validateToken(jwt) Verify that the given JWT is still valid Parameters: Name Type Description jwt String the token to validate Source: lib/Client/RESTClient.js, line 226 Returns: Type Promise &lt;async&gt; verifyPassword(password) Verify the validity of the given password Parameters: Name Type Description password String the password to test Source: lib/Client/RESTClient.js, line 177 Returns: Type Promise × Search results Close "},"Static.html":{"id":"Static.html","title":"Namespace: Static","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationPublicProfileSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehasValueintrospectionStoreisEmailisImageisLongEnoughisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordsStorerecordStorestates Namespace: Static Static All static pages will be handle through this namespace Source: views/Static/Community/Community.vue, line 2 Members Community :module This component handles the sign-up/register page Type: module Source: views/Static/Community/Community.vue, line 6 Educational :module This component handles the sign-up/register page Type: module Source: views/Static/Educational/Educational.vue, line 2 License :module This component handles the sign-up/register page Type: module Source: views/Static/License/License.vue, line 2 Stakeholders :module This component handles the sign-up/register page Type: module Source: views/Static/Stakeholders/Stakeholders.vue, line 2 Timeline :module This component handles the sign-up/register page Type: module Source: views/Static/Timeline/Timeline.vue, line 2 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
