<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_Client_ExternalClients.js.html":{"id":"lib_Client_ExternalClients.js.html","title":"Source: lib/Client/ExternalClients.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: lib/Client/ExternalClients.js import axios from \"axios\" class ExternalRESTClients { /** * The RESTClient is a singleton class that handles the connection and data exchange from the back-end * REST API. */ constructor() { if (ExternalRESTClients._instance) { return ExternalRESTClients._instance } ExternalRESTClients._instance = this; this.doiBaseURL = 'https://dx.doi.org/'; this.headers = { 'Accept': 'application/x-bibtex', }; this.pmidBaseURL = \"https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&amp;retmode=json&amp;id=\"; this.tessBaseURL = \"https://tess.elixir-europe.org/materials.json?q=\"; this.orcidBaseURL = \"https://pub.orcid.org/v2.0/\"; this.rorOrganisationsBaseURL = \"https://api.ror.org/organizations?query=\"; } async getDOI(doi){ let localHeaders = this.headers; localHeaders['Accept'] = 'application/json'; const request = { url: this.doiBaseURL + doi, headers: localHeaders }; let response = await this.executeQuery(request); return response.data; } async getPMID(id){ const request = { url: this.pmidBaseURL + id, headers: { 'Accept': 'application/json', } }; let response = await this.executeQuery(request); return response.data; } async getTessRecords(string){ const request = { url: this.tessBaseURL + string, headers: this.headers }; let response = await this.executeQuery(request); return response.data; } async getOrcidUser(user){ this.headers['Accept'] = \"application/orcid+json\"; const request = { url: this.orcidBaseURL + user, headers: this.headers }; let response = await this.executeQuery(request); this.headers['Accept'] = 'application/x-bibtex'; return response.data; } async getROROrganisation(organisation){ let localHeaders = this.headers; localHeaders['Accept'] = 'application/json'; const request = { url: this.rorOrganisationsBaseURL + organisation, headers: localHeaders }; let response = await this.executeQuery(request); return response.data; } /** * Trigger the given query with Axios * @param query * @returns {Promise&lt;*&gt;} */ async executeQuery(query) { try { return await axios.get(query.url, {headers: query.headers}); } catch(e){ return({data: {error: e}}); } } } export default ExternalRESTClients; × Search results Close "},"lib_GraphClient_GraphClient.js.html":{"id":"lib_GraphClient_GraphClient.js.html","title":"Source: lib/GraphClient/GraphClient.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: lib/GraphClient/GraphClient.js const axios = require(\"axios\"); import Fragments from \"./queries/fragments/fragments.json\"; class GraphQLClient { /** The GraphQLClient retrieves data from the FAIRSharing API and sends it to the front-end. * Be careful, this is a singleton and trying to cast new instances will return the existing instance. Be * also careful, its constructor is async !! * @returns {Promise} - to use this object you need to do \"await new ClassName()\" or use .then(callback) */ constructor() { this.initalizeHeader(); if (GraphQLClient._instance) { return GraphQLClient._instance; } GraphQLClient._instance = this; this.url = process.env.VUE_APP_API_ENDPOINT + \"/graphql\"; } /** * Execute the given query (coming from a json file, see /queries/getRecords.json) * @param {Object} query - the query coming from the JSON file * sending to the API. * @returns {Promise} */ async executeQuery(query) { let client = this; let queryString = { query: `{${client.buildQuery(query)}}`, }; let resp = await this.getData(queryString); if (resp.data.errors) { return resp.data.errors; } return resp.data.data; } /** * Takes the query, post it with axios and returns the raw data * @param {Object} queryString - processed request coming out of buildQuery() or a GraphQL query string * @returns {Promise} - an axios promise representing the server response. */ async getData(queryString) { let client = this; const fullQuery = { method: \"post\", baseURL: client.url, data: queryString, headers: client.headers, }; return axios(fullQuery); } /** * Transform the JSON query into a string for graphQL * @param {Object} query - the query coming from the JSON file * @returns {Object} {query: queryString} - a valid graphQL query string to execute */ buildQuery(query) { let client = this; let queryString = `${query[\"queryName\"]}`; // query name // Handle query parameters if (query.queryParam) { queryString += \"(\"; Object.keys(query.queryParam).forEach(function (key) { if ( typeof query.queryParam[key] === \"boolean\" || typeof query.queryParam[key] === \"number\" ) { queryString += `${key}:${query.queryParam[key]} `; } else if (typeof query.queryParam[key] === \"string\") { //Modified to adjust multiple arguments in GraphQl query params const regExp = /\\(|\\)|\\{|\\}/g; const hasBrackets = regExp.test(query.queryParam[key]); if (hasBrackets) queryString += `${key}:${query.queryParam[key]}`; else queryString += `${key}:\"${query.queryParam[key]}\" `; // queryString += `${key}:\"${query.queryParam[key]}\" `; } else { let param = []; query.queryParam[key].forEach(function (paramVal) { typeof paramVal !== \"number\" ? param.push('\"' + paramVal + '\"') : param.push(paramVal); }); queryString += `${key}:[${param.join(\",\")}]`; } }); queryString += \")\"; } // Handle query fields if (query.fields) { queryString += \"{\"; query.fields.forEach(function (field) { if (typeof field === \"string\") { queryString += ` ${field}`; } if (typeof field === \"object\") { if (\"$ref\" in field) { let myRef = Fragments[field[\"$ref\"]]; for (let subField of myRef) { if (typeof subField === \"string\") { queryString += ` ${subField}`; } else { queryString += ` ${client.buildQuery(subField)}`; } } } else { queryString += ` ${field.name}{`; field.fields.forEach(function (subField) { if (typeof subField === \"string\") { queryString += `${subField} `; } else { queryString += `${client.buildQuery(subField)}`; } }); queryString += \"}\"; } } }); queryString += \"}\"; } return queryString; } /** * Add the authorization token to the headers * @param {String} jwt - the user json web token */ setHeader(jwt) { this.headers[\"Authorization\"] = `Bearer ${jwt}`; } initalizeHeader() { this.headers = { Accept: \"application/json\", \"Content-Type\": \"application/json\", }; this.headers[\"X-Client-Id\"] = process.env.VUE_APP_CLIENT_ID; /* istanbul ignore if */ if (this.headers[\"X-Client-Id\"] === undefined) { delete this.headers[\"X-Client-Id\"]; } } } export default GraphQLClient; × Search results Close "},"lib_Client_RESTClient.js.html":{"id":"lib_Client_RESTClient.js.html","title":"Source: lib/Client/RESTClient.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: lib/Client/RESTClient.js import axios from \"axios\"; //import {toBase64} from \"@/utils/generalUtils\" class RESTClient { /** * The RESTClient is a singleton class that handles the connection and data exchange from the back-end * REST API. */ constructor() { if (RESTClient._instance) { return RESTClient._instance; } RESTClient._instance = this; this.baseURL = process.env.VUE_APP_API_ENDPOINT; this.headers = { Accept: \"application/json\", \"Content-Type\": \"application/json\", \"Cache-Control\": \"no-cache\", }; this.headers[\"X-Client-Id\"] = process.env.VUE_APP_CLIENT_ID; } /* USERS: all methods below related to handling user authentication */ /** * Method to add authorisation to the headers. * @param jwt - the user's json web token * @return {JSON} - headers with authorisation field added */ auth_headers(jwt) { let headers = JSON.parse(JSON.stringify(this.headers)); headers[\"Authorization\"] = \"Bearer \" + jwt; return headers; } /** * Method to log in the user * @param username - name of the user * @param password - password of the user * @return {Promise} - the response of the server */ async login(username, password) { const endpoint = \"/users/sign_in\"; const body = { user: { login: username, password: password, }, }; const request = { method: \"post\", baseURL: this.baseURL + endpoint, data: body, headers: this.headers, }; let response = await this.executeQuery(request); return response.data; } /** * Logout the user from the back, expiring the current jwt. * @param {String} jwt - the user token to expire. * @returns {Promise} */ async logout(jwt) { const request = { method: \"delete\", baseURL: this.baseURL + \"/users/sign_out\", headers: this.auth_headers(jwt), }; let response = await this.executeQuery(request); return response.data; } /** * Method to create a new user * @param {Object} userLogin - the user account to create * @returns {Promise} response - server response */ async createAccount(userLogin) { const request = { method: \"post\", baseURL: this.baseURL + \"/users\", data: { user: userLogin }, headers: this.headers, }; let response = await this.executeQuery(request); return response.data; } /** * Validate the account given the corresponding token * @param {String} token - the account token to validate * @returns {Promise} */ async confirmAccount(token) { const request = { method: \"get\", baseURL: this.baseURL + \"/users/confirmation?confirmation_token=\" + token, headers: this.headers, }; let response = await this.executeQuery(request); return response.data; } /** * Method to send a reset password link to the given email address * @param {String} email to send the link to * @returns {Promise} */ async requestResetPwd(email) { const request = { method: \"post\", baseURL: this.baseURL + \"/users/password\", headers: this.headers, data: { user: { email: email }, }, }; let response = await this.executeQuery(request); return response.data; } /** * Resend the validation link for a given user * @param {Object} user - contains the email of the user. * @returns {Promise} */ async resendConfirmation(user) { const request = { method: \"post\", baseURL: this.baseURL + \"/users/confirmation\", headers: this.headers, data: { user: user }, }; let response = await this.executeQuery(request); return response.data; } /** * Reset the password of the given user * @param {Object} user - contains the new pwd, repeated pwd and token. * @returns {Promise} */ async resetPassword(user) { const request = { method: \"put\", baseURL: this.baseURL + \"/users/password\", headers: this.headers, data: { user: user }, }; let response = await this.executeQuery(request); return response.data; } /** * Changes the password of the logged in user * @param {String} jwt - the user token * @param {Object} user - contains the current, new and repeated new password * @returns {Promise} */ async resetPasswordWithoutToken(jwt, user) { const request = { method: \"put\", baseURL: this.baseURL + \"/users/\", headers: this.auth_headers(jwt), data: { user: user }, }; let response = await this.executeQuery(request); return response.data; } /** * Verify the validity of the given password * @param {String} password - the password to test * @returns {Promise} */ async verifyPassword(password) { let headers = JSON.parse(JSON.stringify(this.headers)); const request = { method: \"post\", baseURL: this.baseURL + \"/users/check_password\", headers: headers, data: { password: password }, }; let response = await this.executeQuery(request); return response.data; } /** * Get the current user data * @param jwt * @returns {Promise} */ async getUser(jwt) { const request = { method: \"get\", baseURL: this.baseURL + \"/users/edit\", headers: this.auth_headers(jwt), }; let response = await this.executeQuery(request); return response.data; } /** * Get the current user data * @param jwt * @param id * @returns {Promise} */ async getPublicUser(jwt, id) { const request = { method: \"get\", baseURL: this.baseURL + `/user_admin/${id}`, headers: this.auth_headers(jwt), }; let response = await this.executeQuery(request); return response.data; } /** * Get all users list * @param jwt * @returns {Promise} */ async getUsersList(jwt) { const request = { method: \"get\", baseURL: this.baseURL + \"/user_admin/\", headers: this.auth_headers(jwt), }; let response = await this.executeQuery(request); return response.data; } /** * Edit the current logged in user profile * @param {Object} newUser - the new values for the logged in user * @param {String} jwt - JWT of the logged in user * @returns {Promise} */ async editUser(newUser, jwt) { const request = { method: \"put\", baseURL: this.baseURL + \"/users\", headers: this.auth_headers(jwt), data: { user: newUser }, }; let response = await this.executeQuery(request); return response.data; } /** * Edit the current logged in user profile * @param {Object} newUser - the new values for the logged in user * @param {String} jwt - JWT of the logged in user * @returns {Promise} */ async editPublicUser(newUser, jwt) { const request = { method: \"put\", baseURL: this.baseURL + `/user_admin/${newUser.id}`, headers: this.auth_headers(jwt), data: { user: newUser }, }; let response = await this.executeQuery(request); return response.data; } /** * Delete the user * @param userID * @param {String} jwt - JWT of the logged in user * @returns {Promise} */ async deletePublicUser(userID, jwt) { const request = { method: \"delete\", baseURL: this.baseURL + `/user_admin/${userID}`, headers: this.auth_headers(jwt), }; let response = await this.executeQuery(request); return response.data; } /** * Verify that the given JWT is still valid * @param {String} jwt - the token to validate * @returns {Promise} */ async validateToken(jwt) { const request = { method: \"get\", baseURL: this.baseURL + \"/users/valid\", headers: this.auth_headers(jwt), }; let response = await this.executeQuery(request); return response.data; } /* EDITORS METHODS */ /** * Post the given object to the API to create the corresponding record. * @param record * @param {String} jwt - JWT of the logged in user * @returns {Promise} */ async createRecord(record, jwt) { const request = { method: \"post\", baseURL: this.baseURL + \"/fairsharing_records\", headers: this.auth_headers(jwt), data: { fairsharing_record: record }, }; let response = await this.executeQuery(request); return response.data; } /** * Update the given record * @param {Object} record - the record to update containing the ID to target, the new values * and the user token * @returns {Promise} */ async updateRecord(record) { const request = { method: \"put\", baseURL: this.baseURL + \"/fairsharing_records/\" + record.id, headers: this.auth_headers(record.token), data: { fairsharing_record: record.record }, }; let response = await this.executeQuery(request); return response.data; } /** * Determine if a user has permission to edit this record. * @param {Integer} recordID - ID for the relevant FairsharingRecord. * @param {String} userToken - JWT of the logged in user * @returns {Promise} */ async canEdit(recordID, userToken) { const request = { method: \"get\", baseURL: this.baseURL + \"/fairsharing_records/can_edit/\" + recordID, headers: this.auth_headers(userToken), }; let response = await this.executeQuery(request); return response.data; } /** * Attempt to create a MaintenanceRequest for a user for a FairsharingRecord. * @param {Integer} recordID - ID for the relevant FairsharingRecord. * @param {String} userToken - JWT of the logged in user * @returns {Promise} */ async claimRecord(recordID, userToken) { const request = { method: \"post\", baseURL: this.baseURL + \"/maintenance_requests\", headers: this.auth_headers(userToken), data: { maintenance_request: { fairsharing_record_id: recordID } }, }; let response = await this.executeQuery(request); return response.data; } /** * Determine if a user has permission to create a MaintenanceRequest for a FairsharingRecord. * @param {Integer} recordID - ID for the relevant FairsharingRecord. * @param {String} userToken - JWT of the logged in user * @returns {Promise} */ async canClaim(recordID, userToken) { const request = { method: \"get\", baseURL: this.baseURL + \"/maintenance_requests/existing/\" + recordID, headers: this.auth_headers(userToken), }; let response = await this.executeQuery(request); return response.data; } /** * Remove an existing maintainer from a FairsharingRecord. * @param {Integer} recordID - ID for the relevant FairsharingRecord. * @param {String} userToken - JWT of the logged in user * @returns {Promise} */ // TODO: Coverage steadfastly refuses to see this even though it is mocked and called // in a test (see Record.spec.js). /* istanbul ignore next */ async removeMaintainer(recordID, userToken) { const request = { method: \"post\", baseURL: this.baseURL + \"/maintenance_requests/remove\", headers: this.auth_headers(userToken), data: { maintenance_request: { fairsharing_record_id: recordID } }, }; let response = await this.executeQuery(request); return response.data; } /** * Add or remove an watcher to/from a FairsharingRecord. * @param {Integer} recordID - ID for the relevant FairsharingRecord. * @param {String} operation - 'add' or 'remove'. * @param {String} userToken - JWT of the logged in user * @returns {Promise} */ // TODO: Mocking this in a test (5c40b02ba3d78a49a088ab6dd5145c9ea10ea24b) // caused it to no longer be covered! /* istanbul ignore next */ async changeWatcher(recordID, operation, userToken) { const request = { method: \"post\", baseURL: this.baseURL + \"/fairsharing_records/watch\", headers: this.auth_headers(userToken), data: { record_id: recordID, operation: operation, }, }; let response = await this.executeQuery(request); return response.data; } /** * Attempt to create a RecordReview for a user for a FairsharingRecord. * @param {Integer} recordID - ID for the relevant FairsharingRecord. * @param {String} userToken - JWT of the logged in user * @returns {Promise} */ async reviewRecord(recordID, userToken) { const request = { method: \"post\", baseURL: this.baseURL + \"/record_reviews\", headers: this.auth_headers(userToken), data: { record_review: { fairsharing_record_id: recordID } }, }; let response = await this.executeQuery(request); return response.data; } /* USER DEFINED TAGS */ /** * Create a new user defined tag in the database for users to tag their records. * @param {String} term - the string value of the term * @param {String} token - the user JWT * @returns {Promise} */ async createNewUserDefinedTag(term, token) { const request = { method: \"post\", baseURL: this.baseURL + \"/user_defined_tags\", headers: this.auth_headers(token), data: { user_defined_tag: { label: term } }, }; let response = await this.executeQuery(request); return response.data; } /* LICENCES */ /** * Create new a licence link * @param {Object} licenceLink - the licence link to create * @param {String} token - the user token * @returns {Promise} */ async createLicenceLink(licenceLink, token) { let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/licence_links\", headers: this.auth_headers(token), data: { licence_link: licenceLink }, }; let response = await _client.executeQuery(request); return response.data; } /** * Delete the given licence * @param {Number} id - id of the licence link to delete * @param {String} token - the user token * @returns {Promise} */ async deleteLicenceLink(id, token) { let _client = this; const request = { method: \"delete\", baseURL: _client.baseURL + \"/licence_links/\" + id, headers: this.auth_headers(token), }; let response = await _client.executeQuery(request); return response.data; } /** * Update the licenceLink * @param {Object} licenceLink - the new values for the licence link * @param {String} token the user token * @returns {Promise} */ async updateLicenceLink(licenceLink, token) { let _client = this; const request = { method: \"put\", baseURL: _client.baseURL + \"/licence_links/\" + licenceLink.id, headers: this.auth_headers(token), data: { licence_link: licenceLink }, }; let response = await _client.executeQuery(request); return response.data; } /* PUBLICATIONS */ async createPublication(publication, token) { let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/publications\", headers: this.auth_headers(token), data: { publication: publication }, }; let response = await _client.executeQuery(request); return response.data; } async editPublication(publication, token) { let _client = this; const request = { method: \"put\", baseURL: _client.baseURL + \"/publications/\" + publication.id, headers: this.auth_headers(token), data: { publication: publication }, }; let response = await _client.executeQuery(request); return response.data; } /* RELATIONSHIPS BETWEEN RECORDS */ /** * Saves the relationships as an array of items containing a targetID, a sourceID and a labelID * @param {Object} options - the options to pass as {token: String, relations: Array} * @returns {Promise} */ async saveRelations(options) { if (options.relations.length &gt; 0) { const request = { method: \"put\", baseURL: this.baseURL + \"/fairsharing_records/\" + options.target, headers: this.auth_headers(options.token), data: { fairsharing_record: { record_associations_attributes: options.relations, }, }, }; let response = await this.executeQuery(request); return response.data; } return {}; } /** * Deletes the relationships as an array of items containing a targetID, a sourceID and a labelID * @param {Object} options - the options to pass as {token: String, relations: Array} * @returns {Promise} */ async deleteRelations(options) { if (options.relations.length &gt; 0) { const request = { method: \"put\", baseURL: this.baseURL + \"/fairsharing_records/\" + options.target, headers: this.auth_headers(options.token), data: { fairsharing_record: { record_associations_attributes: options.relations, }, }, }; let response = await this.executeQuery(request); return response.data; } return {}; } /* ORGANISATIONS AND GRANTS */ /** * Create a given organisation * @param {Object} organisation * @param {String} userToken - the user jwt * @returns {Promise} */ async createOrganisation(organisation, userToken) { let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/organisations\", headers: this.auth_headers(userToken), data: { organisation: organisation }, }; let response = await _client.executeQuery(request); return response.data; } /** * Edit a given organisation * @param {Object} organisation * @param {Number} id * @param {String} userToken - the user jwt * @returns {Promise} */ async editOrganisation(organisation, id, userToken) { let _client = this; const request = { method: \"put\", baseURL: _client.baseURL + \"/organisations/\" + id, headers: this.auth_headers(userToken), data: { organisation: organisation }, }; let response = await _client.executeQuery(request); return response.data; } /** * Delete the given organisation link * @param {Number} organisationId - the id of the link to remove * @param {String} userToken - the user jwt * @returns {Promise} */ async deleteOrganisation(organisationId, userToken) { let _client = this; const request = { method: \"delete\", baseURL: _client.baseURL + \"/organisations/\" + organisationId, headers: this.auth_headers(userToken), }; let response = await _client.executeQuery(request); return response.data; } /** * Create a given grant * @param {Object} grant * @param {String} userToken - the user jwt * @returns {Promise} */ async createGrant(grant, userToken) { let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/grants\", headers: this.auth_headers(userToken), data: { grant: grant }, }; let response = await _client.executeQuery(request); return response.data; } /** * Create a new link between an organisation, a record and an optional grant. * @param {Object} organisationLink - the organisation link to create * @param {String} userToken - the user jwt * @returns {Promise} */ async createOrganisationLink(organisationLink, userToken) { let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/organisation_links\", headers: this.auth_headers(userToken), data: { organisation_link: organisationLink }, }; let response = await _client.executeQuery(request); return response.data; } /** * Update the organisationLink given from linkID input with the given organisationLink * @param {Object} organisationLink - the new organisation link value * @param {Number} linkID - ID of the organisationLink to update * @param {String} userToken - the user jwt * @returns {Promise} */ async updateOrganisationLink(organisationLink, linkID, userToken) { let _client = this; const request = { method: \"put\", baseURL: _client.baseURL + \"/organisation_links/\" + linkID, headers: this.auth_headers(userToken), data: { organisation_link: organisationLink }, }; let response = await _client.executeQuery(request); return response.data; } /** * Delete the given organisation link * @param {Number} linkID - the id of the link to remove * @param {String} userToken - the user jwt * @returns {Promise} */ async deleteOrganisationLink(linkID, userToken) { let _client = this; const request = { method: \"delete\", baseURL: _client.baseURL + \"/organisation_links/\" + linkID, headers: this.auth_headers(userToken), }; let response = await _client.executeQuery(request); return response.data; } /** * Get the extra metadata fields for a RecordType * @param {String} type - name of the record type. * @param {String} userToken - the user jwt * @returns {Promise} */ async extraMetadataFields(type, userToken) { const request = { method: \"post\", baseURL: this.baseURL + \"/fairsharing_records/metadata_fields\", headers: this.auth_headers(userToken), data: { type: type }, }; let response = await this.executeQuery(request); return response.data; } /* METHODS FOR CURATION */ /** * Update the maintenanceRequest given the new status value * @param {Number} maintenanceRequest ID of the maintenanceRequest to update * @param {string} newStatus - new status to update * @param {String} userToken - the user jwt * @returns {Promise} */ async updateStatusMaintenanceRequest( maintenanceRequest, newStatus, userToken ) { let _client = this; const request = { method: \"put\", baseURL: _client.baseURL + \"/maintenance_requests/\" + maintenanceRequest, headers: this.auth_headers(userToken), data: { maintenance_request: { status: newStatus } }, }; let response = await _client.executeQuery(request); return response.data; } /** * Delete Record * @param {Number} id - id of the record link to delete * @param {String} token - the user token * @returns {Promise} */ async deleteRecord(id, token) { let _client = this; const request = { method: \"delete\", baseURL: _client.baseURL + \"/fairsharing_records/\" + id, headers: this.auth_headers(token), }; let response = await _client.executeQuery(request); return response.data; } /** * Get the list of allowed relation types for editing record's relationships. * @returns {Promise} */ /* EDITOR DATA */ async getRelationsTypes() { let _client = this; const request = { method: \"get\", baseURL: _client.baseURL + \"/record_associations/allowed\", }; let response = await _client.executeQuery(request); return response.data; } /** * Get the list of available profile types for a user. * @returns {Promise} */ async getProfileTypes() { const request = { method: \"get\", baseURL: this.baseURL + \"/users/profile_types\", headers: this.headers, }; let response = await this.executeQuery(request); return response.data; } /** * Get the list of available roles for a user. * @returns {Promise} * @param {String} token - the user token */ // Coverage steadfastly refuses to see this even though it is mocked and called // in a test (see EditPublicProfile.spec.js). /* istanbul ignore next */ async getUserRoles(userToken) { const request = { method: \"get\", baseURL: this.baseURL + \"/user_roles\", headers: this.auth_headers(userToken), }; let response = await this.executeQuery(request); return response.data; } /* SYSTEM MESSAGES */ /** * Update the given message * @param {Object} message - the message to update containing the ID to target and the new values * @param {String} userToken - the user jwt * @returns {Promise} */ async updateMessage(message, userToken) { const request = { method: \"put\", baseURL: this.baseURL + \"/messages/\" + message.id, headers: this.auth_headers(userToken), data: { message: message }, }; let response = await this.executeQuery(request); return response.data; } /** * Update the given message * @param {Object} message - the message to create * @param {String} userToken - the user jwt * @returns {Promise} */ async createMessage(message, userToken) { const request = { method: \"post\", baseURL: this.baseURL + \"/messages/\", headers: this.auth_headers(userToken), data: { message: message }, }; let response = await this.executeQuery(request); return response.data; } /** * Update the given message * @param {String} messageId - the ID of the message to delete * @param {String} userToken - the user jwt * @returns {Promise} */ async deleteMessage(messageId, userToken) { const request = { method: \"delete\", baseURL: this.baseURL + \"/messages/\" + messageId, headers: this.auth_headers(userToken), }; let response = await this.executeQuery(request); return response.data; } /* EXTRA METHODS */ /** * Trigger the given query with Axios * @param query * @returns {Promise&lt;*&gt;} */ async executeQuery(query) { try { return await axios(query); } catch (e) { return { data: { error: e } }; } } /** * Get records without DOIS * @param {String} token - the user token that needs to be a curator * @returns {Promise} */ async getRecordsWoDOIs(userToken) { let _client = this; const request = { method: \"get\", baseURL: _client.baseURL + \"/files/no_dois\", headers: this.auth_headers(userToken), }; let response = await _client.executeQuery(request); return response.data; } /** * Get count of records created by month * @param {String} token - the user token that needs to be a curator * @returns {Promise} */ async getRecordCreatedByMonth(userToken) { let _client = this; const request = { method: \"get\", baseURL: _client.baseURL + \"/files/creation_dates\", headers: this.auth_headers(userToken), }; let response = await _client.executeQuery(request); return response.data; } /** * Get count of edits by month * @param {String} token - the user token that needs to be a curator * @returns {Promise} */ async getEditByMonth(userToken) { let _client = this; const request = { method: \"get\", baseURL: _client.baseURL + \"/files/edit_dates\", headers: this.auth_headers(userToken), }; let response = await _client.executeQuery(request); return response.data; } /** * Get Zenodo call * @param {String} call * @param {String} userToken - the user jwt * @returns {Promise} */ async getZenodoSearch(text, userToken) { let _client = this; const request = { method: \"post\", baseURL: _client.baseURL + \"/zenodo\", headers: this.auth_headers(userToken), data: { doi: text }, }; let response = await _client.executeQuery(request); return response.data; } // This is covered in BaseFields.spec.js but doesn't show in coverage. /* istanbul ignore next */ async clearLogo(id, token) { let _client = this; const request = { method: \"put\", baseURL: _client.baseURL + \"/fairsharing_records/\" + id, headers: _client.auth_headers(token), data: { fairsharing_record: { logo: {}, }, }, }; let response = await _client.executeQuery(request); // here the data returned always should be either an array of images or one string of image return response.data; } /** * Get statistics data without users * @returns {Promise} */ async getStatisticsData() { let _client = this; const request = { method: \"get\", baseURL: _client.baseURL + \"/homepage_stats\", }; let response = await _client.executeQuery(request); return response.data; } /** * Get JSON+LD for homepage. * @returns {Promise} */ async getHomepageJsonld() { let _client = this; const request = { method: \"get\", baseURL: _client.baseURL + \"/homepage_jsonld\", }; let response = await _client.executeQuery(request); return response.data; } /** * Send the verification link for a given user * @param {Object} user - contains the email, uid, identifier of the user. * @returns {Promise} */ async sendOrcidVerification(user) { let _client = this; const request = { method: \"post\", baseURL: this.baseURL + \"/users/auth/identify_user\", headers: this.auth_headers(user), data: { user: user }, }; let response = await _client.executeQuery(request); return response.data; } } export default RESTClient; × Search results Close "},"views_Static_Community_Community.vue.html":{"id":"views_Static_Community_Community.vue.html","title":"Source: views/Static/Community/Community.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: views/Static/Community/Community.vue &lt;template&gt; &lt;main :class=\"applyCss?'pa-15 mb-10':''\"&gt; &lt;!-- main_title_2 --&gt; &lt;!-- eslint-disable vue/no-v-html --&gt; &lt;h1 class=\"mb-5\"&gt; FAIRsharing is a community-driven resource with users and collaborators across all disciplines. We work together with our stakeholders to enable the &lt;a href=\"https://www.nature.com/articles/sdata201618\" target=\"_blank\" class=\"underline-effect\" &gt;FAIR Principles&lt;/a&gt; by promoting the value and the use of standards, databases and policies. &lt;/h1&gt; &lt;p class=\"text-h5\"&gt; How to cite us: use the DOI for the &lt;a href=\"https://doi.org/10.25504/FAIRsharing.2abjs5\" target=\"_blank\" class=\"underline-effect\" &gt;FAIRsharing record&lt;/a&gt;, or our &lt;a href=\"https://doi.org/10.1038/s41587-019-0080-8\" target=\"_blank\" class=\"underline-effect\" &gt;publication.&lt;/a&gt; &lt;/p&gt; &lt;!-- Adopters, activities, Governance tabs--&gt; &lt;v-container class=\"my-10\"&gt; &lt;v-row class=\"block-category\" &gt; &lt;v-col v-for=\"(tab,index) in contentTabs\" :key=\"tab.name+'_'+index\" cols=\"12\" sm=\"12\" md=\"4\" lg=\"4\" &gt; &lt;v-card class=\"mx-auto block-category__card cursor-pointer\" max-width=\"350\" height=\"300\" @click=\"jumpToAnchor(tab.name.toLowerCase())\" &gt; &lt;div class=\"white--text d-flex flex-column justify-center block-category__card__gradient\"&gt; &lt;div style=\"height: 136px\" class=\"d-flex justify-center\" &gt; &lt;v-icon size=\"80\" color=\"white\" style=\"opacity: .7\" &gt; {{ $vuetify.icons.values[tab.icon].icon }} &lt;/v-icon&gt; &lt;/div&gt; &lt;v-card-title class=\"d-inline text-h4 text-center text-md-h5 text-lg-h4\"&gt; {{ tab.name }} &lt;/v-card-title&gt; &lt;/div&gt; &lt;v-card-text class=\"text--primary text-justify\" &gt; &lt;p class=\"text-center\"&gt; {{ tab.description }} &lt;/p&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/v-container&gt; &lt;!-- Adopters --&gt; &lt;section id=\"adopters\"&gt; &lt;h3 class=\"text-h3 mb-4 mt-5\"&gt; Adopters &lt;/h3&gt; &lt;p&gt; A broad range of &lt;a href=\"/stakeholders\"&gt;stakeholders&lt;/a&gt; come to FAIRsharing from across all research domains. However, adopters use FAIRsharing specifically to do one or more of the following: &lt;/p&gt; &lt;ol type=\"i\"&gt; &lt;li&gt; Educate their users/community on the variety of existing standards, repositories and policies that exist in FAIRsharing and actively encourage them to submit/claim records, where relevant; &lt;/li&gt; &lt;li&gt; Recommend resources by registering their data policy, and then link it to standards and/or databases &lt;a href=\"/search?page=1&amp;isRecommended=true\"&gt;recommended&lt;/a&gt; in the policy; &lt;/li&gt; &lt;li&gt; Create a &lt;a href=\"/collections\"&gt;Collection&lt;/a&gt; that pulls together a list of standards and/or databases around a given domain of interest relevant to them. &lt;/li&gt; &lt;/ol&gt; &lt;p&gt; Adopters are generally representatives of institutions, libraries, journal publishers, infrastructure programmes, societies and other organisations or projects that in turn serve and guide individual researchers or other stakeholders on research data management matters. Adopters display a FAIRsharing logo on their websites with a link from their website to our homepage. &lt;/p&gt; &lt;p&gt; In general, our adopters fall into the following broad categories. If you don't see your project on the list of adopters, please &lt;a href=\"mailto:contact@fairsharing.org\"&gt;get in touch&lt;/a&gt;. &lt;/p&gt; &lt;div class=\"text-center\"&gt; &lt;v-btn class=\"ma-2 text-white\" &gt; &lt;router-link v-scroll-to=\"'#funders'\" to=\"#funders\" text-color=\"white\" &gt; Funders &lt;/router-link&gt; &lt;/v-btn&gt; &lt;v-btn class=\"ma-2 text-white\" &gt; &lt;router-link v-scroll-to=\"'#publishers'\" to=\"#publishers\" text-color=\"white\" &gt; Publishers &lt;/router-link&gt; &lt;/v-btn&gt; &lt;v-btn class=\"ma-2 text-white\" &gt; &lt;router-link v-scroll-to=\"'#organisations'\" to=\"#organisations\" text-color=\"white\" &gt; Organisations &lt;/router-link&gt; &lt;/v-btn&gt; &lt;v-btn class=\"ma-2 text-white\" &gt; &lt;router-link v-scroll-to=\"'#tools'\" to=\"#tools\" text-color=\"white\" &gt; Tools &lt;/router-link&gt; &lt;/v-btn&gt; &lt;/div&gt; &lt;h4 class=\"text-h4 mb-4 mt-5 pt-10\"&gt; Funders &lt;/h4&gt; &lt;p id=\"funders\" :class=\"['mb-0 mt-10 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" &gt; A selection of official reports from funders and other organisations that recommend the use of FAIRsharing as a key asset for all stakeholders to enable FAIR data: &lt;/p&gt; &lt;!-- External Links --&gt; &lt;v-row class=\"my-2\" &gt; &lt;v-col v-for=\"(item,index) in externalLinks\" :key=\"index+'_'+item.titleLink\" cols=\"12\" md=\"12\" lg=\"4\" :class=\"['pa-5 links',{'max-width-32-percent':$vuetify.breakpoint.mdAndUp}]\" &gt; &lt;a :href=\"item.titleLink\" target=\"_blank\" &gt; &lt;p :class=\"['mb-0 lato-font-medium lato-text-sm underline-effect',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" &gt; {{ item.title }} &lt;/p&gt; &lt;/a&gt; &lt;i :class=\"['mb-0 word-break lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" v-html=\"$sanitize(item.text)\" /&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;h4 class=\"text-h4 mb-4 mt-5 pt-10\"&gt; Publishers &lt;/h4&gt; &lt;p id=\"publishers\" :class=\"['mb-0 mt-10 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" &gt; A selection of the publishers that use FAIRsharing to define and refine their data policies: &lt;/p&gt; &lt;!--Adopter table--&gt; &lt;v-row class=\"mt-2 ml-0\" &gt; &lt;v-col v-for=\"(item,index) in tables.adopterTable.data\" :key=\"index+'_'+item.adopter\" cols=\"12\" md=\"12\" lg=\"4\" :class=\"['pa-5 links',{'max-width-32-percent':$vuetify.breakpoint.mdAndUp}]\" &gt; &lt;v-img v-if=\"item.image\" max-width=\"250px\" max-height=\"250px\" :src=\"item.image\" height=\"120\" contain style=\"filter: grayscale(1);\" /&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;h4 class=\"text-h4 mt-5 pt-10\"&gt; Other Organisations &lt;/h4&gt; &lt;p id=\"organisations\" :class=\"['mb-0 mt-10 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" &gt; Some other organisations using FAIRsharing. &lt;/p&gt; &lt;v-row class=\"mt-2 ml-0\" &gt; &lt;v-col v-for=\"(item,index) in tables.globalOrganisationTable.data\" :key=\"`${item.adopter}_${index}`\" :class=\"['pa-5 links full-width',{'max-width-24-percent':$vuetify.breakpoint.mdAndUp}]\" cols=\"12\" md=\"12\" lg=\"4\" &gt; &lt;v-img v-if=\"item.image\" max-width=\"250px\" max-height=\"250px\" :src=\"item.image\" height=\"120\" contain style=\"filter: grayscale(1);\" /&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/section&gt; &lt;!-- new tools section --&gt; &lt;h4 class=\"text-h4 mt-5 pt-10\"&gt; Tools &lt;/h4&gt; &lt;p v-if=\"tables.toolsTable.data.length\" id=\"tools\" :class=\"['mb-0 mt-10 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" &gt; Tools that make use of FAIRsharing content. If you would like your tool included in this list, please use &lt;a href=\"https://docs.google.com/forms/d/e/1FAIpQLSdl1lKj9xlgN5Od_LyqWfnqBl-8aOLXhdFQa2nfm5CBmZ1TgQ/viewform?usp=sf_link\" target=\"_blank\" &gt;this form&lt;/a&gt; to let us know how you're using FAIRsharing. &lt;/p&gt; &lt;!-- Tools table begins --&gt; &lt;v-row v-if=\"tables.toolsTable.data.length\" dense &gt; &lt;v-col v-for=\"tool in tables.toolsTable.data\" :key=\"tool.id\" cols=\"12\" sm=\"12\" md=\"4\" lg=\"3\" xl=\"2\" &gt; &lt;v-card class=\"full-width\" &gt; &lt;v-img :src=\"tool.logo ? `/assets/Community/tools/${tool.logo}` : '/assets/Community/tools/toolplaceholder.png'\" class=\"white--text align-end\" gradient=\"to top, rgba(0, 0, 0, 0.9), rgba(255, 255, 255, 0.9)\" cover aspect-ratio=\"1\" &gt; &lt;v-card-title&gt; &lt;h4 style=\"word-break: initial\"&gt; &lt;a :id=\"tool.id\" :href=\"tool.homepage\" &gt; {{ tool.name }} &lt;/a&gt; &lt;/h4&gt; &lt;/v-card-title&gt; &lt;v-card-subtitle v-if=\"tool.description\" &gt; {{ tool.description }} &lt;/v-card-subtitle&gt; &lt;/v-img&gt; &lt;v-card-text class=\"text--primary\" style=\"height: 100%\" :style=\"$vuetify.breakpoint.xl ? 'height: 320px': $vuetify.breakpoint.mdAndUp ? 'height: 350px' : 'height: 100%'\" &gt; &lt;div v-if=\"tool.organisations &amp;&amp; tool.organisations.length\"&gt; Organisation : &lt;span v-for=\"(org, i) in tool.organisations\" :key=\"org.id\" &gt; &lt;v-tooltip v-if=\"org.tooltip\" bottom &gt; &lt;template #activator=\"{ on }\"&gt; &lt;a :href=\"`/organisations/${org.id}`\" class=\"d-inline-block\" v-on=\"on\" &gt;{{ org.name }} &lt;/a&gt; &lt;/template&gt; &lt;span&gt;{{ org.tooltip }}&lt;/span&gt; &lt;/v-tooltip&gt; &lt;a v-else :href=\"`/organisations/${org.id}`\" class=\"d-inline-block\" &gt;{{ org.name }} &lt;/a&gt; &lt;span v-if=\"i+1 &lt; tool.organisations.length\"&gt;, &lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;div v-if=\"tool.status\"&gt; Status: {{ tool.status }} &lt;/div&gt; &lt;div v-if=\"tool.contacts &amp;&amp; tool.contacts.length\"&gt; Contacts:&lt;br&gt; &lt;span v-for=\"(contact) in tool.contacts\" :key=\"contact.id\" &gt; &lt;v-chip class=\"ma-2\" x-small &gt; &lt;a :href=\"contact.url\"&gt;{{ contact.name }}&lt;/a&gt; &lt;/v-chip&gt; &lt;/span&gt; &lt;/div&gt; &lt;div v-if=\"tool.methods &amp;&amp; tool.methods.length\"&gt; Methods of using FAIRsharing:&lt;br&gt; &lt;span v-for=\"(method) in tool.methods\" :key=\"tool.name + method\" &gt; &lt;v-chip class=\"ma-2\" x-small &gt; {{ method }} &lt;/v-chip&gt; &lt;/span&gt; &lt;/div&gt; &lt;div v-if=\"tool.types &amp;&amp; tool.types.length\"&gt; Type of resource:&lt;br&gt; &lt;span v-for=\"(type) in tool.types\" :key=\"tool.name + type\" &gt; &lt;v-chip class=\"ma-2\" x-small &gt; {{ type }} &lt;/v-chip&gt; &lt;/span&gt; &lt;/div&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- Tools table ends --&gt; &lt;!-- Activities --&gt; &lt;section id=\"activities\"&gt; &lt;h3 class=\"text-h4 my-4\"&gt; Activities &lt;/h3&gt; &lt;p :class=\"['mb-2 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" &gt; FAIRsharing is not just a registry. The team behind FAIRsharing is involved in a number of FAIR-enabling activities, delivering guidance, tools and services with and for a variety of stakeholders. As these activities mature, we will implement or connect them in/to the FAIRsharing resource itself. &lt;/p&gt; &lt;p :class=\"['mb-2 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" &gt; Some of these activities are part of funded projects and of national or international consortia, while others are volunteer efforts that fall under a variety of umbrella organisations, such as working groups (WG) and learned societies. &lt;/p&gt; &lt;b :class=\"['mb-2 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" &gt; Our activities are classified using the three GO-FAIR pillar structures (change, build, train) and are outlined here. &lt;/b&gt; &lt;!--Activities table--&gt; &lt;ActivitiesStaticTable class=\"mb-16 mt-2\" /&gt; &lt;/section&gt; &lt;!-- Governance --&gt; &lt;section id=\"governance\"&gt; &lt;h3 class=\"text-h4 mb-4\"&gt; Governance &lt;/h3&gt; &lt;!-- Meet the team --&gt; &lt;a id=\"team\" /&gt; &lt;h4 class=\"text-h5 mb-2\"&gt; {{ meettheteam.title }} &lt;/h4&gt; &lt;p :class=\"['mb-5 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" v-html=\"$sanitize(meettheteam.description)\" /&gt; &lt;ul class=\"d-flex flex-wrap pl-0\"&gt; &lt;li v-for=\"(profileItem,index) in meettheteam.profiles\" :key=\"`${profileItem}_${index}`\" :class=\"['text-center width-250 height-400 mb-10',$vuetify.breakpoint.mdAndDown?'mx-auto':'']\" &gt; &lt;v-avatar size=\"160\"&gt; &lt;v-img :src=\"profileItem.profileImg\" style=\"filter: grayscale(1);\" /&gt; &lt;/v-avatar&gt; &lt;p class=\"text-center primary--text lato-font-bold mt-2 ma-0\" style=\"font-size: 1.5rem;min-height: 80px;display: flex;flex-direction: column;\" v-html=\"$sanitize(profileItem.name)\" /&gt; &lt;i class=\"small d-block height-75\"&gt; {{ profileItem.role }} &lt;/i&gt; &lt;div class=\"text-center mt-2 d-flex justify-center\"&gt; &lt;span v-for=\"(socialItem,socialIndex) in profileItem.social\" :key=\"`${socialItem}_${socialIndex}`\" &gt; &lt;a class=\"pr-2\" :href=\"socialItem.link.includes('@')?`mailto:${socialItem.link}`:socialItem.link\" target=\"_blank\" &gt; &lt;Icon class=\"mr-1\" :item=\"socialItem.icon\" :height=\"25\" size=\"30\" wrapper-class=\"\" /&gt; &lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- Advisory Board --&gt; &lt;a id=\"board\" /&gt; &lt;div v-for=\"(governanceItem,key,index) in governance\" :key=\"Object.keys(governanceItem)[index]+'_'+'index'\" &gt; &lt;div class=\"mb-10\"&gt; &lt;h4 class=\"text-h5 mb-8\"&gt; {{ key }} &lt;/h4&gt; &lt;div v-for=\"(itemText,itemIndex) in governance_text\" :key=\"itemText+'_'+itemIndex\" &gt; &lt;p class=\"ma-1\" v-html=\"$sanitize(itemText.text)\" /&gt; &lt;/div&gt; &lt;div v-for=\"(item,itemIndex) in governanceItem\" :key=\"item.title+'_'+itemIndex\" class=\"mt-5\" &gt; &lt;div class=\"mb-5\"&gt; &lt;ul :class=\"['mt-2',{'column-count':$vuetify.breakpoint.mdAndUp}]\"&gt; &lt;li v-for=\"(itemData,itemDataIndex) in item.data\" :key=\"itemData+'_'+itemDataIndex\" :class=\"['mb-1',{'d-flex':isArray(itemData)===true &amp;&amp; $vuetify.breakpoint.lgAndUp}]\" &gt; &lt;div v-if=\"!isArray(itemData)\" class=\"d-flex mb-2\" &gt; &lt;p class=\"ma-0\" v-html=\"$sanitize(itemData.text)\" /&gt; &lt;a v-if=\"itemData.link\" class=\"ml-2 pr-2\" :href=\"itemData.link.toString().includes('@')?`mailto:${itemData.link}`:itemData.link\" target=\"_blank\" &gt; &lt;Icon class=\"mr-1\" item=\"Orcid\" :height=\"25\" size=\"30\" wrapper-class=\"\" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div v-for=\"(itemDataArray,itemDataArrayIndex) in itemData\" v-else :key=\"itemDataArray.link+'_'+itemDataArrayIndex\" class=\"d-flex mb-2\" &gt; &lt;p class=\"ma-0\" v-html=\"$sanitize(itemDataArray.text)\" /&gt; &lt;a class=\"ml-2 pr-2\" :href=\"itemDataArray.link.toString().includes('@')?`mailto:${itemDataArray.link}`:itemDataArray.link\" target=\"_blank\" &gt; &lt;Icon class=\"mr-1\" item=\"Orcid\" :height=\"25\" size=\"30\" wrapper-class=\"\" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;a id=\"rda\" /&gt; &lt;!-- RDA FAIRsharing WG --&gt; &lt;h4 class=\"text-h5 mb-2\"&gt; {{ rda.title }} &lt;/h4&gt; &lt;p :class=\"['mb-5 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" v-html=\"$sanitize(rda.description)\" /&gt; &lt;div v-for=\"(item,itemIndex) in rda.subsections\" :key=\"item.title+'_'+itemIndex\" class=\"ml-8\" &gt; &lt;div class=\"mb-5\"&gt; &lt;h4 class=\"text-h5\"&gt; {{ item.title }} &lt;/h4&gt; &lt;div v-if=\"isArray(item.data)\" &gt; &lt;ul :class=\"['mt-2',{'column-count':$vuetify.breakpoint.mdAndUp}]\"&gt; &lt;li v-for=\"(itemData,itemDataIndex) in item.data\" :key=\"itemData+'_'+itemDataIndex\" :class=\"['mb-1',{'d-flex': $vuetify.breakpoint.lgAndUp}]\" &gt; &lt;div class=\"d-flex mb-2\" &gt; &lt;p class=\"ma-0\" v-html=\"$sanitize(itemData.text)\" /&gt; &lt;a v-if=\"itemData.link\" class=\"ml-2 pr-2\" :href=\"itemData.link.toString().includes('@')?`mailto:${itemData.link}`:itemData.link\" target=\"_blank\" &gt; &lt;Icon class=\"mr-1\" item=\"Orcid\" :height=\"25\" size=\"30\" wrapper-class=\"\" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div v-else&gt; &lt;p :class=\"['mb-5 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" v-html=\"$sanitize(item.data)\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;p :class=\"['mb-5 lato-font-medium lato-text-sm',{'lato-text-md':$vuetify.breakpoint.xlOnly }]\" &gt; &lt;a href=\"https://zulip.com/\" target=\"_blank\" &gt; &lt;img height=\"27px\" width=\"27px\" src=\"/assets/icons/zulip-icon.png\" &gt; &lt;/a&gt; We'd like to thank &lt;a href=\"https://zulip.com/\" target=\"_blank\" class=\"underline-effect\" &gt;Zulip&lt;/a&gt; for access to their community plan, which helps both our core team and our champions. Zulip is an open-source modern team chat app designed to keep both live and asynchronous conversations organized. &lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- eslint-enable vue/no-v-html --&gt; &lt;/main&gt; &lt;/template&gt; &lt;script&gt; /** * All static pages will be handle through this namespace * @namespace Static */ import {isArray} from \"lodash\"; import Icon from \"@/components/Icon\"; import ActivitiesStaticTable from \"@/components/Static/Community/ActivitiesStaticTable\"; import communityData from \"@/data/communityPageData.json\" /** This component handles the sign-up/register page * @memberOf Static * @name Community * @type module * @instance * */ export default { name: \"Community\", components: {Icon, ActivitiesStaticTable}, title: \"This will be the community page\", data: () =&gt; { return { contentTabs: communityData.contentTabs, externalLinks: communityData.externalLinks, governance: communityData.governance, governance_text: communityData.governance_text, meettheteam: communityData.meettheteam, rda: communityData.rda, tables: communityData.tables, applyCss: false, currentAnchor:'', Icon } }, watch: { $route: { deep:true, handler() { this.applyCss = false this.$nextTick(() =&gt; { this.applyCss = true }) } } }, created() { this.$nextTick(() =&gt; { // update the UI padding and margin after DOM is fully loaded. this.applyCss = true }) }, methods: { jumpToAnchor(selectedAnchor) { if (selectedAnchor !== this.currentAnchor) { this.$router.push({hash: `${selectedAnchor}`}); this.currentAnchor = selectedAnchor; } }, isArray(input){ return isArray(input) } } } &lt;/script&gt; &lt;style scoped lang=\"scss\"&gt; .links { border: 1px #d4d4d4 solid; margin: 2px; } .block-category { &amp;__card { transition: all .2ms ease; -webkit-transition: all .2s ease; -moz-transition: all .2s ease; -o-transition: all .2s ease; box-shadow: 0 1rem 2rem rgba(black, .15) !important; -webkit-box-shadow: 0 1rem 2rem rgba(black, .15) !important; -moz-box-shadow: 0 1rem 2rem rgba(black, .15) !important; -o-box-shadow: 0 1rem 2rem rgba(black, .15) !important; &amp;:hover { transform: scale(1.05); -moz-transform: scale(1.05); -webkit-transform: scale(1.05); -o-transform: scale(1.05); } &amp;__gradient { height: 200px; background: rgb(171, 171, 171); background: linear-gradient(50deg, rgb(204, 204, 204) 0%, rgb(135, 135, 135) 100%); background: -webkit-linear-gradient(50deg, rgb(204, 204, 204) 0%, rgb(135, 135, 135) 100%); background: -o-linear-gradient(50deg, rgb(204, 204, 204) 0%, rgb(135, 135, 135) 100%); background: -ms-linear-gradient(50deg, rgb(204, 204, 204) 0%, rgb(135, 135, 135) 100%); } } } .v-divider { margin: 8px; } .border-bottom { border-bottom: 1px solid #ECF0F1 !important; } .border-left { border-left: 1px solid #ECF0F1 !important; } a:hover { div { transform: scale(1.1); -moz-transform: scale(1.1); -webkit-transform: scale(1.1); -o-transform: scale(1.1); } } td { font-size: 1rem!important; } .column-count { column-count:2; -moz-column-count: 2; -webkit-column-count: 2; } .word-break { white-space: break-spaces; } &lt;/style&gt; × Search results Close "},"views_Static_Timeline_Timeline.vue.html":{"id":"views_Static_Timeline_Timeline.vue.html","title":"Source: views/Static/Timeline/Timeline.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: views/Static/Timeline/Timeline.vue &lt;template&gt; &lt;h2&gt;This will be the time-line page&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; /** This component handles the sign-up/register page * @memberOf Static * @name Timeline * @type module * @instance * */ export default { name: \"Timeline\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; × Search results Close "},"store_recordSearch.js.html":{"id":"store_recordSearch.js.html","title":"Source: store/recordSearch.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: store/recordSearch.js import filterMapping from \"@/data/FiltersLabelMapping.json\"; import Client from \"@/lib/GraphClient/GraphClient.js\"; import recordsQuery from \"@/lib/GraphClient/queries/getRecords.json\"; let client = new Client(); export const mutations = { setCollectionIdsParam(state, collectionIDs) { state.collectionIDs = collectionIDs; state.params[\"ids\"] = collectionIDs; }, setRecords(state, data) { state.records = data[\"records\"]; state.facets = buildFacets(data[\"aggregations\"]); state.totalPages = data[\"totalPages\"]; state.perPage = data[\"perPage\"]; state.currentPage = data[\"currentPage\"]; state.hits = data[\"totalCount\"]; }, resetRecords(state) { recordsQuery.queryParam = null; state.records = []; }, resetPages(state) { state.hits = null; state.perPage = null; state.currentPage = 1; state.totalPages = null; }, setLoadingStatus(state, status) { state.loading = status; }, cleanRecordsStore(state) { state.params = { ids: [] }; state.collectionIDs = []; state.records = []; state.facets = []; state.hits = null; state.loading = false; state.totalPages = null; state.perPage = null; state.currentPage = 1; }, }; export const actions = { async initializeCollectionRecords(state, collectionIDs) { this.commit(\"records/setCollectionIdsParam\", collectionIDs); this.commit(\"records/setLoadingStatus\", true); this.commit(\"records/resetRecords\"); this.commit(\"records/resetPages\"); recordsQuery.queryParam = state.state.params; let data; try { data = await client.executeQuery(recordsQuery); this.commit(\"records/setRecords\", data[\"searchFairsharingRecords\"]); this.commit(\"records/setLoadingStatus\", false); } catch { // Loading complete, but no data returned... this.commit(\"records/setRecords\", { records: [] }); } }, async fetchCollectionRecords(state, options) { let params = options.params; let token = options.token; this.commit(\"records/setLoadingStatus\", true); this.commit(\"records/resetRecords\"); this.commit(\"records/resetPages\"); //initialize params state state.state.params = { ids: [...state.state.params.ids] }; Object.keys(params).forEach((key) =&gt; { state.state.params[key] = params[key]; }); recordsQuery.queryParam = state.state.params; let data; try { if (token) { client.setHeader(token); } data = await client.executeQuery(recordsQuery); this.commit(\"records/setRecords\", data[\"searchFairsharingRecords\"]); this.commit(\"records/setLoadingStatus\", false); } catch { // Loading complete, but no data returned... this.commit(\"records/setRecords\", { records: [] }); } }, async fetchRecords(state, options) { let params = options.params; let token = options.token; this.commit(\"records/setLoadingStatus\", true); this.commit(\"records/resetRecords\"); this.commit(\"records/resetPages\"); // params['q'] needs to be sanitised here. if (Object.keys(params).length &gt; 0) { if (\"q\" in params) { // TODO: Is it worth preserving foreign characters as discussed here? // https://stackoverflow.com/questions/22192458/how-to-remove-non-alphanumeric-characters-and-space-but-keep-foreign-language-i const cleaned = params[\"q\"].replace(/[^0-9a-z\\s]/gi, \"\"); const newParams = { ...params, q: cleaned }; recordsQuery.queryParam = newParams; } else { recordsQuery.queryParam = params; } } let data; try { if (token) { client.setHeader(token); } data = await client.executeQuery(recordsQuery); // See: https://github.com/FAIRsharing/FAIRsharing-API/issues/532 if (data[\"error\"] === \"invalid query\") { this.commit(\"records/setRecords\", { aggregations: { is_invalid: { meta: {}, doc_count: 1, doc_count_error_upper_bound: 1, sum_other_doc_count: 1, buckets: [{ key: 1, key_as_string: \"true\", doc_count: 1 }], }, }, records: [], }); } else { this.commit(\"records/setRecords\", data[\"searchFairsharingRecords\"]); } this.commit(\"records/setLoadingStatus\", false); } catch { // Loading complete, but no data returned... /* istanbul ignore next */ this.commit(\"records/setRecords\", { records: [] }); } }, resetRecords() { this.commit(\"records/resetRecords\"); }, }; export const getters = { getFilter: (state) =&gt; (facetName) =&gt; { if (state.facets.length &gt; 0) { let currentFacet = JSON.parse( JSON.stringify( state.facets.find((facet) =&gt; facet.filterName === facetName) ) ); currentFacet[\"values\"] = currentFacet[\"buckets\"]; return currentFacet; } return []; }, getRecordsLength: (state) =&gt; { return state.records.length; }, getCollectionIdsParams: (state) =&gt; { return state.collectionIDs; }, }; /** * The records store handles the requests related to records (searchFairsharingRecords and fairsharingRecord). * @type {Object} */ let recordsStore = { namespaced: true, state: { params: { ids: [] }, collectionIDs: [], records: [], facets: [], hits: null, loading: false, totalPages: null, perPage: null, currentPage: 1, }, mutations: mutations, actions: actions, getters: getters, }; export default recordsStore; /** * Given an object containing the raw facets coming from the client and a mapping object , build the ready to use facets * for usage by the Vue components. * @param {Object} rawFacets - the aggregation object coming from the API response as data['aggregations'] * @returns {Array} output - the array of ready to use facets containing a name, a label and values */ export const buildFacets = function (rawFacets) { let output = []; const mapper = filterMapping[\"autocomplete\"]; Object.keys(rawFacets).forEach(function (facetName) { if (Object.prototype.hasOwnProperty.call(mapper, facetName)) { let localFacet = mapper[facetName]; rawFacets[facetName][\"buckets\"].forEach(function (bucket) { if (Object.prototype.hasOwnProperty.call(bucket, \"key_as_string\")) { bucket[\"key\"] = bucket[\"key_as_string\"]; } }); localFacet[\"buckets\"] = rawFacets[facetName][\"buckets\"]; output.push(localFacet); } }); return output; }; × Search results Close "},"store_searchFilters.js.html":{"id":"store_searchFilters.js.html","title":"Source: store/searchFilters.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: store/searchFilters.js import {isEqual} from 'lodash' import buttonOptions from '@/data/ButtonOptions.json' import filterMapping from \"@/data/FiltersLabelMapping.json\" import homePageData from \"@/data/homePageData.json\" import GraphQLClient from \"@/lib/GraphClient/GraphClient.js\" import query from \"@/lib/GraphClient/queries/getFilters.json\"; const graphClient = new GraphQLClient(); export const mutations = { setFilters(state, data) { state.filtersStatistic = data['searchFairsharingRecords']['aggregations']; state.rawFilters = buildFilters(state.filtersStatistic); state.filters = state.rawFilters.filter(item =&gt; (item.type !== 'Boolean' &amp;&amp; item.filterName !== 'status')); }, setFilterButtons(state) { state.filterButtons.push({ \"data\": [ { \"title\": \"Match all terms\", \"active\": true, \"filterName\": \"searchAnd\", \"value\": true }, { \"title\": \"Match any term\", \"active\": false, \"filterName\": \"searchAnd\", \"value\": false } ], \"curator_only\": false }); state.rawFilters.forEach(item =&gt; { // TODO: Return here if the button is marked as curator-only and the user isn't logged in as a curator. if (item.type === 'Boolean') { let ObjectModel = buttonOptions[item.filterName]; state.filterButtons.push(ObjectModel); } else if (item.filterName === 'status') { let ObjectModel = buttonOptions.status.data; ObjectModel.forEach(function (button) { if (Object.prototype.hasOwnProperty.call(button, 'apiIndex')) { button.value = item.values[button[\"apiIndex\"]]; } }); state.filterButtons.push({data: ObjectModel, curator_only: false}); } }); }, setLoadingStatus(state, status) { state.isLoadingFilters = status; }, resetFilterButtons(state, itemParentIndex) { state.filterButtons[itemParentIndex].data.map((item) =&gt; { item.active = false; }); }, activateButton(state, item) { state.filterButtons[item.itemParentIndex].data.map((filterItem) =&gt; { if (isEqual(filterItem, item.activeItem)) { filterItem.active = true; } }); } }; export const actions = { resetFilterButtons(state, itemParentIndex) { this.commit('searchFilters/resetFilterButtons', itemParentIndex) }, activateButton(state, item) { this.commit('searchFilters/activateButton', item) }, async assembleFilters(){ this.commit(\"searchFilters/setLoadingStatus\", true); // Please refer to ticket: // https://github.com/FAIRsharing/fairsharing.github.io/issues/1288 let keys = []; homePageData.blockInfo['database']['items'].forEach((item) =&gt; { keys.push(item.option.key) }); let data = await graphClient.executeQuery(query); this.commit('searchFilters/setFilters', data); this.commit('searchFilters/setFilterButtons'); this.commit(\"searchFilters/setLoadingStatus\", false); } }; export const getters = { getFilters: (state) =&gt; { let output = []; state.filters.forEach(function (filter) { output.push({ filterName: filter.filterName, filterLabel: filter.filterLabel }) }); return output }, getFiltersStatisticCount: (state) =&gt; (option) =&gt; { return state.filtersStatistic[option.filterName].buckets.find(item =&gt; item.key === option.key)['doc_count']; } }; /** * The searchFilters store trigger a single field query to searchFairsharingRecords, gets the aggregation array and * builds the filtering system to be used by advanced search functions. * @type {Object} */ let filtersStore = { namespaced: true, state: { rawFilters: [], filters: [], filtersStatistic: [], filterButtons: [], isLoadingFilters: false, databaseCount: {} }, mutations: mutations, actions: actions, getters: getters }; export default filtersStore; /** * Given a searchFairsharingRecords aggregations array, build the values used by the advanced search widgets * @param {Array} val - an array of raw filters coming from the api as data['searchFairsharingRecords']['aggregations'] * @returns {Array} filters - ready to use filters for the advanced search components */ export const buildFilters = function (val) { let filters = []; let filtersLabels = filterMapping['autocomplete']; Object.keys(val).forEach(function (key) { if (Object.prototype.hasOwnProperty.call(filtersLabels, key)) { let filter = filtersLabels[key]; filter.values = null; let filterValues = []; let buckets = val[key]['buckets']; buckets.forEach(function (bucket) { if (Object.prototype.hasOwnProperty.call( bucket, \"key_as_string\")) { filterValues.push(bucket[\"key_as_string\"]); } else { filterValues.push(bucket['key']); } }); filter.values = filterValues; filters.push(filter); } }); return filters; }; × Search results Close "},"router_hackSearch.js.html":{"id":"router_hackSearch.js.html","title":"Source: router/hackSearch.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: router/hackSearch.js /* * The purpose of this file is to intercept search parameters before they are passed to the API. It's necessary * as links which were generated on the old system may appear in old (or not so old) papers, on other sites etc. * If anyone complains they've clicked on a link to FAIRsharing that \"doesn't work\" then it may be found to be one * of these, and might perhaps require the specific terms be added to the lookup tables here. * Unfortunately it seems difficult to test and results in: * Timeout - Async callback was not invoked within the 5000ms timeout specified by jest.setTimeout.Timeout */ /** * Convert a prop from the old system into that used by the new. Useful when old search links * have been deployed elsewhere in the internet or in print (as long as we know about them). * @returns String - new form of the old prop */ export function hackSearch(query) { let modified = false; const lookupKeys = { content: 'fairsharingRegistry' }; const lookupValues = { biodbcore: 'database' } Object.keys(query).forEach(function(key) { let value = query[key]; // Delete keys with empty values. if (!value) { delete query[key]; modified = true; } // This key is no longer used in the system: if (key === 'search_state') { delete query[key]; modified = true; } // The key is outdated and needs to be replaced with the latest. if (Object.keys(lookupKeys).includes(key)) { let newKey = lookupKeys[key]; if (Object.keys(lookupValues).includes(value)) { query[newKey] = lookupValues[value]; } else { query[newKey] = value; } // Delete old key. delete query[key]; modified = true; } // The key's OK but the value may need replacing. else { if (Object.keys(lookupValues).includes(value)) { query[key] = lookupValues[value]; modified = true; } else { modified = false; } } }); return [query, modified]; } /* Fixed: https://fairsharing.org/search/?q=genomics&amp;content=biodbcore https://fairsharing.org/search/?q=transcriptomics&amp;content=biodbcore https://fairsharing.org/search/?q=genomics&amp;content=standard&amp;name=&amp;taxonomies=&amp;organisations=&amp;shortname=&amp;description=&amp;supportlinks=&amp;licenses=&amp;countries=&amp;maintainers=&amp;expanded_onto_domains=&amp;expanded_onto_disciplines=&amp;user_defined_tags=&amp;record_id=&amp;miriam_id=&amp;search_state=hidden https://fairsharing.org/search/?q=proteomics&amp;content=biodbcore&amp;name=&amp;taxonomies=&amp;organisations=&amp;shortname=&amp;description=&amp;supportlinks=&amp;licenses=&amp;countries=&amp;maintainers=&amp;expanded_onto_domains=&amp;expanded_onto_disciplines=&amp;user_defined_tags=&amp;record_id=&amp;miriam_id=&amp;search_state=hidden https://fairsharing.org/search/?q=proteomics&amp;content=standard&amp;name=&amp;taxonomies=&amp;organisations=&amp;shortname=&amp;description=&amp;supportlinks=&amp;licenses=&amp;countries=&amp;maintainers=&amp;expanded_onto_domains=&amp;expanded_onto_disciplines=&amp;user_defined_tags=&amp;record_id=&amp;miriam_id=&amp;search_state=hidden https://fairsharing.org/search/?q=metabolomics&amp;content=biodbcore&amp;name=&amp;taxonomies=&amp;organisations=&amp;shortname=&amp;description=&amp;supportlinks=&amp;licenses=&amp;countries=&amp;maintainers=&amp;expanded_onto_domains=&amp;expanded_onto_disciplines=&amp;user_defined_tags=&amp;record_id=&amp;miriam_id=&amp;search_state=hidden https://fairsharing.org/search/?q=metabolomics&amp;content=standard&amp;name=&amp;taxonomies=&amp;organisations=&amp;shortname=&amp;description=&amp;supportlinks=&amp;licenses=&amp;countries=&amp;maintainers=&amp;expanded_onto_domains=&amp;expanded_onto_disciplines=&amp;user_defined_tags=&amp;record_id=&amp;miriam_id=&amp;search_state=hidden Covered by something else: https://fairsharing.org/standards/?q=transcriptomics */ × Search results Close "},"utils_rules.js.html":{"id":"utils_rules.js.html","title":"Source: utils/rules.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: utils/rules.js /** * Assess if the string is of a certain value (useful to compare passwords) * @param {String} val - the value to evaluate the string against * @returns {function(*): (boolean|string)} */ export function hasValue(val){ return value =&gt; value === val || \"Invalid repeated password\" } /** * Assess email patterns. * @returns {function(*): (boolean|string)} */ export function isEmail(){ return value =&gt; { const pattern = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/ return pattern.test(value) || 'Invalid e-mail.' } } /** * Assess mastodon username @user@server. * @returns {function(*): (boolean|string)} */ export function isMastodon(){ return value =&gt; { if (!value) return true; const pattern = /^@[A-Za-z]+@[A-Za-z\\\\.]+$/ return pattern.test(value) || 'Invalid mastodon handle: Use @user@server.' } } /** * Assess the presence of the field * @returns {function(*=): (boolean|string)} */ export function isRequired(){ return value =&gt; !(!value || value.length === 0 || JSON.stringify(value) === '{}') || 'Required' } /** * Assess URL patterns. * @returns {function(*): (boolean|string)} */ export function isUrl() { return value =&gt; { if (!value) return true; const pattern = /[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,8}\\b([-a-zA-Z0-9()@:%_+.~#?&amp;//=]*)?/gi; return pattern.test(value) || 'Invalid URL.' } } /** * Assess email or email patterns. * @returns {function(*): (boolean|string)} */ export function isEmailOrUrl(){ return value =&gt; { const pattern = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/ const patternUrl = /[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,8}\\b([-a-zA-Z0-9()@:%_+.~#?&amp;//=]*)?/gi; return pattern.test(value) || patternUrl.test(value) || 'Invalid e-mail/URL.' } } /** * Assess if the string is long enough. * @param {Number} length - the length to evaluate the string against. * @returns {function(*): (boolean|string)} */ export function isLongEnough(length) { return value =&gt; { let error = (value) ? `Value is not long enough (${value.length}/${length})` : `Value is not long enough (0/${length})`; if (!value) return error; return value.length &gt;= length || error; } } /** * Assess ORCID patterns. Can be empty if required is false. * @params {Boolean} required - is the field required or not. * @returns {function(*): (boolean|string)} */ export function isOrcid(required) { return value =&gt; { if (!value &amp;&amp; !required) return true; // because this is an optional Orcid ID const pattern = /^(\\d|X){4}-(\\d|X){4}-(\\d|X){4}-(\\d|X){4}$/gi; return pattern.test(value) || \"Doesn't look like a valid ORCID ID.\" } } /** * Assess if the given file has the correct extension * @returns {function(*): (boolean|string)} */ export function isImage(){ const accept = [\"image/png\", \"image/jpeg\"]; return value =&gt; { return (!value || accept.indexOf(value.type) &gt; -1) || \"File type should be PNG or JPEG\" } } /** * Assess if the given file has the correct allowed size * @returns {function(*): (boolean|string)} */ export function isAllowedSize(allowedSize) { // allowedSize is based on MB return value =&gt; { if (!value) return false // if its an array of image if (value.length &gt; 1) { let finalVal = value.map(imageItem =&gt; { if (imageItem.size &gt; (1000000 * allowedSize)) { return false } }) return !finalVal.includes(false) || `One or some of your selected files' size is more than ${allowedSize} MB!` } else { // if its a single image return (!value[0] || value[0].size &lt; (1000000 * allowedSize)) || `file size should be less than ${allowedSize} MB!` } } } × Search results Close "},"store_introspector.js.html":{"id":"store_introspector.js.html","title":"Source: store/introspector.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: store/introspector.js import {isEqual} from 'lodash' import Client from \"../lib/GraphClient/GraphClient.js\" import introspectionQuery from \"../lib/GraphClient/queries/introspection.json\" let client = new Client(); export const mutations = { setParameters(state, data) { try { if (Object.keys(data).includes(\"errors\")) { state.error = data.errors[0].message } else { localStorage.introspectionQuery = JSON.stringify(data); let queryParams = data.data[\"__schema\"][\"types\"].filter(param =&gt; param.name === \"Query\")[0]; state.searchQueryParameters = queryParams.fields.filter(param =&gt; param.name === \"searchFairsharingRecords\")[0]; if (!localStorage.searchQueryParameters) { localStorage.searchQueryParameters = JSON.stringify(state.searchQueryParameters); } else { if (!isEqual(JSON.parse(localStorage.searchQueryParameters), JSON.parse(JSON.stringify(state.searchQueryParameters)))) { localStorage.searchQueryParameters = JSON.stringify(state.searchQueryParameters); } else { state.searchQueryParameters = JSON.parse(localStorage.searchQueryParameters); } } } } catch (e) { state.error = \"Can't initialize application\" } }, setLocalStorageExpiryTime: function () { let now = new Date(); localStorage.expiryDate = now; return now; }, setMaintenanceMode(state){ state.maintenanceMode = true; }, setReadOnlyMode(state){ state.readOnlyMode = true; } }; export const actions = { async fetchParameters(state, timer) { let expirationTimer = (timer) ? timer : 24; let data = await client.getData(introspectionQuery); if (localStorage.expiryDate) { const expiration = paramsAreExpired(localStorage.expiryDate, expirationTimer); if (expiration) { this.commit(\"introspection/setLocalStorageExpiryTime\"); this.commit(\"introspection/setParameters\", data.data); } else { this.commit(\"introspection/setParameters\", JSON.parse(localStorage.introspectionQuery)); } } if (!localStorage.introspectionQuery) { this.commit(\"introspection/setLocalStorageExpiryTime\"); this.commit(\"introspection/setParameters\", data.data); } if (data.headers['maintenance'] === \"true\") this.commit(\"introspection/setMaintenanceMode\"); if (data.headers['read-only'] === \"true\") this.commit(\"introspection/setReadOnlyMode\"); // temp! // this.commit(\"introspection/setMaintenanceMode\"); // this.commit(\"introspection/setReadOnlyMode\"); } }; export const getters = { buildQueryParameters: (state) =&gt; (params) =&gt; { let queryParameters = {}; Object.keys(params[1]).forEach(function (param) { let expectedTypeObject = null; if(state.searchQueryParameters.args === undefined) return; let currentParam = state.searchQueryParameters.args.filter(arg =&gt; arg.name === param)[0]; if(currentParam === undefined) return; expectedTypeObject = currentParam.type; if (expectedTypeObject.kind !== \"LIST\") { queryParameters[param] = parseParam(expectedTypeObject, params[1][param]); } else { const currentVal = params[1][param]; const expectedType = expectedTypeObject[\"ofType\"][\"ofType\"].name; queryParameters[param] = []; if (currentVal.indexOf(\",\") &gt; 0) { currentVal.split(\",\").forEach(function (val) { queryParameters[param].push(decodeURIComponent(parseParam(expectedType, val))) }); } else { queryParameters[param] = decodeURIComponent(parseParam(expectedType, currentVal)) } } }); return queryParameters; } }; /** * The introspection store is related to the introspection query that let us know which fields/types are allowed by the searchFairsharingRecords query * @type {Object} * */ let introspectionStore = { namespaced: true, /** * @name states * @type {Object} * @property {String} errors - collects errors while introspecting. * @property {object} searchQueryParameters - filters query parameters object coming from API. */ state: { errors: String, searchQueryParameters: {}, maintenanceMode: false, readOnlyMode: false }, modules: {}, mutations: mutations, actions: actions, getters: getters }; export default introspectionStore; /** * Given a type and a value, parse the value with the expected type. * @param {Object} param - the parameter types allowed * @param {String} paramVal - the value to be parsed * @returns {String | Number | Boolean} paramVal - the parse value * @example &lt;caption&gt; Example usage of parseParam &lt;/caption&gt; * parseParam({name: \"Boolean\"}, \"true\"); * // return True */ const parseParam = function (param, paramVal) { if (param.name === \"Int\") { return parseFloat(paramVal) } else if (param.name === \"Boolean\") { return JSON.parse(paramVal) } return paramVal }; /** * Compares the given date with now and returns true if it greater than the given timer * @param {Date} expiryDate - the date to compare * @param {Number} expirationTimer - the timer to determine if the date has been expired or not * @returns {boolean} - is the data expired or not */ export const paramsAreExpired = function (expiryDate, expirationTimer) { const limit = expirationTimer * 3600; const expiration = new Date(expiryDate); const now = new Date(); return ((now - expiration) - limit) &gt;= 0 }; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_AdvancedSearchDialogBox.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_AdvancedSearchDialogBox.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/AdvancedSearchDialogBox.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/AdvancedSearchDialogBox.vue &lt;template&gt; &lt;v-row justify=\"center\"&gt; &lt;v-dialog :value=\"dialog\" fullscreen persistent :retain-focus=\"false\" @keydown.esc=\"closeDialog()\" &gt; &lt;v-card&gt; &lt;div class=\"d-flex pt-6 px-6 justify-space-between\" :class=\"{ 'flex-column align-end': $vuetify.breakpoint.smAndDown, }\" &gt; &lt;!--Close Button --&gt; &lt;div class=\"order-md-3\" style=\"padding-left: 14.4%\" &gt; &lt;v-btn icon dark @click=\"closeDialog()\" &gt; &lt;v-icon color=\"black\" size=\"40px\" &gt; mdi-close &lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/div&gt; &lt;!--FAIRsharing Logo --&gt; &lt;router-link to=\"/\" class=\"mt-n5 order-md-1\" :class=\"{ 'mt-n15 mx-auto': $vuetify.breakpoint.smAndDown, }\" &gt; &lt;img src=\"/assets/fairsharing-logo.svg\" alt=\"FAIRsharing logo\" @click=\"closeDialog()\" &gt; &lt;/router-link&gt; &lt;!--Advanced Search Header Text --&gt; &lt;div class=\"order-sm-2\" style=\"text-align: center; margin: 0 auto 0 auto\" &gt; &lt;h2 class=\"primary--text\"&gt; Advanced filtering and searching for FAIRsharing records &lt;/h2&gt; &lt;p style=\"text-align: center\"&gt; Find out more about our Advanced Search in our &lt;a href=\"https://fairsharing.gitbook.io/fairsharing/how-to/advanced-search\" target=\"_blank\" class=\"text-decoration-underline\" &gt;gitbook documentation&lt;v-icon x-small&gt; {{ \"fa fa-link\" }} &lt;/v-icon&gt; &lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;v-card-title&gt; &lt;!--It will print the advancedSearch text on the dialog box when the search text is entered in the search field on the home page and advancedSearch is click--&gt; &lt;!-- &lt;div v-if=\"!getEditDialogStatus\"&gt;--&gt; &lt;!-- &lt;span class=\"text-h5\"&gt;--&gt; &lt;!-- {{ advancedSearchTerm }}--&gt; &lt;!-- &lt;/span&gt;--&gt; &lt;!-- &lt;/div&gt;--&gt; &lt;div class=\"d-flex full-width\"&gt; &lt;TooltipComponent :tool-tip-text=\"toolTipText\" text-colour=\"black--text\" /&gt; &lt;v-text-field v-if=\"!getEditDialogStatus\" ref=\"inputRef\" class=\"text-h5\" clearable full-width outlined hide-details label=\"Add Search text\" @change=\"updateSearchText($event)\" /&gt; &lt;v-text-field v-else class=\"text-h5\" clearable full-width outlined hide-details label=\"Add Search text\" :value=\"getAdvancedSearchText\" @input=\"updateSearchText($event)\" @change=\"updateSearchText($event)\" /&gt; &lt;/div&gt; &lt;/v-card-title&gt; &lt;v-card-text&gt; &lt;QueryBuilderView :is-dialog=\"dialog\" /&gt; &lt;/v-card-text&gt; &lt;v-card-actions class=\"px-6 justify-space-between\" :class=\"{ 'flex-column align-center': $vuetify.breakpoint.smAndDown, }\" &gt; &lt;v-btn color=\"green\" variant=\"text\" class=\"white--text order-md-2\" :class=\"{ 'mb-3': $vuetify.breakpoint.smAndDown, }\" :disabled=\"isContinue\" :width=\"$vuetify.breakpoint.smAndDown ? '100%' : '250'\" @click=\"goToAdvancedSearch()\" &gt; Proceed &lt;/v-btn&gt; &lt;v-btn color=\"accent3\" variant=\"text\" class=\"white--text order-md-1 ml-0\" :width=\"$vuetify.breakpoint.smAndDown ? '100%' : '250'\" @click=\"closeDialog()\" &gt; Close &lt;/v-btn&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;/v-row&gt; &lt;/template&gt; &lt;script&gt; import { isBoolean } from \"lodash\"; import { mapActions, mapGetters } from \"vuex\"; import TooltipComponent from \"@/components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/TooltipComponent.vue\"; import QueryBuilderView from \"@/components/Records/Search/Input/AdvancedSearch/QueryBuilderView.vue\"; import advancedSearch from \"@/store\"; import { uniqueValues } from \"@/utils/advancedSearchUtils\"; export default { name: \"AdvancedSearchDialogBox\", components: { QueryBuilderView, TooltipComponent }, props: { advancedSearchTerm: { default: \"\", type: String, }, }, data: () =&gt; { return { dialog: false, updatedAdvancedSearchText: \"\", toolTipText: \"Text will be searched against record fields such as name, abbreviation, description, tags, etc. Then, the results of that search will be filtered by the filters you have specified below.\", queryString: \"\", }; }, computed: { ...mapGetters(\"advancedSearch\", [ \"getAdvancedSearch\", \"getAdvancedSearchText\", \"getEditDialogStatus\", \"getAdvancedSearchDialogStatus\", ]), /** * Enables the proceed button when all the selected fields are non-empty * @returns {boolean} */ isContinue() { let isDisabled = true; let isTrue, allTrue; let isTrueArr = []; if ( this.getAdvancedSearch[\"children\"] &amp;&amp; this.getAdvancedSearch[\"children\"].length ) { this.getAdvancedSearch[\"children\"].forEach(({ children }) =&gt; { if (children &amp;&amp; children.length) { isTrue = children.every(({ value }) =&gt; value.length || isBoolean(value)); isTrueArr.push(isTrue); } }); } //Check if all values in the array is true if (isTrueArr &amp;&amp; isTrueArr.length) allTrue = isTrueArr.every((item) =&gt; item); if (allTrue) isDisabled = !allTrue; return isDisabled; }, }, watch: { getEditDialogStatus(newValue) { this.dialog = newValue; }, getAdvancedSearchDialogStatus(newValue) { this.dialog = newValue; //Reset searchText field if (newValue &amp;&amp; this.$refs.inputRef !== undefined) { this.$refs.inputRef.reset(); } }, }, mounted() { //When the user is redirected to advancedsearch url directly //it will open the dialog box if (this.$route.fullPath.toLowerCase() === \"/advancedsearch\") { advancedSearch.commit( \"advancedSearch/setAdvancedSearchDialogStatus\", true ); } }, methods: { ...mapActions(\"advancedSearch\", [\"fetchAdvancedSearchResults\"]), closeDialog() { this.dialog = false; advancedSearch.commit(\"advancedSearch/setEditDialogStatus\", false); advancedSearch.commit( \"advancedSearch/setAdvancedSearchDialogStatus\", false ); // Redirecting to home page after closing if (this.$route.fullPath.toLowerCase() === \"/advancedsearch\") { this.$router.push(\"/\"); } }, isAdvancedSearchTerm(queryString) { const queryValues = { q: this.getAdvancedSearchText, operator: this.getAdvancedSearch[\"operatorIdentifier\"], fields: queryString, }; return queryValues; }, noAdvancedSearchTerm(queryString) { const queryValues = { operator: this.getAdvancedSearch[\"operatorIdentifier\"], fields: queryString, }; return queryValues; }, /** * Method called on the click of the proceed button * in dialog box */ goToAdvancedSearch() { if (this.updatedAdvancedSearchText) { this.fetchAdvancedSearchResults(this.updatedAdvancedSearchText); } else { this.fetchAdvancedSearchResults(this.advancedSearchTerm); } this.closeDialog(); //Clear search text field flag this.$emit(\"clearSearchField\", true); this.advancedSearchQueryString(); this.advancedSearchNavigation(this.queryString); }, /** * Add advancedSearch selection to query params in * the URL by creating array of objects into string */ advancedSearchQueryString() { if ( this.getAdvancedSearch[\"children\"] &amp;&amp; this.getAdvancedSearch[\"children\"].length ) { this.getAdvancedSearch[\"children\"].forEach((item) =&gt; { this.queryString = \"\"; this.queryString += \"(operator=\"; this.queryString += item[\"operatorIdentifier\"]; const mergedValues = uniqueValues(item[\"children\"]); mergedValues.forEach((params) =&gt; { this.queryString += \"&amp;\"; this.queryString += params[\"identifier\"]; this.queryString += \"=\"; if (Array.isArray(params[\"value\"])) { this.queryString += params[\"value\"].toString(); } else if (params[\"value\"]) { this.queryString += params[\"value\"]; } }); this.queryString += \")\"; }); } }, /** * Navigation method called on the click of the proceed button * and on the advancedSearch page */ advancedSearchNavigation(queryString) { //When not on advancedSearch page if (this.$route.path !== \"/advancedsearch\") { if (this.getAdvancedSearchText) { this.$router.push({ name: \"AdvancedSearchResult\", query: this.isAdvancedSearchTerm(queryString), }); } else { this.$router.push({ name: \"AdvancedSearchResult\", query: this.noAdvancedSearchTerm(queryString), }); } } //When on advancedSearch page else { if (this.getAdvancedSearchText) { this.$router.push({ query: this.isAdvancedSearchTerm(queryString), }); } else { this.$router.push({ query: this.noAdvancedSearchTerm(queryString), }); } } }, /** * Method to fetch/update the searchTerm * @param {String} -- item */ updateSearchText(item) { this.updatedAdvancedSearchText = item; }, }, }; &lt;/script&gt; × Search results Close "},"views_AdvancedSearch_AdvancedSearchResultTable.vue.html":{"id":"views_AdvancedSearch_AdvancedSearchResultTable.vue.html","title":"Source: views/AdvancedSearch/AdvancedSearchResultTable.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: views/AdvancedSearch/AdvancedSearchResultTable.vue &lt;template&gt; &lt;div v-if=\"getErrorStatus\" fluid class=\"pa-0\" &gt; &lt;ErrorPage /&gt; &lt;/div&gt; &lt;div v-else fluid class=\"pa-5 mb-15\" &gt; &lt;v-btn class=\"mb-2\" color=\"primary\" small @click=\"downloadResults()\" &gt; Download Results &lt;/v-btn&gt; &lt;p class=\"body-2 mb-0\"&gt; &lt;v-icon x-small class=\"infoIcon\" &gt; {{ \"fa fa-info\" }} &lt;/v-icon&gt;Find out more about our Advanced Search in our &lt;a href=\"https://fairsharing.gitbook.io/fairsharing/how-to/advanced-search\" target=\"_blank\" class=\"text-decoration-underline\" &gt;gitbook documentation&lt;v-icon x-small&gt; {{ \"fa fa-link\" }} &lt;/v-icon&gt; &lt;/a&gt; &lt;/p&gt; &lt;v-data-iterator :items=\"getAdvancedSearchResponse\" :items-per-page.sync=\"itemsPerPage\" :page.sync=\"page\" :search=\"search\" :sort-by=\"sortBy.toLowerCase()\" :sort-desc=\"sortDesc\" :hide-default-footer=\"noFooter\" :loading=\"getLoadingStatus\" :footer-props=\"{ 'items-per-page-text': 'Records per page:', 'items-per-page-options': [5, 10, 25, 50, 100], }\" &gt; &lt;!-- headers start --&gt; &lt;template #header=\"{ pagination, options, updateOptions }\"&gt; &lt;v-data-footer :pagination=\"pagination\" :options=\"options\" items-per-page-text=\"Records per page:\" @update:options=\"updateOptions\" /&gt; &lt;v-toolbar dark color=\"blue lighten-1\" class=\"mb-5\" &gt; &lt;v-text-field v-model=\"search\" clearable flat solo-inverted hide-details prepend-inner-icon=\"mdi-filter\" label=\"Filter these results\" /&gt; &lt;template v-if=\"$vuetify.breakpoint.mdAndUp\"&gt; &lt;v-spacer /&gt; &lt;v-select v-model=\"sortBy\" flat solo-inverted hide-details :items=\"keys\" prepend-inner-icon=\"mdi-sort\" label=\"Sort by\" /&gt; &lt;v-spacer /&gt; &lt;v-btn-toggle v-model=\"sortDesc\" mandatory &gt; &lt;v-btn large depressed color=\"blue\" :value=\"false\" &gt; &lt;v-icon&gt;mdi-arrow-up&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;v-btn large depressed color=\"blue\" :value=\"true\" &gt; &lt;v-icon&gt;mdi-arrow-down&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/v-btn-toggle&gt; &lt;/template&gt; &lt;/v-toolbar&gt; &lt;/template&gt; &lt;!-- headers stop --&gt; &lt;!-- data section begins --&gt; &lt;template #default=\"props\"&gt; &lt;v-row&gt; &lt;v-col v-for=\"item in props.items\" :key=\"item.name\" cols=\"12\" &gt; &lt;v-card&gt; &lt;v-card-title class=\"subheading font-weight-bold\"&gt; &lt;RecordStatus :record=\"item\" /&gt; &lt;a :href=\"'/' + item.id\" target=\"_blank\" class=\"ml-10\" :class=\" item['status'] === 'deprecated' ? 'text-decoration-line-through' : null \" &gt; {{ item.name }} &lt;/a&gt; &lt;/v-card-title&gt; &lt;p class=\"mt-2 ml-10 pr-2 text-sm-body-2 text-md-body-1 text-justify text-ellipses-height-2lines\" &gt; {{ item.description }} &lt;/p&gt; &lt;TagChips :record=\"item\" class=\"ml-10\" /&gt; &lt;p class=\"pb-5\" /&gt; &lt;/v-card&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/template&gt; &lt;!-- data section ends --&gt; &lt;template #loading&gt; Loading... &lt;/template&gt; &lt;/v-data-iterator&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapActions, mapGetters } from \"vuex\"; import RecordStatus from \"@/components/Records/Shared/RecordStatus.vue\"; import TagChips from \"@/components/Records/Shared/TagChips.vue\"; import advancedSearch from \"@/store\"; import recordsCardUtils from \"@/utils/recordsCardUtils\"; import ErrorPage from \"@/views/Errors/404.vue\"; export default { name: \"AdvancedSearchResultTable\", components: { RecordStatus, TagChips, ErrorPage }, mixins: [recordsCardUtils], data() { return { itemsPerPageArray: [10, 20, 50, 100, 200], search: \"\", sortDesc: false, page: 1, itemsPerPage: 5, sortBy: \"name\", keys: [\"Name\", \"Registry\", \"Type\", \"Status\", \"Description\"], fairSharingURL: process.env.VUE_APP_FAIRSHARING_URL, }; }, computed: { ...mapGetters(\"advancedSearch\", [ \"getAdvancedSearchResponse\", \"getLoadingStatus\", \"getErrorStatus\", \"getAdvancedSearchQuery\", ]), noFooter() { return ( Array.isArray(this.getAdvancedSearchResponse) &amp;&amp; !this.getAdvancedSearchResponse.length ); }, }, mounted() { this.fetchQueryParams(); }, methods: { ...mapActions(\"advancedSearch\", [\"fetchAdvancedSearchResults\"]), /** * Fetch query from URL and display advancedSearch Result */ fetchQueryParams() { if ( Array.isArray(this.getAdvancedSearchResponse) &amp;&amp; !this.getAdvancedSearchResponse.length &amp;&amp; Array.isArray(this.getAdvancedSearchQuery[\"fields\"]) &amp;&amp; !this.getAdvancedSearchQuery[\"fields\"].length ) { // Checking if advancedsearch has query parameters if (Object.keys(this.$route.query).length) { const routeQuery = this.$route.query; //Query format is same as setAdvancedSearch mutation let searchQuery = { operatorIdentifier: \"\", children: [], }; searchQuery[\"operatorIdentifier\"] = routeQuery[\"operator\"]; //Destructuring the fields string into valid setAdvancedSearch format to execute the query const searchFieldsArr = routeQuery[\"fields\"] .split(\"(\") .join(\"\") .split(\")\") .filter((item) =&gt; item); //Filter is used to remove empty string searchFieldsArr.forEach((item) =&gt; { const itemArr = item.split(\"&amp;\"); let searchObj = { operatorIdentifier: \"\", children: [], }; itemArr.forEach((subItem) =&gt; { const paramValues = subItem.split(\"=\"); if (paramValues[0] === \"operator\") { searchObj[\"operatorIdentifier\"] = paramValues[1]; } else { let advancedSearchParams = { identifier: \"\", value: [] || Boolean, }; advancedSearchParams[\"identifier\"] = paramValues[0]; // For boolean/string values if ((paramValues[1] === \"true\") || paramValues[1] === \"false\") { advancedSearchParams[\"value\"] = paramValues[1]; } else { advancedSearchParams[\"value\"] = paramValues[1].split(\",\"); } searchObj[\"children\"].push(advancedSearchParams); } }); searchQuery[\"children\"].push(searchObj); }); //Committing the URL query param to setAdvancedSearch mutation in appropriate format to execute the advancedSearchQuery advancedSearch.commit( \"advancedSearch/setAdvancedSearch\", searchQuery ); //Committing the URL query param to setEditAdvancedSearch mutation in appropriate format to execute the edit advanced search advancedSearch.commit( \"advancedSearch/setEditAdvancedSearch\", searchQuery ); //Calling the fetch method to get the result if (routeQuery[\"q\"]) this.fetchAdvancedSearchResults(routeQuery[\"q\"]); else this.fetchAdvancedSearchResults(routeQuery[\"q\"]); } } }, /** * Download Results on click of download result button */ downloadResults() { const MIME_TYPE = \"text/csv\"; let data = [ \"Name 5,Abbreviation,FAIRsharingURL,FAIRsharing DOI,Homepage,Number of Publications \\n\", ]; this.getAdvancedSearchResponse.forEach((record) =&gt; { data.push( `${record.name.replace(/,/g, \"\")},${ record.abbreviation || \"n/a\" },https://fairsharing.org/${record.id},${record.doi || \"n/a\"},${ record.homepage || \"n/a\" },${this.recordPublicationsLength(record)}\\n` ); }); let blob = new Blob(data, { type: MIME_TYPE }); window.location.href = window.URL.createObjectURL(blob); }, /** * Calculate number of the publications for the record * @param record * @return {number} */ recordPublicationsLength(record) { return record[\"publications\"] &amp;&amp; record[\"publications\"].length ? record[\"publications\"].length : 0; }, }, }; &lt;/script&gt; &lt;style scoped&gt; .infoIcon { border: 1px solid; border-radius: 50%; padding: 3px 6px; margin: -2px 2px 0 0; } &lt;/style&gt; × Search results Close "},"views_AdvancedSearch_AdvancedSearchSelection.vue.html":{"id":"views_AdvancedSearch_AdvancedSearchSelection.vue.html","title":"Source: views/AdvancedSearch/AdvancedSearchSelection.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: views/AdvancedSearch/AdvancedSearchSelection.vue &lt;template&gt; &lt;v-card elevation=\"3\" :class=\"[ 'mx-2 full-width d-flex flex-column', $vuetify.breakpoint.mdAndUp ? responsiveClassObject : 'fullHeight', ]\" &gt; &lt;AdvancedSearchButtons /&gt; &lt;div v-if=\"getAdvancedSearchText\" class=\"searchText chips-holder ma-2\" &gt; &lt;v-chip class=\"ma-2 mt-2 text-capitalize\" color=\"accent3\" text-color=\"white\" label &gt; Search Text : {{ getAdvancedSearchText }} &lt;/v-chip&gt; &lt;/div&gt; &lt;div v-for=\"(item, index) in getAdvancedSearchQuery['fields']\" :key=\"index\" class=\"ma-2 selectionWrapper d-flex flex-column\" &gt; &lt;div class=\"chips-holder mb-2\"&gt; &lt;div v-for=\"([key, value], idx) in Object.entries(item)\" id=\"individualChips\" :key=\"idx\" class=\"individualChips d-flex flex-column align-center\" &gt; &lt;div class=\"my-2 mx-1 text-capitalize primary px-3 py-1 white--text rounded d-flex\" style=\"font-size: 14px\" &gt; &lt;span&gt;{{ printSelectionKeys(key) }} &lt;/span&gt; &lt;span&gt;&lt;strong&gt;&amp;nbsp;:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt; &lt;!-- eslint-disable vue/no-v-html --&gt; &lt;span v-html=\"printSelectionValues(key, value)\" /&gt; &lt;!-- eslint-enable vue/no-v-html --&gt; &lt;/div&gt; &lt;v-chip class=\"operatorChip\" color=\"accent\" text-color=\"accent\" outlined small &gt; {{ printSelectedOperator(item) }} &lt;/v-chip&gt; &lt;/div&gt; &lt;/div&gt; &lt;v-chip color=\"accent2\" class=\"parentOperatorChip text-uppercase font-weight-medium\" text-color=\"white\" &gt; {{ printOperator(getAdvancedSearchQuery[\"operator\"]) }} &lt;/v-chip&gt; &lt;/div&gt; &lt;/v-card&gt; &lt;/template&gt; &lt;script&gt; import { mapGetters, mapState } from \"vuex\"; import extraFilterChips from \"@/data/extraFilterChips.json\"; import stringUtils from \"@/utils/stringUtils\"; import AdvancedSearchButtons from \"@/views/AdvancedSearch/AdvancedSearchButtons.vue\"; export default { name: \"AdvancedSearchSelection\", components: { AdvancedSearchButtons }, mixins: [stringUtils], data() { return { operatorArr: [], }; }, computed: { ...mapState(\"uiController\", [\"UIGeneralStatus\"]), ...mapGetters(\"advancedSearch\", [ \"getAdvancedSearchQuery\", \"getAdvancedSearch\", \"getAdvancedSearchText\", ]), responsiveClassObject() { return { \"filters-holder-default\": this.UIGeneralStatus.headerVisibilityState, \"filters-holder-after-scroll\": !this.UIGeneralStatus.headerVisibilityState, }; }, }, methods: { /** * Print the within selection operator (_and/_or) * @param {Object} item - Selection object * @returns {String} operator - Operator _and/_or formatted as and/or */ printSelectedOperator(item) { let operatorValue; for (let i = 0; i &lt; Object.entries(item).length; i++) { operatorValue = Object.entries(item)[0][1]; } return this.printOperator(operatorValue); }, /** * Print the values with OR operator if multiple selection is done * @param {Object} key,value - Selection key value pair * @returns {String} value - Selection */ printSelectionValues(key, value) { let refinedValues = \"\"; if (key !== \"operator\") { if ((value === true) || (value[0] === \"true\")) { return \"true\" } if ((value === false) || (value[0] === \"false\")) { return \"false\" } else { refinedValues = value .map((item) =&gt; this.cleanString(item)) .join(\" OR \"); if (refinedValues !== \" \") { refinedValues = this.boldString(refinedValues, \"OR\"); return refinedValues; } } } }, /** * Print the keys and update the text transform if the key within the * extraFilterChips * @param {string } key - Selected key * @returns {string} key - Updated key */ printSelectionKeys(key) { let refinedKeys = key; extraFilterChips.forEach((item) =&gt; { let itemKey = Object.keys(item)[0]; let itemValue = Object.values(item)[0]; if (itemKey === key) refinedKeys = itemValue; }); return refinedKeys; }, printOperator(value) { if (value === \"_and\") return \"And\"; else if (value === \"_or\") return \"Or\"; }, /** * @param {String} str - String * @param {String} find - Find text to make it bold * @returns {String} - String with bold text */ boldString(str, find) { const re = new RegExp(find, \"g\"); return str.replace( re, \"&lt;span class='font-weight-medium'&gt;\" + find + \"&lt;/span&gt;\" ); }, }, }; &lt;/script&gt; &lt;style scoped lang=\"scss\"&gt; .fullHeight { height: 90vh; overflow: scroll; } .filters-holder-default { overflow-x: hidden; height: calc(100vh - 355px); position: sticky; top: 0; transition: height ease-in 500ms; overscroll-behavior: contain; scrollbar-width: thin; } .filters-holder-after-scroll { overflow-x: hidden; height: 100vh; position: sticky; top: 0; transition: height ease-in 500ms; overscroll-behavior: contain; scrollbar-width: thin; margin-bottom: 94px; } .chips-holder { background: #f5f5f5; border: 2px dotted #dbdbdb; border-radius: 10px !important; } .selectionWrapper { .parentOperatorChip { width: 50%; display: block; margin: 0 auto; text-align: center; //font-weight: 500; } &amp;:last-child { .parentOperatorChip { display: none; } } .chips-holder { .individualChips { width: 98%; margin: 0 auto; .chipText { overflow: hidden; text-overflow: ellipsis; width: 100%; } &amp;:first-child { display: none !important; } &amp;:last-child { .operatorChip { display: none !important; } } } } } &lt;/style&gt; × Search results Close "},"components_Records_Record_Collections.vue.html":{"id":"components_Records_Record_Collections.vue.html","title":"Source: components/Records/Record/Collections.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Record/Collections.vue &lt;template xmlns:v-slot=\"http://www.w3.org/1999/XSL/Transform\"&gt; &lt;v-card v-if=\"!tabsDataExist\" class=\"pa-4 d-flex flex-column\" outlined :color=\"backColor\" tile elevation=\"3\" &gt; &lt;SectionTitle title=\"Collections &amp;amp; Recommendations\" /&gt; &lt;div class=\"d-flex flex-column ml-2 min-height-40\"&gt; &lt;div class=\"d-flex flex-wrap mt-5\"&gt; &lt;!-- search autocomplete --&gt; &lt;v-autocomplete v-if=\"!tabsDataExist\" v-model=\"selectedValues\" :disabled=\"tabsData.tabs[Object.keys(tabsData.tabs)[tabsData.selectedTab]].data.length&lt;5\" :items=\"getValues\" solo :attach=\"true\" dense clearable prepend-inner-icon=\"fa-search\" :placeholder=\"`Search through ${cleanString(Object.keys(tabsData.tabs)[tabsData.selectedTab])}`\" item-text=\"name\" item-value=\"name\" &gt; &lt;template #item=\"data\"&gt; &lt;span class=\"filterValueName\"&gt; {{ data.item.name }} &lt;/span&gt; &lt;/template&gt; &lt;/v-autocomplete&gt; &lt;/div&gt; &lt;!-- tabs --&gt; &lt;v-tabs v-if=\"!tabsDataExist\" v-model=\"tabsData.selectedTab\" :show-arrows=\"$vuetify.breakpoint.mdAndDown\" background-color=\"transparent\" grow color=\"accent3\" slider-color=\"accent3\" class=\"mb-5\" :hide-slider=\"tabsData.tabs[Object.keys(tabsData.tabs)[tabsData.selectedTab]].data.length===0\" &gt; &lt;v-tab v-for=\"(tabName,tabIndex) in Object.keys(tabsData.tabs)\" :key=\"tabName+'_'+tabIndex\" :disabled=\"tabsData.tabs[tabName].data.length===0\" @change=\"selectedValues=null\" &gt; {{ cleanString(tabName) }} ({{ tabsData.tabs[tabName].count }}) &lt;/v-tab&gt; &lt;/v-tabs&gt; &lt;!-- tab content --&gt; &lt;v-tabs-items v-if=\"!tabsDataExist\" v-model=\"tabsData.selectedTab\" :class=\"['transparent',tabsDataExist]\" &gt; &lt;v-tab-item v-for=\"(tabItem,tabItemIndex) in filterList\" :key=\"tabItem+'_'+tabItemIndex\" &gt; &lt;v-virtual-scroll :items=\"tabItem.data\" height=\"400\" item-height=\"130\" class=\"ma-4 overflow-x-hidden\" &gt; &lt;template #default=\"{ item,index }\"&gt; &lt;router-link :to=\"'/'+item.id\" @click.native=\"()=&gt;$scrollTo('body',0,{})\" &gt; &lt;v-card :key=\"item.id + '_' + index\" class=\"pa-4 d-flex flex-column v-card-hover mx-2 height-120\" flat outlined &gt; &lt;div class=\"d-flex align-center\"&gt; &lt;record-status :record=\"item\" :show-status=\"false\" /&gt; &lt;div class=\"ml-10 underline-effect text-ellipses-height-2lines line-height-20\"&gt; {{ item.name }} &lt;/div&gt; &lt;/div&gt; &lt;p class=\"grey--text relation-style text-ellipses-height-2lines line-height-14 pr-5\"&gt; {{ item.object }} &lt;v-tooltip top&gt; &lt;template #activator=\"{ on }\"&gt; &lt;span class=\"red--text mouse-info\" v-on=\"on\" &gt; {{ item.recordAssociationLabel }} &lt;/span&gt; &lt;/template&gt; &lt;span&gt;{{ relationDefinition[item.recordAssociationLabel] }}&lt;/span&gt; &lt;/v-tooltip&gt; {{ item.subject }} &lt;/p&gt; &lt;/v-card&gt; &lt;/router-link&gt; &lt;/template&gt; &lt;/v-virtual-scroll&gt; &lt;/v-tab-item&gt; &lt;/v-tabs-items&gt; &lt;/div&gt; &lt;/v-card&gt; &lt;/template&gt; &lt;script&gt; import {mapState} from \"vuex\"; import SectionTitle from '@/components/Records/Record/SectionTitle'; import RecordStatus from \"@/components/Records/Shared/RecordStatus\"; import recordRelationShipsDefinitions from \"@/data/RecordRelationShipsDefinitions.json\"; import recordTabUtils from \"@/utils/recordTabUtils\"; import stringUtils from \"@/utils/stringUtils\" export default { name: \"Collections\", components: { RecordStatus, SectionTitle, }, mixins: [stringUtils, recordTabUtils], props:{ backColor:{ default:null, type: String, } }, data: () =&gt; { return { relationDefinition: recordRelationShipsDefinitions, selectedValues: null, tabsData: { selectedTab: 0, tabs: { in_collections: {relation: 'collects', data: [], count:0} } } } }, computed: { ...mapState(\"record\", [\"currentRecord\"]), }, methods: { /** Dynamically sets data for each tabs based on the data received from recordAssociations and reverseAssociations*/ prepareTabsData() { const _module = this; // There are different tabs for policies vs. other registries. if (_module.currentRecord['fairsharingRecord'].registry === 'Policy') { _module.tabsData.tabs.related_policies = { registry: ['Policy'], data: [], count:0 } } else { _module.tabsData.tabs.in_policies = { relation: 'recommends', data: [], count:0 } } if (Object.keys(_module.currentRecord['fairsharingRecord']).includes('recordAssociations') || Object.keys(_module.currentRecord['fairsharingRecord']).includes('reverseRecordAssociations')) { /* * In this case the related_policies tab could have relations going either way. */ if (_module.currentRecord['fairsharingRecord'].registry === 'Policy') { Object.keys(_module.tabsData.tabs).forEach(tabName =&gt; { // All policy relations, incoming or outgoing. if (tabName === 'related_policies') { _module.tabsData.tabs[tabName].data = _module.prepareAssociations( _module.currentRecord['fairsharingRecord'].recordAssociations, _module.currentRecord['fairsharingRecord'].reverseRecordAssociations ).filter( item =&gt; _module.tabsData.tabs[tabName].registry.includes(item.registry) ).filter( item =&gt; item.recordAssociationLabel !== 'collects' ) _module.tabsData.tabs[tabName].count = _module.tabsData.tabs[tabName].data.length; } // All incoming collections. else { _module.tabsData.tabs[tabName].data = _module.prepareAssociations( [], _module.currentRecord['fairsharingRecord']['reverseRecordAssociations'] ).filter(item =&gt; item.recordAssociationLabel === _module.tabsData.tabs[tabName].relation); _module.tabsData.tabs[tabName].count = _module.tabsData.tabs[tabName].data.length; } }) } /* * Here, only incoming recommends or collects relations are expected. */ else { Object.keys(_module.tabsData.tabs).forEach(tabName =&gt; { _module.tabsData.tabs[tabName].data = _module.prepareAssociations( [], _module.currentRecord['fairsharingRecord']['reverseRecordAssociations'] ).filter(item =&gt; item.recordAssociationLabel === _module.tabsData.tabs[tabName].relation); _module.tabsData.tabs[tabName].count = _module.tabsData.tabs[tabName].data.length; }) } } else { return false } }, } } &lt;/script&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Countries.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Countries.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Countries.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Countries.vue &lt;template&gt; &lt;div class=\"d-flex width-90\"&gt; &lt;TooltipComponent :tool-tip-text=\"toolTipText\" /&gt; &lt;AutoCompleteComponent v-model=\"model\" :item-value=\"itemValue\" :item-list=\"getSearchCountries\" :loading=\"getLoadingStatus\" @input=\"selectedValue\" @fetchData=\"getResults\" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapActions, mapGetters } from \"vuex\"; import countriesSearch from \"@/store\"; import AutoCompleteComponent from \"./AutoCompleteComponent.vue\"; import TooltipComponent from \"./TooltipComponent.vue\"; export default { name: \"Countries\", components: { TooltipComponent, AutoCompleteComponent }, props: { value: { type: Array, default: () =&gt; [], }, }, data: () =&gt; { return { itemSelected: [], itemValue: [], toolTipText: \"Countries applicable to this resource or its data. Multiple selections will be joined with OR. Start typing to see Countries.\", }; }, computed: { ...mapGetters(\"countriesSearch\", [\"getSearchCountries\", \"getLoadingStatus\"]), ...mapGetters(\"advancedSearch\", [\"getEditDialogStatus\"]), model: { get() { return this.itemSelected; }, set(value) { this.$emit(\"input\", value); }, }, }, watch: { itemSelected(newValue) { this.itemValue = newValue; }, /** * Item list for the autocomplete should not be empty * It is assigned with selected values when edit field is opened */ getEditDialogStatus: { handler(open) { if (open) { if (this.value &amp;&amp; this.value.length) { countriesSearch.commit( \"countriesSearch/setSearchCountries\", this.value ); } } }, immediate: true, }, }, mounted() { //Pre-fill selected values on edit advanced search is clicked and open this.itemValue = this.value; }, methods: { ...mapActions(\"countriesSearch\", [\"fetchSearchCountries\"]), selectedValue(item) { this.itemSelected = item; }, getResults(queryParams) { if (queryParams) this.fetchSearchCountries(queryParams); }, }, }; &lt;/script&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_GroupCtrlSlot_DatabaseRule.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_GroupCtrlSlot_DatabaseRule.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/GroupCtrlSlot/DatabaseRule.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/GroupCtrlSlot/DatabaseRule.vue &lt;template&gt; &lt;div class=\"d-flex mr-4\"&gt; &lt;select v-model=\"selectedDatabaseRule\" class=\"query-builder-group-slot__rule-selection mb-3\" &gt; &lt;option disabled value=\"\" &gt; Select a database rule &lt;/option&gt; &lt;option v-for=\"rule in databaseQueryBuilderComponents()\" :key=\"rule.identifier\" :value=\"rule.identifier\" v-text=\"rule.name\" /&gt; &lt;/select&gt; &lt;button :disabled=\"selectedDatabaseRule === ''\" class=\"query-builder-group-slot__rule-adding-button ml-3\" @click=\"addNewRule(groupCtrl, selectedDatabaseRule)\" &gt; Add Rule &lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { AssociatedTools, CertificationsAndCommunityBadges, CitationToRelatedPublications, DataAccessCondition, DataAccessForPrePublicationReview, DatabaseRecordType, DataContactInformation, DataCuration, DataDepositionCondition, DataPreservationPolicy, DataProcessesAndConditions, DataVersioning, ResourceSustainability } from \"../index\"; export default { name: \"DatabaseRule\", props: { groupCtrl: { type: Object, default: null } }, data: () =&gt; { return { selectedDatabaseRule: \"\", }; }, methods:{ databaseQueryBuilderComponents() { return [ { identifier: \"databasetype\", name: \"Database Record Type\", component: DatabaseRecordType, initialValue: () =&gt; [], }, { identifier: \"dataCuration\", name: \"Data Curation\", component: DataCuration, initialValue: () =&gt; [], }, { identifier: \"dataDepositionCondition\", name: \"Data Deposition Condition\", component: DataDepositionCondition, initialValue: () =&gt; [], }, { identifier: \"dataAccessCondition\", name: \"Data Access Condition \", component: DataAccessCondition, initialValue: () =&gt; [], }, { identifier: \"citationToRelatedPublications\", name: \"Citation To Related Publications\", component: CitationToRelatedPublications, initialValue: () =&gt; [], }, { identifier: \"dataAccessForPrePublicationReview\", name: \"Data Access For Pre Publication Review\", component: DataAccessForPrePublicationReview, initialValue: () =&gt; [], }, { identifier: \"dataContactInformation\", name: \"Data Contact Information\", component: DataContactInformation, initialValue: () =&gt; [], }, { identifier: \"dataVersioning\", name: \"Data Versioning\", component: DataVersioning, initialValue: () =&gt; [], }, { identifier: \"associatedTools\", name: \"Associated Tools\", component: AssociatedTools, initialValue: \"\", }, { identifier: \"certificationsAndCommunityBadges\", name: \"Certifications And Community Badges\", component: CertificationsAndCommunityBadges, initialValue: \"\", }, { identifier: \"dataProcessesAndConditions\", name: \"Data Processes And Conditions\", component: DataProcessesAndConditions, initialValue: \"\", }, { identifier: \"dataPreservationPolicy\", name: \"Data Preservation Policy\", component: DataPreservationPolicy, initialValue: \"\", }, { identifier: \"resourceSustainability\", name: \"Resource Sustainability\", component: ResourceSustainability, initialValue: \"\", }, ] }, /** * Add rule to query builder * @param item - Object * @param selectedRule - String */ addNewRule(item, selectedRule) { item.addRule(selectedRule) this.selectedDatabaseRule = '' }, } }; &lt;/script&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Domains.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Domains.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Domains.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Domains.vue &lt;template&gt; &lt;div class=\"d-flex width-90\"&gt; &lt;TooltipComponent :tool-tip-text=\"toolTipText\" /&gt; &lt;AutoCompleteComponent v-model=\"model\" :item-value=\"itemValue\" :item-list=\"getSearchDomains\" :loading=\"getLoadingStatus\" @input=\"selectedValue\" @fetchData=\"getResults\" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapActions, mapGetters } from \"vuex\"; import domainsSearch from \"@/store\"; import AutoCompleteComponent from \"./AutoCompleteComponent.vue\"; import TooltipComponent from \"./TooltipComponent.vue\"; export default { name: \"Domains\", components: { TooltipComponent, AutoCompleteComponent }, props: { value: { type: Array, default: () =&gt; [], }, }, data: () =&gt; { return { itemSelected: [], itemValue: [], toolTipText: \"Tags from the FAIRsharing Domain ontology. Multiple selections will be joined with OR. Start typing to see Domain tags.\", }; }, computed: { ...mapGetters(\"domainsSearch\", [\"getSearchDomains\", \"getLoadingStatus\"]), ...mapGetters(\"advancedSearch\", [\"getEditDialogStatus\"]), model: { get() { return this.itemSelected; }, set(value) { this.$emit(\"input\", value); }, }, }, watch: { itemSelected(newValue) { this.itemValue = newValue; }, /** * Item list for the autocomplete should not be empty * It is assigned with selected values when edit field is opened */ getEditDialogStatus: { handler(open) { if (open) { if (this.value &amp;&amp; this.value.length) { domainsSearch.commit(\"domainsSearch/setSearchDomains\", this.value); } } }, immediate: true, }, }, mounted() { //Pre-fill selected values on edit advanced search is clicked and open this.itemValue = this.value; }, methods: { ...mapActions(\"domainsSearch\", [\"fetchSearchDomains\"]), selectedValue(item) { this.itemSelected = item; }, getResults(queryParams) { if (queryParams) this.fetchSearchDomains(queryParams); }, }, }; &lt;/script&gt; × Search results Close "},"components_Records_Search_Input_FilterAutocomplete.vue.html":{"id":"components_Records_Search_Input_FilterAutocomplete.vue.html","title":"Source: components/Records/Search/Input/FilterAutocomplete.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/FilterAutocomplete.vue &lt;template&gt; &lt;v-expansion-panel v-if=\"filter.filterName\" :id=\"filter.filterName + 'AutocompleteList' \" &gt; &lt;v-expansion-panel-header&gt; {{ filter.filterLabel }}&lt;/v-expansion-panel-header&gt; &lt;v-expansion-panel-content class=\"pl-5 pr-5\"&gt; &lt;div :class=\"['d-flex',{'flex-column':$vuetify.breakpoint.mdAndDown}]\"&gt; &lt;v-autocomplete v-model=\"selectedValues\" :attach=\"true\" :items=\"getValues\" solo dense clearable multiple prepend-inner-icon=\"fa-search\" :placeholder=\"`Search`\" item-text=\"key\" item-value=\"key\" @focus=\"scrollTo(filter.filterName)\" @click:clear=\"reset(filter)\" &gt; &lt;template #selection=\"data\"&gt; &lt;v-chip class=\"blue white--text mb-1 \"&gt; &lt;span class=\"chipsValueName\"&gt; {{ cleanString(data.item.key) }} &lt;/span&gt; &lt;/v-chip&gt; &lt;/template&gt; &lt;template #item=\"data\"&gt; &lt;div class=\"d-flex full-width\"&gt; &lt;span class=\"filterValueName\"&gt; {{ cleanString(data.item.key) }}&lt;/span&gt; &lt;span class=\"filterValueCount\"&gt; {{ data.item['doc_count'] }}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/v-autocomplete&gt; &lt;v-btn color=\"primary\" class=\"ml-lg-2 custom-btn\" @click=\"applyFilters(filter)\" &gt; Apply &lt;/v-btn&gt; &lt;/div&gt; &lt;/v-expansion-panel-content&gt; &lt;/v-expansion-panel&gt; &lt;/template&gt; &lt;script&gt; import {mapGetters, mapState} from 'vuex' import clearString from '@/utils/stringUtils' export default { name: \"FilterAutocomplete\", mixins: [clearString], props: { filter: {default: null, type: Object}, lastItem:{default:false, type:Boolean} }, data: () =&gt; { return { selectedValues: [] } }, computed: { ...mapGetters('records', ['getFilter']), ...mapState('uiController', ['stickToTop']), getValues: function () { let _module = this; let output = _module.getFilter(this.filter.filterName); if (output.values &amp;&amp; typeof output.values === 'object') { return output.values; } return [] } }, methods: { /** * Apply the filters by building the new query parameters using the form data. */ applyFilters: function () { let _module = this; let filterName = _module.filter.filterName; let currentParams = JSON.parse(JSON.stringify(_module.$route.query)); if (Object.keys(currentParams).indexOf(filterName) === -1) { if (_module.selectedValues !== null &amp;&amp; _module.selectedValues.length &gt; 0) { if (_module.selectedValues.length === 1) { currentParams[filterName] = encodeURIComponent(_module.selectedValues.join(',')); } else { let newParam = []; _module.selectedValues.forEach(function (val) { newParam.push(encodeURIComponent(val)); }); currentParams[filterName] = newParam.join(\",\"); } currentParams['page'] = 1; _module.$router.push({ name: _module.$route.name, query: currentParams }); } } else { if (_module.selectedValues === null || _module.selectedValues.length === 0) { delete currentParams[_module.filter.filterName]; currentParams['page'] = 1; _module.$router.push({ name: _module.$route.name, query: currentParams }); } else { let newParams = []; let existingValues = currentParams[_module.filter.filterName].split(\",\"); _module.selectedValues.forEach(function (selectedValue) { const filterVal = encodeURIComponent(selectedValue); if (existingValues.indexOf(filterVal) === -1) { newParams.push(filterVal); } }); currentParams[_module.filter.filterName] += `,${newParams.join(\",\")}`; if (newParams.length &gt; 0) { currentParams['page'] = 1; _module.$router.push({ name: _module.$route.name, query: currentParams }); } } } _module.selectedValues = []; }, /** * Reset the form/filters/parameters to default (go so /search?page=1) */ reset: function (selectedItem) { selectedItem.filterSelected = {}; }, /* istanbul ignore next */ scrollTo(name) { let _module = this; _module.$scrollTo(\"#\" + name + 'AutocompleteList', 450, { container: '#scrollable-holder', easing: 'ease-in', }) } } } &lt;/script&gt; &lt;style scoped&gt; .filterValueName { text-overflow: ellipsis; overflow: hidden; white-space: nowrap; flex: 1; } .chipsValueName { width: 100%; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } .filterValueCount { background: #2196F3; color: white; padding: 0 7px; } .custom-btn { height: 38px; } &lt;/style&gt; × Search results Close "},"components_Records_Search_Input_FilterButton.vue.html":{"id":"components_Records_Search_Input_FilterButton.vue.html","title":"Source: components/Records/Search/Input/FilterButton.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/FilterButton.vue &lt;template&gt; &lt;v-tooltip bottom :disabled=\"itemModified.tooltip===undefined || $vuetify.breakpoint.smAndDown\" &gt; &lt;template #activator=\"{ on }\"&gt; &lt;v-btn color=\"primary\" class=\"mr-1 mr-lg-2\" :outlined=\"!itemModified.active\" :class=\"[isFirstItem &amp;&amp; !doubleItems ? 'first-child' : 'flex-1', {'button-style-md-screens' : mdScreens, 'buttons-md-style' : multipleItems &amp;&amp; !isFirstItem}]\" @click=\"selectFilter(itemModified)\" v-on=\"on\" &gt; &lt;span v-if=\"itemModified.title!=='ALL'\"&gt;{{ itemModified.title }}&lt;/span&gt; &lt;v-icon v-else small color=\"primary\" &gt; {{ $vuetify.icons.values.loading }} &lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/template&gt; &lt;span&gt;{{ itemModified.tooltip }}&lt;/span&gt; &lt;/v-tooltip&gt; &lt;/template&gt; &lt;script&gt; import { isEqual } from \"lodash\"; import { mapActions } from 'vuex' import currentParameter from \"@/utils/currentParameterMixin.js\" export default { name: \"FilterButton\", mixins: [currentParameter], props: { item: {default: null, type: Object}, isFirstItem: {default: false, type: Boolean}, mdScreens: {default: null, type: Boolean}, itemParentIndex: {default: 0, type: Number}, multipleItems: {default: false, type: Boolean}, doubleItems: {default: false, type: Boolean}, }, data: () =&gt; { return { itemModified: {default: null, type: Object} } }, watch: { currentParameter: { handler(newVal) { const _module = this; const fieldName = _module.itemModified.filterName; const fieldValue = newVal[fieldName]; const currentValue = _module.itemModified.value; const title = _module.itemModified.title; _module.checkCurrentParameters(title, fieldValue, currentValue); }, deep: true } }, mounted(){ this.$nextTick(function () { const _module = this; _module.itemModified = JSON.parse(JSON.stringify(this.item)); const fieldValue = _module.currentParameter[this.itemModified.filterName]; const currentValue = _module.itemModified.value; const title = _module.itemModified.title; _module.checkCurrentParameters(title, fieldValue, currentValue); }); }, methods: { checkCurrentParameters: function(title, fieldValue, currentValue) { if (fieldValue === null) { this.itemModified.active = title === 'all' || title === 'match all terms'; } else { if (currentValue === undefined) { this.itemModified.active = false; } else { this.itemModified.active = currentValue.toString() === fieldValue; } } }, /** * Apply the filters by building the new query parameters using the form data. */ applyFilters: function (selectedItem) { const _module = this; let currentQuery = {}; let oldQuery = {}; Object.keys(_module.$route.query).forEach(function (param) { currentQuery[param] = _module.$route.query[param]; oldQuery[param] = _module.$route.query[param] }); Object.prototype.hasOwnProperty.call(selectedItem, 'value') ? currentQuery[selectedItem.filterName] = encodeURIComponent(selectedItem.value) : delete currentQuery[selectedItem.filterName]; if (!isEqual(currentQuery, oldQuery)) { currentQuery['page'] = 1; this.$router.push({ name: _module.$route.name, query: currentQuery }); } }, selectFilter: function (selectedItem) { let _module = this; _module.resetFilterButtons(_module.itemParentIndex); _module.activateButton({ 'activeItem': selectedItem, 'itemParentIndex': _module.itemParentIndex }); this.applyFilters(selectedItem); }, ...mapActions(\"searchFilters\", [\"resetFilterButtons\", \"activateButton\"]) } } &lt;/script&gt; &lt;style scoped&gt; .button-style-md-screens { font-size: 9px !important; } .first-child { font-size: 11px; width: 16.5%; } .flex-1 { font-size: 11px; flex: 1; } .buttons-md-style { min-width: 32px !important; } &lt;/style&gt; × Search results Close "},"components_Records_Search_Header_FilterChips.vue.html":{"id":"components_Records_Search_Header_FilterChips.vue.html","title":"Source: components/Records/Search/Header/FilterChips.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Header/FilterChips.vue &lt;template&gt; &lt;v-row class=\"mr-2 ml-2 pb-3\"&gt; &lt;v-chip v-if=\"getChips.length\" class=\"ma-2 mt-5\" color=\"red\" text-color=\"white\" @click=\"removeAllParams\" &gt; Clear All &lt;/v-chip&gt; &lt;div v-for=\"(chip, index) in getChips\" :key=\"'Chips_' + index\" &gt; &lt;v-chip class=\"ma-2 mt-5\" close color=\"white\" text-color=\"secondary\" @click:close=\"removeParam(chip.paramName, chip.paramVal)\" &gt; {{ getFilteredLabel[chip.paramName] }}:&lt;b class=\"ml-1\"&gt; {{ decodeURIComponent(chip.paramVal).replace(/_/g, \" \") }}&lt;/b&gt; &lt;/v-chip&gt; &lt;/div&gt; &lt;/v-row&gt; &lt;/template&gt; &lt;script&gt; import {throttle} from \"lodash\" import extraFilterChips from \"@/data/extraFilterChips.json\" import filterMapping from \"@/data/FiltersLabelMapping.json\" import filterChipsUtils from \"@/utils/filterChipsUtils\"; export default { name: \"FilterChips\", mixins: [filterChipsUtils], computed: { /** * get the Filtered label that correponds to the name using the map FilterLabel * @returns {Object} - object with the mapping names and labels */ getFilteredLabel: function () { let filterLabels = { q: \"Query string\", userDefinedTags: \"User defined tags\" }; Object.keys(filterMapping[\"autocomplete\"]).forEach((filterName) =&gt; { let field = filterMapping[\"autocomplete\"][filterName]; filterLabels[field.filterName] = field.filterLabel; }); /* * These labels are specific to the FAIRsharing Wizard and aren't normally required in the search sidebar, * so they are defined here rather than in filterMapping. */ extraFilterChips.forEach(function(extra) { let key = Object.keys(extra)[0] filterLabels[key] = extra[key]; }) return filterLabels; } }, methods: { /** * Removes the parameter value from the router query with a 2000ms throttle * @param {String} paramName - name of the parameter to remove * @param {String} paramVal - value of the parameter to remove */ removeParam: throttle(async function (paramName, paramVal) { let _module = this; let query = this.buildNewQuery(paramName, paramVal); await _module.$router.push({ name: _module.$route.name, query: query }) }, 2000), /** * Removes all the parameters value from the router query with a 2000ms throttle */ removeAllParams: throttle(async function () { let _module = this; let query = {}; await _module.$router.push({ name: _module.$route.name, query: query }) }, 2000), /** * Build the new query given a parameter name a value by getting the current query and removing the key/value given * @param {String} paramName - name of the parameter to remove * @param {String} paramVal - value of the parameter to remove * @returns {Object} - the new query to replace in the router */ buildNewQuery: function (paramName, paramVal) { let _module = this; let query = {}; Object.keys(_module.$route.query).forEach(function (queryParam) { if (queryParam !== paramName) { query[queryParam] = _module.$route.query[queryParam] } else { if (_module.$route.query[queryParam].includes(',')) { let currentValues = _module.$route.query[queryParam].split(\",\"); if (currentValues.includes(paramVal)) { currentValues.splice(currentValues.indexOf(paramVal), 1) } query[paramName] = currentValues.join(\",\"); } } }); query[\"page\"] = 1; return query; } } } &lt;/script&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_GroupCtrlSlot_GeneralRule.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_GroupCtrlSlot_GeneralRule.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/GroupCtrlSlot/GeneralRule.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/GroupCtrlSlot/GeneralRule.vue &lt;template&gt; &lt;div class=\"ruleWrapper d-flex mr-4\"&gt; &lt;select v-model=\"selectedGeneralRule\" class=\"query-builder-group-slot__rule-selection mb-3\" &gt; &lt;option disabled value=\"\" &gt; Select a rule &lt;/option&gt; &lt;option v-for=\"rule in generalQueryBuilderComponents()\" :key=\"rule.identifier\" :value=\"rule.identifier\" v-text=\"rule.name\" /&gt; &lt;/select&gt; &lt;button :disabled=\"selectedGeneralRule === ''\" class=\"query-builder-group-slot__rule-adding-button ml-3\" @click=\"addNewRule(groupCtrl, selectedGeneralRule)\" &gt; Add Rule &lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { Countries, Domain, Licences, Organisations, PolicyRecordType, RecordStatus, Registry, StandardRecordType, Subject, Taxonomies, UserDefinedTag } from \"../index\"; export default { name: \"GeneralRule\", props: { groupCtrl: { type: Object, default: null } }, data: () =&gt; { return { selectedGeneralRule: \"\", }; }, methods:{ generalQueryBuilderComponents() { return [ { identifier: \"registry\", name: \"Registry\", component: Registry, initialValue: () =&gt; [], }, { identifier: \"standardtype\", name: \"Standard Record Type\", component: StandardRecordType, initialValue: () =&gt; [], }, { identifier: \"policytype\", name: \"Policy Record Type\", component: PolicyRecordType, initialValue: () =&gt; [], }, { identifier: \"subjects\", name: \"Subject\", component: Subject, initialValue: () =&gt; [], }, { identifier: \"domains\", name: \"Domain\", component: Domain, initialValue: () =&gt; [], }, { identifier: \"userDefinedTags\", name: \"User Defined Tag\", component: UserDefinedTag, initialValue: () =&gt; [], }, { identifier: \"status\", name: \"Record Status\", component: RecordStatus, initialValue: () =&gt; [], }, { identifier: \"taxonomies\", name: \"Taxonomies\", component: Taxonomies, initialValue: () =&gt; [], }, { identifier: \"licences\", name: \"Licences\", component: Licences, initialValue: () =&gt; [], }, { identifier: \"countries\", name: \"Countries\", component: Countries, initialValue: () =&gt; [], }, { identifier: \"organisations\", name: \"Organisations\", component: Organisations, initialValue: () =&gt; [], }, ] }, /** * Add rule to query builder * @param item - Object * @param selectedRule - String */ addNewRule(item, selectedRule) { item.addRule(selectedRule) this.selectedGeneralRule = '' }, } }; &lt;/script&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_GroupCtrlSlot_GroupCtrlSlot.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_GroupCtrlSlot_GroupCtrlSlot.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/GroupCtrlSlot/GroupCtrlSlot.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/GroupCtrlSlot/GroupCtrlSlot.vue &lt;template&gt; &lt;div class=\"query-builder-group-slot__group-control pa-4 d-flex\"&gt; &lt;!-- General Component --&gt; &lt;GeneralRule :group-ctrl=\"groupCtrl\" /&gt; &lt;!-- Database Component --&gt; &lt;DatabaseRule :group-ctrl=\"groupCtrl\" /&gt; &lt;div class=\"query-builder-group-slot__spacer\" /&gt; &lt;button class=\"query-builder-group-slot__group-adding-button\" @click=\"addNewGroup(groupCtrl)\" &gt; Add Group &lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import {DatabaseRule,GeneralRule} from \"./index\"; export default { name: \"GroupCtrlSlot\", components:{GeneralRule, DatabaseRule}, props: { groupCtrl: { type: Object, default: null } }, methods:{ /** * Add group to query builder * @param item - Object */ addNewGroup(item) { item.newGroup() }, } }; &lt;/script&gt; × Search results Close "},"views_Home_Home.vue.html":{"id":"views_Home_Home.vue.html","title":"Source: views/Home/Home.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: views/Home/Home.vue &lt;template&gt; &lt;v-main&gt; &lt;v-container fluid class=\"text-center pa-0\" &gt; &lt;Carousel /&gt; &lt;InfoBlock class=\"mb-12\" /&gt; &lt;SearchBlock /&gt; &lt;CategoryBlock class=\"mt-12\" /&gt; &lt;CommunityBlock class=\"mt-12\" /&gt; &lt;v-lazy&gt; &lt;StatisticsBlock class=\"my-12\" /&gt; &lt;/v-lazy&gt; &lt;/v-container&gt; &lt;!-- This html is from a safe source --&gt; &lt;!-- eslint-disable vue/no-v-html --&gt; &lt;script type=\"application/ld+json\" v-html=\"JSONLD\" /&gt; &lt;!-- eslint-enable vue/no-v-html --&gt; &lt;/v-main&gt; &lt;/template&gt; &lt;script&gt; import Carousel from \"@/components/Home/Carousel\"; import CategoryBlock from \"@/components/Home/CategoryBlock\"; import CommunityBlock from \"@/components/Home/CommunityBlock\"; import InfoBlock from \"@/components/Home/InfoBlock\"; import SearchBlock from \"@/components/Home/SearchBlock\"; import StatisticsBlock from \"@/components/Home/StatisticsBlock\"; import RestClient from \"@/lib/Client/RESTClient.js\" const restClient = new RestClient(); /** Component to handle the front page (landing page) * */ export default { name: \"Home\", components:{Carousel, InfoBlock, SearchBlock, CategoryBlock, StatisticsBlock, CommunityBlock }, data() { return { JSONLD: {} } }, mounted() { this.getJsonld(); }, destroyed() { this.$scrollTo('body',0,{}); }, methods: { async getJsonld() { this.JSONLD = await restClient.getHomepageJsonld(); }, } }; &lt;/script&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Licences.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Licences.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Licences.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Licences.vue &lt;template&gt; &lt;div class=\"d-flex width-90\"&gt; &lt;TooltipComponent :tool-tip-text=\"toolTipText\" /&gt; &lt;AutoCompleteComponent v-model=\"model\" :item-value=\"itemValue\" :item-list=\"getSearchLicences\" :loading=\"getLoadingStatus\" @input=\"selectedValue\" @fetchData=\"getResults\" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapActions, mapGetters } from \"vuex\"; import licencesSearch from \"@/store\"; import AutoCompleteComponent from \"./AutoCompleteComponent.vue\"; import TooltipComponent from \"./TooltipComponent.vue\"; export default { name: \"Licences\", components: { TooltipComponent, AutoCompleteComponent }, props: { value: { type: Array, default: () =&gt; [], }, }, data: () =&gt; { return { itemSelected: [], itemValue: [], toolTipText: \"Licences applicable to this resource or its data. Multiple selections will be joined with OR. Start typing to see Licenses.\", }; }, computed: { ...mapGetters(\"licencesSearch\", [\"getSearchLicences\", \"getLoadingStatus\"]), ...mapGetters(\"advancedSearch\", [\"getEditDialogStatus\"]), model: { get() { return this.itemSelected; }, set(value) { this.$emit(\"input\", value); }, }, }, watch: { itemSelected(newValue) { this.itemValue = newValue; }, /** * Item list for the autocomplete should not be empty * It is assigned with selected values when edit field is opened */ getEditDialogStatus: { handler(open) { if (open) { if (this.value &amp;&amp; this.value.length) { licencesSearch.commit( \"licencesSearch/setSearchLicences\", this.value ); } } }, immediate: true, }, }, mounted() { //Pre-fill selected values on edit advanced search is clicked and open this.itemValue = this.value; }, methods: { ...mapActions(\"licencesSearch\", [\"fetchSearchLicences\"]), selectedValue(item) { this.itemSelected = item; }, getResults(queryParams) { if (queryParams) this.fetchSearchLicences(queryParams); }, }, }; &lt;/script&gt; × Search results Close "},"views_Users_Login_Login.vue.html":{"id":"views_Users_Login_Login.vue.html","title":"Source: views/Users/Login/Login.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: views/Users/Login/Login.vue &lt;template&gt; &lt;v-form id=\"loginPage\" ref=\"loginPage\" v-model=\"formValid\" class=\"login\" style=\"background: white\" &gt; &lt;v-container&gt; &lt;!-- forms --&gt; &lt;v-row justify=\"center\"&gt; &lt;v-col cols=\"12\" sm=\"12\" :md=\"!popUp ? '8' : '12' \" :lg=\"!popUp ? '8' : '12' \" :xl=\"!popUp ? '5' : '12' \" &gt; &lt;v-card :flat=\"popUp\"&gt; &lt;v-card-title :class=\"{'blue white--text mb-5': !popUp, 'py-0 mb-5': popUp}\"&gt; &lt;h2 class=\"ma-0\"&gt; {{ currentPanel | capitalize }} &lt;/h2&gt; &lt;/v-card-title&gt; &lt;v-card-text&gt; &lt;!-- message handler --&gt; &lt;MessageHandler field=\"login\" /&gt; &lt;!-- button to re-send confirmation if login failed --&gt; &lt;div v-if=\"resendButton\" class=\"d-flex flex-row justify-center\" &gt; &lt;v-btn class=\"text-center teal white--text px-2\" href=\"/users/resendConfirmation\" @click=\"()=&gt;{$emit('ClosePopup', true)}\" &gt; Resend me the confirmation email &lt;/v-btn&gt; &lt;/div&gt; &lt;v-divider v-if=\"resendButton\" class=\"pb-0 mb-0\" /&gt; &lt;!-- OAUTH --&gt; &lt;v-list&gt; &lt;v-list-item v-for=\"(provider, providerIndex) in oauthLogin\" :key=\"'provider_' + providerIndex\" style=\"justify-content: center\" &gt; &lt;v-btn width=\"250px\" :class=\"provider.color\" class=\"text-left\" :href=\"provider.callback + getCurrentLocation()\" &gt; &lt;v-layout width=\"100%\"&gt; &lt;v-icon left class=\"mr-5\" &gt; {{ 'fab fa-' + provider.name.toLowerCase() }} &lt;/v-icon&gt; &lt;v-layout&gt;with {{ provider.name }}&lt;/v-layout&gt; &lt;/v-layout&gt; &lt;/v-btn&gt; &lt;/v-list-item&gt; &lt;/v-list&gt; &lt;/v-card-text&gt; &lt;!-- card content // Form --&gt; &lt;v-card-text v-if=\"currentPanel === 'login'\"&gt; &lt;v-form id=\"loginForm\" ref=\"loginForm\" v-model=\"formValid\" &gt; &lt;!-- account --&gt; &lt;v-text-field v-model=\"loginData.name\" label=\"Username or email\" required outlined :rules=\"[rules.isRequired()]\" @keyup.enter=\"logUser()\" /&gt; &lt;!-- password --&gt; &lt;v-text-field v-model=\"loginData.password\" :append-icon=\"show1 ? 'fa-eye' : 'fa-eye-slash'\" :type=\"show1 ? 'text' : 'password'\" label=\"Password\" counter required outlined :rules=\"[rules.isRequired()]\" @click:append=\"show1 = !show1\" @keyup.enter=\"logUser()\" /&gt; &lt;v-card-text class=\"text-center py-1\"&gt; &lt;router-link to=\"/accounts/forgotPassword\"&gt; &lt;span @click=\"()=&gt;{$emit('ClosePopup', true)}\"&gt;Forgotten your password?&lt;/span&gt; &lt;/router-link&gt; &lt;v-divider /&gt; &lt;router-link to=\"/accounts/signup\"&gt; &lt;span @click=\"()=&gt;{$emit('ClosePopup', true)}\"&gt;Need to create a new account?&lt;/span&gt; &lt;/router-link&gt; &lt;v-divider /&gt; &lt;a href=\"https://fairsharing.gitbook.io/fairsharing/#accessing-fairsharing-through-3rd-party-accounts\" target=\"_blank\" &gt; &lt;span @click=\"()=&gt;{$emit('ClosePopup', true)}\"&gt;Can't login with ORCID?&lt;/span&gt; &lt;/a&gt; &lt;/v-card-text&gt; &lt;v-card-actions class=\"mt-2 justify-center\"&gt; &lt;v-btn class=\" px-4\" light color=\"primary\" :disabled=\"!formValid\" @click=\"logUser()\" &gt; LOGIN &lt;/v-btn&gt; &lt;/v-card-actions&gt; &lt;/v-form&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/v-container&gt; &lt;/v-form&gt; &lt;/template&gt; &lt;script&gt; import {mapActions, mapState} from 'vuex' import MessageHandler from \"@/components/Users/MessageHandler\"; import { isRequired } from \"@/utils/rules.js\" import stringUtils from '@/utils/stringUtils'; /** This component handles the login page * */ export default { name: \"Login\", components: {MessageHandler}, mixins: [stringUtils], props: { redirect: { type: Boolean, default: true, }, popUp: { type: Boolean, default: false, }, }, data: () =&gt; { return { show1: false, resendButton: false, currentPanel: \"login\", loginData: {}, oauthLogin: [ { name: \"ORCID\", color: \"green white--text\", callback: process.env.VUE_APP_API_ENDPOINT + \"/users/auth/orcid\", }, // See: https://github.com/FAIRsharing/fairsharing.github.io/issues/2184 /* { name: \"Twitter\", color: \"blue white--text\", callback: process.env.VUE_APP_API_ENDPOINT + \"/users/auth/twitter\", }, */ { name: \"GitHub\", color: \"black white--text\", callback: process.env.VUE_APP_API_ENDPOINT + \"/users/auth/github\", } ], rules: { isRequired: function(){return isRequired()}, }, formValid: false } }, computed: { ...mapState(\"users\", [\"messages\", \"user\"]), }, methods: { ...mapActions('users', ['login', 'logout']), async logUser() { const _module = this; const user = { \"name\": _module.loginData.name, \"password\": _module.loginData.password }; _module.$emit('ClosePopup',false); await _module.login(user); if (_module.messages().login.error) { const confirmationError = \"You have to confirm your email address before continuing.\"; if (_module.messages().login.message === confirmationError) { _module.resendButton = true; } } else { const goTo = _module.$route.query.goTo; if (_module.redirect) { if (goTo) { _module.$router.push({ path: goTo }) } else { _module.$router.push({ path: \"/accounts/profile\" }) } } } }, returnTo() { const _module = this; const goTo = _module.$route.query.goTo; if (goTo) { return `?return_to=${goTo}`; } return ''; }, getCurrentLocation() { let loc = this.$router.currentRoute.path; let params = this.$route.query; let query = Object.keys(params).map(k=&gt;`${k}=${params[k]}`).join('&amp;').replace(\"next=\",\"\"); let origin; if (params.length &gt; 0) { origin = encodeURI(`${loc}`); } else { origin = encodeURI(`${loc}?${query}`); } return `?origin=${origin}`; } } } &lt;/script&gt; &lt;style scoped&gt; #loginPage a { text-decoration: none !important; } .v-card__text { width: auto; } &lt;/style&gt; × Search results Close "},"views_CreateRecord_NewRecord.vue.html":{"id":"views_CreateRecord_NewRecord.vue.html","title":"Source: views/CreateRecord/NewRecord.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: views/CreateRecord/NewRecord.vue &lt;template&gt; &lt;v-container id=\"createRecord\" fluid &gt; &lt;v-form id=\"createRecord\" ref=\"createRecord\" v-model=\"formValid\" &gt; &lt;v-row&gt; &lt;v-col cols=\"12\"&gt; &lt;v-card v-if=\"loaded\"&gt; &lt;v-card-title class=\"primary white--text\"&gt; &lt;h3 class=\"white--text\"&gt; Creating a new FAIRsharing record &lt;/h3&gt; &lt;/v-card-title&gt; &lt;v-card-text v-if=\"message.error\" class=\"pt-4\" &gt; &lt;v-alert type=\"error\"&gt; {{ message.value }}&lt;v-icon class=\"px-3\"&gt; fa-arrow-right &lt;/v-icon&gt; {{ message.value.response.data }} &lt;/v-alert&gt; &lt;/v-card-text&gt; &lt;v-card-text class=\"pt-3\"&gt; &lt;v-container fluid&gt; &lt;v-row&gt; &lt;base-fields :create-mode=\"true\" :submit-record=\"submitAnyway\" :loading=\"loading\" @submission=\"setSubmitAnyway()\" @clearing=\"tryAgain()\" @createnewrecord=\"createRecord()\" /&gt; &lt;/v-row&gt; &lt;/v-container&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;v-fade-transition&gt; &lt;v-overlay v-if=\"!loaded\" :absolute=\"false\" opacity=\"0.8\" &gt; &lt;loaders /&gt; &lt;/v-overlay&gt; &lt;/v-fade-transition&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/v-form&gt; &lt;v-dialog v-model=\"recordCreated\" max-width=\"700px\" &gt; &lt;v-card&gt; &lt;v-card-title class=\"headline\" &gt; &lt;p&gt; &lt;b&gt;Success!&lt;/b&gt; &lt;/p&gt; &lt;/v-card-title&gt; &lt;v-card-text&gt; Draft submission saved. Next, please complete curation on your record. &lt;/v-card-text&gt; &lt;v-card-actions&gt; &lt;v-spacer /&gt; &lt;v-btn color=\"blue darken-1\" text @click=\"redirectToEdit(newRecord)\" &gt; OK &lt;/v-btn&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;/v-container&gt; &lt;/template&gt; &lt;script&gt; import { mapActions, mapGetters,mapState } from \"vuex\" import status from \"@/data/status.json\" import RESTClient from \"@/lib/Client/RESTClient.js\" import { isUrl } from \"@/utils/rules.js\" import BaseFields from \"../../components/Editor/GeneralInformation/BaseFields\"; import Loaders from \"../../components/Navigation/Loaders\"; let restClient = new RESTClient(); /** Component to generate the new record page and its buttons to redirect to new collection, standard, policy and database * */ export default { name: \"NewRecordPage\", components: {Loaders, BaseFields}, data(){ return { record: {}, newRecord: {}, recordsTypes: [], formValid: false, loaded: false, message: { error: false, value: null }, rules: { isUrl: function(){return isUrl()} }, submitAnyway: false, recordCreated: false, loading: false, } }, computed: { ...mapState('users', [\"user\"]), ...mapState('editor', ['possibleDuplicates']), ...mapGetters('record', ['getSection']) }, async mounted(){ this.$nextTick(async function () { this.loaded = false; this.resetRecord(); await this.getData(); this.loaded = true; this.$store.commit(\"editor/clearPossibleDuplicates\"); this.$store.commit(\"record/setCreatingNewRecord\"); }); }, methods: { ...mapActions(\"editor\", [\"getCountries\", \"getRecordTypes\", \"getTags\", \"getPossibleDuplicates\", \"cleanEditorStore\" ]), ...mapActions(\"record\", [\"resetRecord\"]), async getData(){ await this.getCountries(); await this.getRecordTypes(); await this.getTags(); }, async createRecord(){ this.message = { error: false, value: null }; let record = JSON.parse(JSON.stringify(this.getSection(\"generalInformation\").data)); // The user has not specified to ignore the warning of duplicate records. // So, a check is made to see if the server reports any possibilities if (!this.submitAnyway) { record = await this.checkForDups(record); } if (this.submitAnyway) { if (this.possibleDuplicates.length &gt; 0) { record.dups_suspected = true; } else { record.dups_suspected = false; } } else { if (this.possibleDuplicates.length &gt; 0) { return; } } this.loading = true; record.record_type_id = record.type.id; record.metadata.status = status; record.country_ids = record.countries.map(obj =&gt; obj.id); record.metadata.status = record.status; delete record.status; delete record.countries; delete record.type; let new_record = await restClient.createRecord(record, this.user().credentials.token); if (new_record.error) { this.message = { error: true, value: new_record.error } } else { this.recordCreated = true; this.newRecord = new_record; } }, redirectToEdit(record) { this.recordCreated = false; this.$router.push({ path: record.data.id + \"/edit\" }); }, async checkForDups(record) { const _module = this; // run the dup check query, using stored_name, stored_abbreviation or stored_homepage; any that // are over three characters in length. let fieldsToQuery = []; // These are only queried if they are at least 6 characters... [record.metadata.name, record.metadata.abbreviation].forEach(function(val) { /* istanbul ignore else */ if (val === null) { return; } if (val.trim().length &gt;= 3) { fieldsToQuery.push(val); } }); // ...whereas any length URL will do if it is valid. let urlCheck = _module.rules.isUrl(); /* istanbul ignore next */ if (urlCheck(record.metadata.homepage)) { fieldsToQuery.push(record.metadata.homepage) } /* istanbul ignore if */ if (fieldsToQuery.length === 0) { return; } // Now send the query. await _module.getPossibleDuplicates({fields: fieldsToQuery}); if (_module.possibleDuplicates.length &gt; 0) { record.dups_suspected = true; } return record; }, setSubmitAnyway() { this.submitAnyway = true; }, tryAgain() { this.submitAnyway = false; this.$store.commit(\"editor/clearPossibleDuplicates\"); } } } &lt;/script&gt; &lt;style scoped&gt; .v-autocomplete__content .v-subheader { font-size: 2rem; text-transform: capitalize; } #autocompleteSelect .v-list-item { min-height: 0 !important; } &lt;/style&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Organisations.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Organisations.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Organisations.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Organisations.vue &lt;template&gt; &lt;div class=\"d-flex width-90\"&gt; &lt;TooltipComponent :tool-tip-text=\"toolTipText\" /&gt; &lt;AutoCompleteComponent v-model=\"model\" :item-value=\"itemValue\" :item-list=\"getSearchOrganisations\" :loading=\"getLoadingStatus\" @input=\"selectedValue\" @fetchData=\"getResults\" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapActions, mapGetters } from \"vuex\"; import organisationSearch from \"@/store\"; import AutoCompleteComponent from \"./AutoCompleteComponent.vue\"; import TooltipComponent from \"./TooltipComponent.vue\"; export default { name: \"Organisations\", components: { TooltipComponent, AutoCompleteComponent }, props: { value: { type: Array, default: () =&gt; [], }, }, data: () =&gt; { return { itemSelected: [], itemValue: [], toolTipText: \"Organisations related to this record. Multiple selections will be joined with OR. Start typing to see Organisations.\", }; }, computed: { ...mapGetters(\"organisationSearch\", [\"getSearchOrganisations\", \"getLoadingStatus\"]), ...mapGetters(\"advancedSearch\", [\"getEditDialogStatus\"]), model: { get() { return this.itemSelected; }, set(value) { this.$emit(\"input\", value); }, }, }, watch: { itemSelected(newValue) { this.itemValue = newValue; }, /** * Item list for the autocomplete should not be empty * It is assigned with selected values when edit field is opened */ getEditDialogStatus: { handler(open) { if (open) { if (this.value &amp;&amp; this.value.length) { organisationSearch.commit( \"organisationSearch/setSearchOrganisations\", this.value ); } } }, immediate: true, }, }, mounted() { //Pre-fill selected values on edit advanced search is clicked and open this.itemValue = this.value; }, methods: { ...mapActions(\"organisationSearch\", [\"fetchSearchOrganisations\"]), selectedValue(item) { this.itemSelected = item; }, getResults(queryParams) { if (queryParams) this.fetchSearchOrganisations(queryParams); }, }, }; &lt;/script&gt; × Search results Close "},"components_Records_Search_Header_Pagination.vue.html":{"id":"components_Records_Search_Header_Pagination.vue.html","title":"Source: components/Records/Search/Header/Pagination.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Header/Pagination.vue &lt;template&gt; &lt;v-pagination v-model=\"page\" :length=\"totalPages\" :total-visible=\"($vuetify.breakpoint.mdAndUp) ? 7 : 3\" /&gt; &lt;/template&gt; &lt;script&gt; import {throttle} from 'lodash'; /** Component to handle the advanced search filters for the searchFairsharingRecords query. * @vue-prop {Number} [totalPages = 0] - the total number of pages to display * @vue-data {Number} [currentQuery = null] - the current page number */ export default { name: \"Pagination\", props: { totalPages: { type: Number, default: 0 }, currentPage: { type: Number, default: 1 } }, data() { return { currentPageLocal: null, allowPaginate: true, disable: false, page: 1 } }, watch: { '$route.name': function () { this.currentPageLocal = 1; }, '$route.query': { handler: function (newVal) { let _module = this; if (!Object.prototype.hasOwnProperty.call(newVal, \"page\")) { _module.currentPageLocal = 1; _module.page = _module.currentPageLocal; } else { _module.currentPageLocal = Number(newVal.page); _module.page = _module.currentPageLocal; } }, immediate: true }, 'page': function (newPage) { this.paginate(newPage); } }, created() { let _module = this; if (!Object.prototype.hasOwnProperty.call(_module.$route.query, \"page\")) { _module.currentPageLocal = 1; _module.page = _module.currentPageLocal; } else { _module.currentPageLocal = Number(_module.$route.query.page); _module.page = _module.currentPageLocal; } }, methods: { /** * Set the current query page parameter value to the given input for vueJs router * @param {Number} pageNumber - the page to go to */ paginate: async function (pageNumber) { if (this.allowPaginate) { if (pageNumber !== this.currentPageLocal &amp;&amp; this.allowPaginate) { let _module = this; let currentQuery = {}; _module.currentPageLocal = pageNumber; Object.keys(_module.$route.query).forEach(function (param) { currentQuery[param] = _module.$route.query[param] }); currentQuery.page = pageNumber; this.disableThrottle(this.disable); await _module.$router.push({ name: _module.$route.name, query: currentQuery }); } } }, /** * Postpone the pagination buttons to be clickable */ PaginatePermission: throttle(function () { this.allowPaginate = true }, 1200), /** * Set the environment ready for testing or development * @param {Boolean} disable - should disable or not the throttle for the next call */ disableThrottle: function (disable) { if (!disable) { this.allowPaginate = false; this.PaginatePermission(); } else { this.allowPaginate = true; } } }, } &lt;/script&gt; &lt;style scoped&gt; button { outline: none; } #advancedSearch { top: 20px; } &lt;/style&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderView.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderView.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderView.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderView.vue &lt;template&gt; &lt;query-builder v-model=\"query\" :config=\"config\" &gt; &lt;!-- To use the custom text instead of default text 'Operator' --&gt; &lt;template #groupOperator=\"props\"&gt; &lt;div class=\"query-builder-group__group-selection\"&gt; &lt;div class=\"tooltip\"&gt; &lt;v-icon small class=\"mr-1 white--text tooltipIcon\" &gt; fa-question-circle &lt;/v-icon&gt; &lt;span class=\"tooltiptext\" /&gt; &lt;/div&gt; &lt;span class=\"query-builder-group__group-operator\"&gt; Select an Operator to apply across all groups &lt;/span&gt; &lt;select class=\"operatorSelect\" :value=\"props.currentOperator\" @input=\"props.updateCurrentOperator($event.target.value)\" &gt; &lt;option disabled value=\"\" &gt; Select an operator &lt;/option&gt; &lt;option v-for=\"operator in props.operators\" :key=\"operator.identifier\" :value=\"operator.identifier\" v-text=\"operator.name\" /&gt; &lt;/select&gt; &lt;/div&gt; &lt;/template&gt; &lt;template #groupControl=\"props\"&gt; &lt;GroupCtrlSlot :group-ctrl=\"props\" /&gt; &lt;/template&gt; &lt;/query-builder&gt; &lt;/template&gt; &lt;script&gt; import QueryBuilder from \"query-builder-vue\"; import { mapGetters } from \"vuex\"; import advancedSearch from \"@/store\"; import { uniqueValues } from \"@/utils/advancedSearchUtils\"; import { AssociatedTools, CertificationsAndCommunityBadges, CitationToRelatedPublications, Countries, DataAccessCondition, DataAccessForPrePublicationReview, DatabaseRecordType, DataContactInformation, DataCuration, DataDepositionCondition, DataPreservationPolicy, DataProcessesAndConditions, DataVersioning, Domain, GroupCtrlSlot, Licences, Organisations, PolicyRecordType, RecordStatus, Registry, ResourceSustainability, StandardRecordType, Subject, Taxonomies, UserDefinedTag } from \"./QueryBuilderComponents\"; export default { name: \"QueryBuilderView\", components: { QueryBuilder, GroupCtrlSlot }, props: { isDialog: { type: Boolean, default: false, }, }, data: () =&gt; { return { query: { operatorIdentifier: \"_and\", children: [], }, }; }, computed: { ...mapGetters(\"advancedSearch\", [ \"getEditDialogStatus\", \"getEditAdvancedSearch\", ]), config() { return { operators: [ { name: \"AND\", identifier: \"_and\", }, { name: \"OR\", identifier: \"_or\", }, ], rules: [ { identifier: \"registry\", name: \"Registry\", component: Registry, initialValue: () =&gt; [], }, { identifier: \"standardtype\", name: \"Standard Record Type\", component: StandardRecordType, initialValue: () =&gt; [], }, { identifier: \"policytype\", name: \"Policy Record Type\", component: PolicyRecordType, initialValue: () =&gt; [], }, { identifier: \"subjects\", name: \"Subject\", component: Subject, initialValue: () =&gt; [], }, { identifier: \"domains\", name: \"Domain\", component: Domain, initialValue: () =&gt; [], }, { identifier: \"userDefinedTags\", name: \"User Defined Tag\", component: UserDefinedTag, initialValue: () =&gt; [], }, { identifier: \"status\", name: \"Record Status\", component: RecordStatus, initialValue: () =&gt; [], }, { identifier: \"taxonomies\", name: \"Taxonomies\", component: Taxonomies, initialValue: () =&gt; [], }, { identifier: \"licences\", name: \"Licences\", component: Licences, initialValue: () =&gt; [], }, { identifier: \"countries\", name: \"Countries\", component: Countries, initialValue: () =&gt; [], }, { identifier: \"organisations\", name: \"Organisations\", component: Organisations, initialValue: () =&gt; [], }, { identifier: \"databasetype\", name: \"Database Record Type\", component: DatabaseRecordType, initialValue: () =&gt; [], }, { identifier: \"dataCuration\", name: \"Data Curation\", component: DataCuration, initialValue: () =&gt; [], }, { identifier: \"dataDepositionCondition\", name: \"Data Deposition Condition\", component: DataDepositionCondition, initialValue: () =&gt; [], }, { identifier: \"dataAccessCondition\", name: \"Data Access Condition\", component: DataAccessCondition, initialValue: () =&gt; [], }, { identifier: \"citationToRelatedPublications\", name: \"Citation To Related Publications\", component: CitationToRelatedPublications, initialValue: () =&gt; [], }, { identifier: \"dataAccessForPrePublicationReview\", name: \"Data Access For Pre Publication Review\", component: DataAccessForPrePublicationReview, initialValue: () =&gt; [], }, { identifier: \"dataContactInformation\", name: \"Data Contact Information\", component: DataContactInformation, initialValue: () =&gt; [], }, { identifier: \"dataVersioning\", name: \"Data Versioning\", component: DataVersioning, initialValue: () =&gt; [], }, { identifier: \"associatedTools\", name: \"Associated Tools\", component: AssociatedTools, initialValue: \"\", }, { identifier: \"certificationsAndCommunityBadges\", name: \"Certifications And Community Badges\", component: CertificationsAndCommunityBadges, initialValue: \"\", }, { identifier: \"dataProcessesAndConditions\", name: \"Data Processes And Conditions\", component: DataProcessesAndConditions, initialValue: \"\", }, { identifier: \"dataPreservationPolicy\", name: \"Data Preservation Policy\", component: DataPreservationPolicy, initialValue: \"\", }, { identifier: \"resourceSustainability\", name: \"Resource Sustainability\", component: ResourceSustainability, initialValue: \"\", }, ], colors: [\"#599C0F\", \"#CB9221\", \"#A04545\"], }; }, /** * Removes duplicate entries and return unique values * @returns {Object} */ uniqueGetEditAdvancedSearch() { let searchValues = { operatorIdentifier: this.getEditAdvancedSearch[\"operatorIdentifier\"], children: [], }; if ( this.getEditAdvancedSearch[\"children\"] &amp;&amp; this.getEditAdvancedSearch[\"children\"].length ) { this.getEditAdvancedSearch[\"children\"].forEach((item) =&gt; { if (item[\"children\"] &amp;&amp; item[\"children\"].length) { let fieldsObj = { operatorIdentifier: item[\"operatorIdentifier\"], children: uniqueValues(item[\"children\"]), }; searchValues[\"children\"].push(fieldsObj); } }); } return searchValues; }, }, watch: { query(newValue) { advancedSearch.commit(\"advancedSearch/setAdvancedSearch\", newValue); //Updating edit advanced search only if newValue has some data if (newValue[\"children\"] &amp;&amp; newValue[\"children\"].length) { newValue[\"children\"].forEach((item) =&gt; { if (item[\"children\"] &amp;&amp; item[\"children\"].length) { advancedSearch.commit( \"advancedSearch/setEditAdvancedSearch\", newValue ); } }); } }, /** * Reset the dialog box when closed and opened again * @param open - Boolean */ isDialog: { handler(open) { //On click of Reset/Open Advanced search button if (open &amp;&amp; !this.getEditDialogStatus) { this.query = { operatorIdentifier: \"_and\", children: [ { operatorIdentifier: \"_and\", children: [], }, ], }; } }, immediate: true, }, /** * Populate the dialog box with advanced search selection * @param open - Boolean */ getEditDialogStatus: { handler(open) { if (open) { this.query = this.uniqueGetEditAdvancedSearch; } }, immediate: true, }, }, }; &lt;/script&gt; &lt;style lang=\"scss\" scoped&gt; @import \"~vuetify/src/styles/settings/_variables.scss\"; @import \"@/styles/queryBuilderView\"; &lt;/style&gt; × Search results Close "},"views_Records_Record.vue.html":{"id":"views_Records_Record.vue.html","title":"Source: views/Records/Record.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: views/Records/Record.vue &lt;template xmlns:v-slot=\"http://www.w3.org/1999/XSL/Transform\"&gt; &lt;main&gt; &lt;v-container v-if=\"queryTriggered\" fluid &gt; &lt;!-- error --&gt; &lt;div v-if=\"error\"&gt; &lt;NotFound /&gt; &lt;/div&gt; &lt;!-- Action Menu &amp; Alert --&gt; &lt;v-row v-if=\"!target &amp;&amp; queryTriggered\" class=\"mx-1\" &gt; &lt;v-col cols=\"12\" &gt; &lt;!-- alerts --&gt; &lt;record-alert v-for=\"(alert,key,index) in alerts\" :key=\"key+'_'+alert.message+'_'+index\" :type=\"alert.type\" :message=\"alert.message\" /&gt; &lt;!-- snackbars --&gt; &lt;record-snackbar v-for=\"(snackbar,index) in snackbars\" :key=\"snackbar.message+'_'+index\" :message=\"snackbar.message\" :type=\"snackbar.type\" :model=\"convertStringToLocalVar(snackbar.model)\" /&gt; &lt;!-- Menu component --&gt; &lt;record-menu v-if=\"currentRecord.fairsharingRecord['isHidden']!==undefined &amp;&amp; !error &amp;&amp; !recordHidden\" :buttons=\"buttons\" :read-only-mode=\"readOnlyMode\" /&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- CuratorsNotes --&gt; &lt;CuratorNotes id=\"curatorNotes\" class=\"ma-4 mb-7\" :back-color=\"getRecordCardBackground\" /&gt; &lt;Tombstone v-if=\"currentRecord['fairsharingRecord'] &amp;&amp; currentRecord['fairsharingRecord'].metadata.tombstone\" id=\"tombStone\" :record=\"currentRecord['fairsharingRecord']\" /&gt; &lt;Hidden v-if=\"recordHidden\" id=\"hidden\" :record-name=\"currentRecord['fairsharingRecord'].metadata.name\" :is-logged-in=\"user().isLoggedIn\" /&gt; &lt;!-- handle situations where the record is hidden --&gt; &lt;!-- Content --&gt; &lt;div v-if=\"currentRecord['fairsharingRecord'] &amp;&amp; !error &amp;&amp; !recordHidden &amp;&amp; !currentRecord['fairsharingRecord'].metadata.tombstone\"&gt; &lt;!-- Top Block --&gt; &lt;GeneralInfo id=\"generalInfo\" :class=\"['ma-4',{'mb-10':currentRecord.fairsharingRecord.registry==='Collection'}]\" :can-claim=\"canClaim\" :back-color=\"getRecordCardBackground\" @requestOwnership=\"requestOwnership\" /&gt; &lt;!-- Dynamic Block --&gt; &lt;v-row no-gutters&gt; &lt;v-col :cols=\"$vuetify.breakpoint.mdAndDown?'12':'6'\"&gt; &lt;!--Left Block--&gt; &lt;div v-if=\"currentRecord.fairsharingRecord.registry!=='Collection'\"&gt; &lt;component :is=\"block\" v-for=\"(block,index) in currentDynamicBlock.leftBlock\" :id=\"block.toLowerCase()\" :key=\"block\" :back-color=\"getRecordCardBackground\" :class=\"['ma-4',index===currentDynamicBlock.rightBlock.length-1?'mb-4':'mb-8']\" /&gt; &lt;/div&gt; &lt;/v-col&gt; &lt;!--Right Block--&gt; &lt;v-col :cols=\"$vuetify.breakpoint.mdAndDown?'12':'6'\"&gt; &lt;div v-if=\"currentRecord.fairsharingRecord.registry!=='Collection'\"&gt; &lt;component :is=\"block\" v-for=\"(block,index) in currentDynamicBlock.rightBlock\" :id=\"block.toLowerCase()\" :key=\"block\" :back-color=\"getRecordCardBackground\" :class=\"['ma-4',index===currentDynamicBlock.rightBlock.length-1?'mb-4':'mb-8']\" /&gt; &lt;/div&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;!-- Bottom Block --&gt; &lt;Publications id=\"publications\" :class=\"['ma-4 mb-8', {'mb-10 mt-0':currentRecord.fairsharingRecord.registry==='Collection'}]\" :back-color=\"getRecordCardBackground\" /&gt; &lt;!-- Additional Information --&gt; &lt;AdditionalInfo v-if=\"currentRecord.fairsharingRecord.registry!=='Collection'\" id=\"additionalInfo\" class=\"mb-8 ma-4\" :back-color=\"getRecordCardBackground\" /&gt; &lt;!-- Search Collection --&gt; &lt;SearchCollection v-if=\"currentRecord.fairsharingRecord.registry==='Collection'\" id=\"searchCollection\" class=\"mb-10 ma-4\" /&gt; &lt;/div&gt; &lt;/v-container&gt; &lt;!-- This html is from a safe source --&gt; &lt;!-- eslint-disable vue/no-v-html --&gt; &lt;script type=\"application/ld+json\" v-html=\"JSONLD\" /&gt; &lt;!-- eslint-enable vue/no-v-html --&gt; &lt;v-dialog v-model=\"history.show\" fullscreen class=\"pa-0\" persistent no-click-animation &gt; &lt;v-card&gt; &lt;v-card-title class=\"blue white--text pb-4\" style=\"border-radius: 0 !important;\" &gt; {{ getField(\"name\") }} history logs &lt;v-spacer /&gt; &lt;v-btn x-small fab @click=\"closeHistory()\" &gt; &lt;v-icon&gt; fa-times &lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/v-card-title&gt; &lt;v-card-text class=\"pt-2\"&gt; &lt;RecordHistory v-if=\"!history.loading\" id=\"recordHistory\" :history=\"currentRecordHistory.history\" :legacy-logs=\"currentRecordHistory.legacyLogs\" /&gt; &lt;Loaders v-else /&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;v-dialog v-model=\"dialogs.deleteRecord\" max-width=\"650px\" &gt; &lt;v-card&gt; &lt;v-card-title class=\"headline\" &gt; Are you sure you want to &lt;font style=\"color:red; padding-left: 5px; padding-right: 5px;\" &gt; DELETE &lt;/font&gt; (without DOI) or tombstone (with DOI) this record? &lt;ul style=\"list-style-type:none;\"&gt; &lt;li&gt; {{ dialogs.recordName }} &lt;/li&gt; &lt;/ul&gt; &lt;/v-card-title&gt; &lt;v-card-actions&gt; &lt;v-spacer /&gt; &lt;v-btn :disabled=\"dialogs.disableButton === true\" color=\"blue darken-1\" text @click=\"closeDeleteMenu()\" &gt; Cancel &lt;/v-btn&gt; &lt;v-btn :disabled=\"dialogs.disableDelButton === true || dialogs.disableButton === true\" color=\"blue darken-1\" text @click=\"confirmDelete()\" &gt; DELETE &lt;/v-btn&gt; &lt;v-spacer /&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;v-dialog v-model=\"dialogs.claimRecord\" max-width=\"700px\" &gt; &lt;v-card&gt; &lt;v-card-title class=\"headline\" &gt; &lt;p class=\"claimtext\"&gt; &lt;b&gt;Please confirm that you would like to request ownership of this record.&lt;/b&gt; &lt;/p&gt; &lt;p class=\"claimtext\"&gt; We encourage resource developers to claim ownership of their FAIRsharing record; doing so allows them to make updates and provides them with a visible means of attribution for their efforts. However, please note that for this request to be approved, you must be associated with the institutions(s) that develop this resource. &lt;/p&gt; &lt;p class=\"claimtext\"&gt; Please also see our &lt;a href=\"https://fairsharing.gitbook.io/fairsharing/#claiming-a-record\"&gt; documentation on requesting ownership&lt;/a&gt;. &lt;/p&gt; &lt;/v-card-title&gt; &lt;v-card-actions&gt; &lt;v-spacer /&gt; &lt;v-btn :disabled=\"dialogs.disableButton === true\" color=\"blue darken-1\" text @click=\"closeClaimMenu()\" &gt; Cancel &lt;/v-btn&gt; &lt;v-btn :disabled=\"dialogs.disableDelButton === true || dialogs.disableButton === true\" color=\"blue darken-1\" text @click=\"requestOwnership()\" &gt; OK &lt;/v-btn&gt; &lt;v-spacer /&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;v-dialog v-model=\"dialogs.stopMaintainRecord\" max-width=\"700px\" &gt; &lt;v-card&gt; &lt;v-card-title class=\"headline\" &gt; &lt;p class=\"claimtext\"&gt; &lt;b&gt;Please confirm that you would like to stop maintaining this record:&lt;/b&gt; &lt;/p&gt; &lt;p class=\"claimtext\"&gt; &lt;b&gt;&amp;ldquo;{{ dialogs.recordName }}&amp;rdquo;&lt;/b&gt; &lt;/p&gt; &lt;/v-card-title&gt; &lt;v-card-actions&gt; &lt;v-spacer /&gt; &lt;v-btn :disabled=\"dialogs.disableButton === true\" color=\"blue darken-1\" text @click=\"closeMaintainMenu()\" &gt; Cancel &lt;/v-btn&gt; &lt;v-btn :disabled=\"dialogs.disableDelButton === true || dialogs.disableButton === true\" color=\"blue darken-1\" text @click=\"removeMaintainer()\" &gt; OK &lt;/v-btn&gt; &lt;v-spacer /&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;/main&gt; &lt;/template&gt; &lt;script&gt; import {mapActions, mapGetters, mapMutations, mapState} from 'vuex' import Loaders from \"@/components/Navigation/Loaders\"; import AdditionalInfo from \"@/components/Records/Record/AdditionalInfo\"; import SearchCollection from \"@/components/Records/Record/CollectionRecord/SearchCollection\"; import Collections from \"@/components/Records/Record/Collections\"; import CuratorNotes from \"@/components/Records/Record/CuratorNotes\"; import DataProcessesAndConditions from '@/components/Records/Record/DataProcessesAndConditions'; import GeneralInfo from \"@/components/Records/Record/GeneralInfo\"; import RecordHistory from \"@/components/Records/Record/History/RecordHistory\"; import Organisations from \"@/components/Records/Record/Organisations\"; import Publications from '@/components/Records/Record/Publications'; import RecordAlert from \"@/components/Records/Record/RecordAlert\"; import RecordMenu from \"@/components/Records/Record/RecordMenu\"; import RecordSnackbar from \"@/components/Records/Record/RecordSnackBar\"; import RelatedContent from \"@/components/Records/Record/RelatedContent\"; import Support from '@/components/Records/Record/Support'; import Tools from '@/components/Records/Record/Tools'; import AlertBuilder from \"@/lib/AlertBuilder/AlertBuilder\"; import RestClient from \"@/lib/Client/RESTClient.js\" import Client from '@/lib/GraphClient/GraphClient.js' import getHostname from \"@/utils/generalUtils\"; import stringUtils from '@/utils/stringUtils'; import NotFound from \"@/views/Errors/404\" import Hidden from \"../Errors/Hidden\"; import Tombstone from \"../Errors/Tombstone\"; const client = new RestClient(); export default { name: \"Record\", components: { RecordSnackbar, RecordAlert, RecordMenu, CuratorNotes, AdditionalInfo, Tombstone, Hidden, SearchCollection, Loaders, RecordHistory, RelatedContent, Collections, Organisations, GeneralInfo, Tools, DataProcessesAndConditions, Publications, Support, NotFound }, mixins: [stringUtils, getHostname], props: { target: {type: Number, default: null} }, data: () =&gt; { return { recordID: null, error: null, queryTriggered: false, showScrollToTopButton: false, canEdit: false, canClaim: false, alreadyClaimed: false, noClaimRegistered:false, ownershipApproved: false, ownershipApprovalStatus:null, claimedTriggered: false, reviewSuccess: false, reviewFail: false, stopMaintainSuccess: false, stopMaintainFailure: false, buttons: [], history: { show: false, loading: false }, tombstone: false, alerts:{}, snackbars: [ { model: \"claimedTriggered\", type: \"success\", message: \"Thank you for claiming this record. We will be getting back to you between 48 and 72h.\" }, { model: \"reviewSuccess\", type: \"success\", message: \"Thank you for reviewing this record.\" }, { model: \"reviewFail\", type: \"warning\", message: \"Sorry, it was not possibly to save a review for this record.\" }, { model: \"stopMaintainSuccess\", type: \"success\", message: \"You have been removed as maintainer of this record.\" }, { model: \"stopMaintainFailure\", type: \"warning\", message: \"You could not be removed as maintainer. Please email for assistance.\" } ], dialogs: { recordName: \"\", recordID: \"\", deleteRecord: false, disableDelButton: true, disableButton: false, claimRecord: false, stopMaintainRecord: false }, } }, head: { link: function() { if (this.recordID) { let results = []; let citeAsUrl; let describedByUrl; // Mysteriously not covered even if a doi value is provided in tests. /* istanbul ignore if */ if (this.currentRecord.fairsharingRecord.doi) { citeAsUrl = \"https://doi.org/\" + this.currentRecord.fairsharingRecord.doi; describedByUrl = this.getHostname() + this.currentRecord.fairsharingRecord.doi.split(/\\//)[1]; } else { citeAsUrl = this.getHostname() + this.recordID; describedByUrl = this.getHostname() + this.recordId; } results.push({ rel: 'cite-as', type: \"application/html\", href: citeAsUrl }); results.push( { rel: 'describedby', type: \"application/json\", href: describedByUrl } ) results.push( { rel: 'describedby', type: \"application/ld+json\", href: describedByUrl } ) return results; } } }, computed: { ...mapState('record', [\"currentRecord\", \"currentRecordHistory\"]), ...mapState('users', [\"user\", \"messages\"]), ...mapGetters(\"record\", [\"getField\"]), ...mapState('introspection', [\"readOnlyMode\"]), recordHidden() { let _module = this; if (_module.currentRecord.fairsharingRecord.isHidden) { if (!_module.user().isLoggedIn) { return true; } else { if (!_module.canEdit) { return true; } } } return false; }, getRecordCardBackground() { let finalCardBackColor switch (this.currentRecord.fairsharingRecord.registry) { case 'Standard': finalCardBackColor = this.$vuetify.theme.themes.light.bg_standard_record_card; break; case 'Database': finalCardBackColor = this.$vuetify.theme.themes.light.bg_database_record_card; break; case 'Policy': finalCardBackColor = this.$vuetify.theme.themes.light.bg_policy_record_card; break; case 'Collection': finalCardBackColor = this.$vuetify.theme.themes.light.bg_collection_record_card; break; } return finalCardBackColor }, JSONLD () { return this.$sanitize(JSON.stringify(this.getField(\"schemaOrg\"))); }, currentRoute() { let id = this.$route.params['id']; if (id.includes(\"FAIRsharing.\")) { return \"10.25504/\" + id; } return this.target || this.$route.params['id']; }, userIsLoggedIn(){ return this.user().isLoggedIn; }, getTitle() { return 'FAIRsharing | ' + this.currentRoute; }, maintainsRecord() { let _module = this; if (!_module.userIsLoggedIn){ return false } // Is the current_user's ID in the array of maintainer objects? if (typeof _module.currentRecord['fairsharingRecord']['maintainers'] === 'undefined') { return false; } if (_module.currentRecord['fairsharingRecord']['maintainers'].length === 0) { return false; } return _module.currentRecord['fairsharingRecord']['maintainers'].some(({ id }) =&gt; id === _module.user().id); }, currentDynamicBlock() { if (this.$vuetify.breakpoint.name === 'md') { return { leftBlock: [\"Collections\", \"RelatedContent\", \"Support\"], rightBlock: [\"DataProcessesAndConditions\", \"Tools\", \"Organisations\"] } } else { return { leftBlock: [\"Collections\", \"Support\", \"DataProcessesAndConditions\"], rightBlock: [\"RelatedContent\", \"Tools\", \"Organisations\"] } } }, }, watch: { async currentRoute() { await this.getData(); if (!this.error) { await this.canEditRecord(); await this.checkClaimStatus(); await this.getMenuButtons(); } await this.$nextTick(); await this.$scrollTo(this.$route.hash || 'body') }, async userIsLoggedIn() { await this.canEditRecord(); await this.checkClaimStatus(); await this.getMenuButtons(); await this.checkAlerts(); } }, destroyed() { // minor change in the y axis can fix a serious bug after going back to records.. this.$scrollTo('body',5,{}) }, async mounted() { let _module = this; _module.client = new Client(); await _module.getData(); _module.recordID = this.currentRecord.fairsharingRecord.id; _module.$emit('updateHead'); if (!_module.error) { await _module.canEditRecord(); await _module.checkClaimStatus(); await _module.getMenuButtons() } await _module.$nextTick(); await _module.checkAlerts(); try { await _module.$scrollTo(_module.$route.hash || 'body') // eslint-disable-next-line no-empty } catch (e) { // This serves to prevent warnings when tests are run on Github (trying to scroll with no DOM etc.). #1201 } // update the UI padding and margin after DOM is fully loaded. // At this point it might be possible to directly load the record page if a parameter has been passed... let query = _module.$route.query; if (!(query === undefined || query === null)) { // TODO: This does work but yet again the test refuses to acknowledge this. /* istanbul ignore if */ if (query.history === 'show') { _module.history = { show: true, loading: true }; await _module.getHistory(); _module.history.loading = false; } } }, methods: { closeHistory() { this.history.show = false; this.$router.replace({query: {}}); }, async checkAlerts() { let _module = this; // here order of calling functions matters in presentation first we stack blue alerts(no-auth needed ones) // and then curators alerts(auth-needed orange ones) so blue ones stack, // then orange and then red/green [approval/rejection] ones. let alertBuilder = new AlertBuilder(_module.currentRecord, this.user()) .isAwaitingApproval() .isWatching(this.isWatching()) .isNeedingReview(this.needsReviewing(), this.error) .isNeedingReviewAndBeenReviewed(this.reviewsPresent()) .isAlreadyClaimed(this.alreadyClaimed) .isHidden() .isOwnerShipApproved(this.ownershipApprovalStatus, this.isBannerExpired()); _module.alerts = alertBuilder.getAlerts(); }, ...mapActions('record', ['fetchRecord', 'fetchRecordHistory', 'fetchPreviewRecord']), ...mapActions('users', ['updateWatchedRecords']), ...mapMutations('users', ['changeWatched']), async getMenuButtons() { let _module = this; this.buttons = [] let initial_buttons = [ { name: function() { return \"Edit record\" }, isDisabled: function(){ if (!_module.userIsLoggedIn){ return false } return !_module.canEdit }, method: function(){return _module.goToEdit()} }, { name: function() { return \"Request ownership\" }, isDisabled: function(){ if (!_module.userIsLoggedIn){ return false } return !_module.canClaim; }, method: async function(){ if (!_module.userIsLoggedIn){ _module.$router.push({ path: \"/accounts/login\", query: { goTo: `/${_module.currentRecord['fairsharingRecord'].id}` } }) } else { _module.claimRecordMenu( _module.currentRecord['fairsharingRecord'].name, _module.currentRecord['fairsharingRecord'].id, ); } } }, { name: () =&gt; { if (!_module.userIsLoggedIn){ return \"Watch record\" } else { if (!_module.isWatching()){ return \"Watch record\" } else { return \"Unwatch record\" } } }, isDisabled: function() { return false }, method: function(){ if (!_module.userIsLoggedIn){ _module.$router.push({ path: \"/accounts/login\", query: { goTo: `/${_module.currentRecord['fairsharingRecord'].id}` } }) } else { if (_module.isWatching()) { _module.changeWatchRecord(false); } else { _module.changeWatchRecord(true); } } } }, { name: function() { return \"View Relation Graph\" }, isDisabled: function(){ return false }, method: function(){ _module.$router.push({ path: \"/graph/\" + _module.currentRecord['fairsharingRecord'].id }) } }, { name: function() { return \"View record history\" }, isDisabled: function(){return false}, method: async () =&gt; { this.history = { show: true, loading: true }; await this.getHistory(); this.history.loading = false; } }, { name: function () { return \"Have a suggestion/question ?\" }, isDisabled: function () { return false; }, method: function () { parent.location = \"mailto:contact@fairsharing.org?subject=[FAIRsharing][Feedback] Comments on \" + _module.currentRecord.fairsharingRecord.name; } } ]; if (_module.user().is_curator &amp;&amp; _module.needsReviewing()) { initial_buttons.push( { name: function () { return \"Review this record\" }, isDisabled: function () { // Only to be seen by logged-in curators. // So, this line shouldn't really be encountered... /* istanbul ignore if */ if (!_module.userIsLoggedIn) { return true; } return !_module.user().is_curator; }, method: async function () { await _module.reviewRecord(); } } ) } if (_module.user().is_super_curator) { initial_buttons.push( { name: function () { return \"Delete this record\" }, isDisabled: function () { return !_module.user().is_super_curator; }, method: /* istanbul ignore next */ async function () { _module.deleteRecordMenu( _module.currentRecord['fairsharingRecord'].name, _module.currentRecord['fairsharingRecord'].id, ); } } ) } if (_module.maintainsRecord) { let _module = this; initial_buttons.push( { name: function() { return \"Stop maintaining\"}, isDisabled: function() { return false; }, method: async function () { _module.stopMaintainRecordMenu( _module.currentRecord['fairsharingRecord'].name, _module.currentRecord['fairsharingRecord'].id, ); } }, ) } this.buttons = initial_buttons; }, convertStringToLocalVar(stringVarName){ return this[stringVarName] }, /* useful methods for communicating from child to parent // please keep these as reference updateStates(property, value) { this[property] = value }, callMyMethod(name, value = null) { this[name](value) }, */ async confirmDelete(){ const _module = this; _module.dialogs.disableButton = true; let data = await client.deleteRecord(_module.dialogs.recordID, this.user().credentials.token); if (data.error){ _module.error = \"error deleting record\"; } else{ // Redirect to current record to show it has gone... this.$router.go(); } _module.dialogs.deleteRecord = false; }, claimRecordMenu(recordName, recordID) { const _module = this; _module.dialogs.disableButton = false; _module.dialogs.disableDelButton = true _module.dialogs.recordName = recordName; _module.dialogs.recordID = recordID; _module.dialogs.claimRecord = true; /* istanbul ignore next */ setTimeout(function () { _module.dialogs.disableDelButton = false; }, 5000); }, stopMaintainRecordMenu(recordName, recordID) { const _module = this; _module.dialogs.disableButton = false; _module.dialogs.disableDelButton = true _module.dialogs.recordName = recordName; _module.dialogs.recordID = recordID; _module.dialogs.stopMaintainRecord = true; /* istanbul ignore next */ setTimeout(function () { _module.dialogs.disableDelButton = false; }, 5000); }, deleteRecordMenu(recordName, recordID){ const _module = this; _module.dialogs.disableButton = false; _module.dialogs.disableDelButton = true _module.dialogs.recordName = recordName; _module.dialogs.recordID = recordID; _module.dialogs.deleteRecord = true; /* istanbul ignore next */ setTimeout(function () { _module.dialogs.disableDelButton = false; }, 5000); }, closeDeleteMenu () { this.dialogs.disableButton = true; this.dialogs.deleteRecord = false; }, closeClaimMenu () { this.dialogs.disableButton = true; this.dialogs.claimRecord = false; }, closeMaintainMenu () { this.dialogs.disableButton = true; this.dialogs.stopMaintainRecord = false; }, goToEdit(){ let _module = this; const recordID = '/' + _module.currentRecord['fairsharingRecord'].id; if (_module.userIsLoggedIn) { this.$router.push({ path: recordID + '/edit', params: { fromRecordPage: true } }) } else { this.$router.push({ path: \"/accounts/login\", query: { goTo: `/${_module.currentRecord['fairsharingRecord'].id}` } }) } }, /** * Method to create a maintenance_request; sets canClaim and (on fail) error. * @returns {undefined} * */ async requestOwnership() { let _module = this; const recordID = _module.currentRecord['fairsharingRecord'].id; const claim = await client.claimRecord(recordID, _module.user().credentials.token); /* istanbul ignore else */ if (claim.error) { _module.error = \"Sorry, your request to claim this record failed. Please contact us.\"; _module.canClaim = false; } else { // show modal here _module.canClaim = false; _module.claimedTriggered = true; _module.alreadyClaimed = true; } await _module.checkAlerts(); _module.dialogs.claimRecord = false; }, /** * Method to remove current_user from the list of maintainers. * @returns {undefined} * */ async removeMaintainer() { let _module = this; const recordID = _module.currentRecord['fairsharingRecord'].id; // TODO: Write new function to remove claim. const unclaim = await client.removeMaintainer(recordID, _module.user().credentials.token); if (unclaim.error) { _module.error = \"Sorry, your request to be removed as a maintainer of this record failed. Please contact us.\"; _module.stopMaintainFailure = true; } else { // Display a toast here. _module.stopMaintainSuccess = true; // remove maintainer from local data let newMaintainers = _module.currentRecord['fairsharingRecord']['maintainers'].filter(maintainer =&gt; { return maintainer.id !== _module.user().id } ) _module.currentRecord['fairsharingRecord']['maintainers'] = newMaintainers; } _module.dialogs.stopMaintainRecord = false; }, /** * Method to set the canClaim status for this record. * @returns {undefined} * */ async checkClaimStatus() { let _module = this; if (_module.user().isLoggedIn) { const recordID = _module.currentRecord['fairsharingRecord'].id; try { const claim = await client.canClaim(recordID, _module.user().credentials.token); if (claim.error) { if (claim.error.response.data.existing &amp;&amp; claim.error.response.data.status === 'pending') { let maintainer = _module.getField(\"maintainers\").filter(maintainer =&gt; maintainer.username === _module.user().credentials.username); if (maintainer.length === 0) { //alreadyClaimed: this is the situation where the current record has been already claimed by user to be maintained. _module.alreadyClaimed = true; } } _module.ownershipApprovalStatus = claim.error.response.data.status; // assign expiring date for approval/rejection banner--- if (_module.ownershipApprovalStatus === 'approved' || _module.ownershipApprovalStatus === 'rejected') { _module.setBannerExpiry(); } _module.canClaim = false; } else { // show modal here _module.canClaim = !claim.existing; } if(!claim.error) { //noClaimRegistered: this is the situation where the current record is not requested to be maintained by user _module.noClaimRegistered = true; } } catch (e) { /* istanbul ignore next */ _module.canClaim = false; } } }, /** * Method to set the current record in the store * @returns {Promise} - the current record * */ async getData() { let _module = this; this.queryTriggered = false; this.error = null; this.alreadyClaimed = false; this.claimedTriggered = false; this.tombstone = false; try { if (this.target) await _module.fetchPreviewRecord(this.target); else await _module.fetchRecord({ id: this.currentRoute, token: (_module.user().credentials) ? _module.user().credentials.token : null }); // UNCOMMENT ME TO TEST TOMBSTONE PAGE // Or, set tombstone to true on a record, if using a local server. // this.currentRecord['fairsharingRecord'].metadata.tombstone = true; } catch (e) { this.error = e.message; } this.queryTriggered = true; }, /** * Method to dispatch the current record history into the store * @returns {Promise} - the current record history * */ async getHistory() { await this.$store.dispatch(\"record/fetchRecordHistory\", { id: this.currentRoute, token: this.user().credentials.token } ); }, /** * Test if the current user can edit the current record * @returns {Promise&lt;void&gt;} */ async canEditRecord(){ const _module = this; _module.canEdit = false; if (_module.user().isLoggedIn) { const recordID = _module.currentRecord['fairsharingRecord'].id; if (!recordID) { return false; } const canEdit = await client.canEdit(recordID, _module.user().credentials.token); _module.canEdit = !canEdit.error; } else { return false; } }, /** * Method to add or remove the current record to the list of watched records * @param watch * @returns {Promise&lt;void&gt;} */ async changeWatchRecord(watch) { const _module = this; this.loading = true; let operation; let records = _module.user().watchedRecords.slice(); if (watch) { operation = 'add'; records.push(_module.currentRecord['fairsharingRecord'].id); } else { operation = 'remove'; records = records.filter(function(value){ return value !== _module.currentRecord['fairsharingRecord'].id; }); } let response = await this.updateWatchedRecords( { recordID: _module.currentRecord['fairsharingRecord'].id, operation: operation } ); // Refresh user data to reload followed record status. /* istanbul ignore else */ if (response.message.indexOf('success') !== -1){ _module.changeWatched(records); } this.loading = false; await _module.checkAlerts(); }, /** * Test if the user is watching the current record * @returns {*|boolean} */ isWatching() { if (this.user().watchedRecords === undefined) { return false; } return this.currentRecord['fairsharingRecord'].id &amp;&amp; this.user().watchedRecords.includes(this.currentRecord['fairsharingRecord'].id) || false; }, setBannerExpiry() { const _module = this; let bannerExpiryDate = {...JSON.parse(localStorage.getItem(\"bannerExpiryDate\"))}; if (!bannerExpiryDate[_module.getField(\"id\")]) { bannerExpiryDate = { ...JSON.parse(localStorage.getItem(\"bannerExpiryDate\")), [_module.getField(\"id\")]: new Date() } localStorage.setItem(\"bannerExpiryDate\", JSON.stringify(bannerExpiryDate)); } }, isBannerExpired() { let now = new Date(); let id = this.getField(\"id\"); const DAY = 2; const temp = JSON.parse(localStorage.getItem(\"bannerExpiryDate\")); if (temp) { const expiryDate = new Date(temp[id]); // very important line: instead of adding if its been expired I directly assigned to variable so test can be passed much easier. return !(expiryDate.getTime() + (DAY * 24 * 60 * 60 * 1000) &lt; now.getTime()); } return true; }, needsReviewing() { const _module = this; let need = true; let d = new Date(); let pastYear = d.getFullYear() - 1; d.setFullYear(pastYear); if (!_module.reviewsPresent()){ return !_module.reviewsPresent(); } else { // Creating a date from the string returned by the API. // See: https://stackoverflow.com/a/11658343/1195207 _module.currentRecord['fairsharingRecord']['reviews'].forEach(function (review) { let rawDate = review['createdAt'].split('T')[0].split('-'); if (new Date(rawDate[0], rawDate[1]-1, rawDate[2]) &gt; d) { need = false; } }) } return need; }, reviewsPresent() { const _module = this; if (!_module.currentRecord['fairsharingRecord']['reviews']) { return false; } if(_module.currentRecord['fairsharingRecord']['reviews'].length === 0) { return false; } return true; }, async reviewRecord() { // Post a review to the server. const _module = this; const recordID = _module.currentRecord['fairsharingRecord'].id; const reviewRecord = await client.reviewRecord(recordID, _module.user().credentials.token); if (reviewRecord.error) { _module.reviewFail = true; } else { _module.reviewSuccess = true; await this.getData(); } // Re-display the menu. await this.getMenuButtons(); await this.checkAlerts(); } }, metaInfo() { try { let id; if (this.currentRecord.fairsharingRecord.doi) { id = this.currentRecord.fairsharingRecord.doi.split('/')[1]; } else { id = this.currentRecord.fairsharingRecord.id; } if (this.currentRecord.fairsharingRecord.abbreviation) { return { title: 'FAIRsharing | ' + this.currentRecord.fairsharingRecord.abbreviation, meta: [ { name: 'description', content: `FAIRsharing record for ${this.currentRecord.fairsharingRecord.name} (${this.currentRecord.fairsharingRecord.abbreviation})` }, { name: 'link', content: `${process.env.VUE_APP_HOSTNAME}${id}`, rel: 'canonical' } ] } } else { return { title: 'FAIRsharing | ' + this.currentRecord.fairsharingRecord.name, meta: [ { name: 'description', content: `FAIRsharing record for ${this.currentRecord.fairsharingRecord.name}` }, { name: 'link', content: `${process.env.VUE_APP_HOSTNAME}${id}`, rel: 'canonical' } ] } } } catch (e) { //error } } } &lt;/script&gt; &lt;style scoped&gt; .fade-enter-active, .fade-leave-active { transition: opacity 1s; transition-delay: 1s; } .fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ { opacity: 0; } ul,li { padding: 0; } .claimtext { word-break: keep-all; font-size: 70%; } &lt;/style&gt; × Search results Close "},"views_Records_Records.vue.html":{"id":"views_Records_Records.vue.html","title":"Source: views/Records/Records.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: views/Records/Records.vue &lt;template&gt; &lt;v-main&gt; &lt;transition name=\"fade\"&gt; &lt;jump-to-top v-if=\"scrollStatus\" /&gt; &lt;/transition&gt; &lt;v-container fluid class=\"pa-0\" &gt; &lt;!-- Content --&gt; &lt;v-row no-gutters&gt; &lt;v-col v-if=\"$vuetify.breakpoint.lgAndUp\" cols=\"12\" lg=\"4\" md=\"4\" xl=\"3\" class=\"d-flex mt-2 ml-2\" &gt; &lt;SearchInput :class=\"[ 'search-input-mb', { 'left-panel-fixed-lg': stickToTop &amp;&amp; $vuetify.breakpoint.xlOnly, 'left-panel-default-lg': !stickToTop &amp;&amp; $vuetify.breakpoint.xlOnly, 'left-panel-default': !stickToTop &amp;&amp; !$vuetify.breakpoint.xlOnly, 'left-panel-fixed': stickToTop &amp;&amp; !$vuetify.breakpoint.xlOnly, }, ]\" /&gt; &lt;/v-col&gt; &lt;v-col v-else cols=\"12\" class=\"ml-3 mt-2\" &gt; &lt;v-btn class=\"info\" @click=\"showFiltersSM = true\" &gt; &lt;span class=\"mr-2\"&gt;Show filters&lt;/span&gt; &lt;v-icon small&gt; fa-filter &lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/v-col&gt; &lt;v-col class=\"mt-2\"&gt; &lt;SearchOutput class=\"pb-5 mr-0 mr-md-2 px-3\" /&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/v-container&gt; &lt;v-fade-transition&gt; &lt;v-dialog v-model=\"showFiltersSM\" fullscreen hide-overlay scrollable &gt; &lt;v-card&gt; &lt;v-card-title class=\"primary white--text pb-5\"&gt; Add a filter &lt;v-spacer /&gt; &lt;v-btn fab x-small @click=\"showFiltersSM = false\" &gt; &lt;v-icon&gt;fa-times&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/v-card-title&gt; &lt;SearchInput class=\"pa-5\" /&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;/v-fade-transition&gt; &lt;v-fade-transition&gt; &lt;v-overlay v-if=\"isLoading\" :absolute=\"false\" opacity=\"0.8\" &gt; &lt;Loaders /&gt; &lt;/v-overlay&gt; &lt;/v-fade-transition&gt; &lt;/v-main&gt; &lt;/template&gt; &lt;script&gt; import { mapActions, mapMutations, mapState } from \"vuex\"; import JumpToTop from \"@/components/Navigation/jumpToTop\"; import Loaders from \"@/components/Navigation/Loaders\"; import SearchInput from \"@/components/Records/Search/Input/SearchInput\"; import SearchOutput from \"@/components/Records/Search/Output/SearchOutput\"; import recordsLabels from \"@/data/recordsTypes.json\"; import filterChipsUtils from \"@/utils/filterChipsUtils\"; import onScrollUtil from \"@/utils/onScrollUtil\"; export default { name: \"Records\", components: { Loaders, JumpToTop, SearchOutput, SearchInput }, mixins: [filterChipsUtils, onScrollUtil], data: () =&gt; ({ searchTerm: \"\", offsetTop: 0, bodyOverflowActive: true, hideOverflow: \"overflow-hidden\", showHeader: true, showDrawerLeft: false, labels: recordsLabels, recordsSubTitles: recordsLabels[\"recordSubTitles\"], recordTypes: recordsLabels[\"recordTypes\"], isLoading: false, showFiltersSM: false, }), computed: { ...mapState(\"uiController\", [\"scrollStatus\", \"stickToTop\"]), ...mapState(\"records\", [\"records\"]), ...mapState(\"users\", [\"user\"]), getTitle: function () { const flipRecordTypes = Object.entries(this.recordTypes).reduce( (obj, [key, value]) =&gt; ({ ...obj, [value]: key }), {} ); let title = \"Search\"; /* istanbul ignore else */ if ( Object.prototype.hasOwnProperty.call( this.$route.query, \"fairsharingRegistry\" ) ) { if ( Object.prototype.hasOwnProperty.call( flipRecordTypes, this.$route.query.fairsharingRegistry ) ) { title = flipRecordTypes[this.$route.query.fairsharingRegistry]; } } return title; }, currentPath: function () { let title = this.$route.path.replace(\"/\", \"\"); const client = this; let queryParams = {}; Object.keys(this.$route.query).forEach(function (prop) { let queryVal = client.$route.query[prop]; if (queryVal) { queryParams[prop] = decodeURI(queryVal); } }); if (this.recordTypes[title.charAt(0).toUpperCase() + title.slice(1)]) { title = this.recordTypes[title.charAt(0).toUpperCase() + title.slice(1)]; } else title = title.charAt(0).toUpperCase() + title.slice(1); return [title, queryParams]; }, }, watch: { currentPath: async function () { this.$scrollTo(\"body\", 50, {}); try { await this.tryRedirect(); } catch (e) { // eslint-disable-next-line no-empty // Uncaught promise thrown on Github (only). } }, }, mounted: function () { window.addEventListener(\"scroll\", () =&gt; { this.onScroll(this.records); }); this.$nextTick(async function () { try { await this.tryRedirect(); this.$scrollTo(\"body\", 50, {}); } catch (e) { // eslint-disable-next-line no-empty // Uncaught promise thrown on Github (only). } }); }, beforeDestroy() { this.cleanRecordsStore(); }, destroyed() { this.$scrollTo(\"body\", 50, {}); window.removeEventListener(\"scroll\", () =&gt; { this.onScroll(this.records); }); this.setStickToTop(false); this.$store.dispatch(\"uiController/setGeneralUIAttributesAction\", { drawerVisibilityState: false, headerVisibilityState: true, }); }, methods: { ...mapMutations(\"records\", [\"cleanRecordsStore\"]), ...mapActions(\"records\", [\"fetchRecords\"]), ...mapActions(\"uiController\", [\"setScrollStatus\", \"setStickToTop\"]), /** * Try to redirect to search of the page that is hit is /standards /databases * /policies or /collections * */ tryRedirect: async function () { if (Object.keys(this.recordTypes).includes(this.$route.name)) { let fairsharingRegistry = this.recordTypes[this.$route.name]; let query = this.$route.query; /* istanbul ignore else */ if (query &amp;&amp; query !== {}) { query.fairsharingRegistry = fairsharingRegistry; try { await this.$router.push({ name: \"search\", query: query, }); return true; } catch (e) { return false; } } } await this.getData(); }, /** This methods get the data from the Client. * @returns {Promise} */ getData: async function () { this.$scrollTo(\"body\", 50, {}); this.isLoading = true; this.errors = null; const _module = this; // To make sure that any lingering values from having viewed a collection are cleared out. // See SummaryDownload.vue for the code which looks for collection IDs when downloading a // summary of search results. this.$store.commit('records/setCollectionIdsParam', []); try { this.showFiltersSM = false; let token = this.user().credentials.token; await _module.fetchRecords({ params: this.getParameters(), token: token, }); } catch (e) { /* istanbul ignore next */ this.errors = e.message; } this.isLoading = false; }, /** * Get the parameters that are allowed for this query * @returns {Object} parameters - parameters and types allowed for this query */ getParameters: function () { return this.$store.getters[\"introspection/buildQueryParameters\"]( this.currentPath ); }, }, /** * Setting up the metaInfo of the page * @returns {{title: String}} * */ metaInfo() { return { title: \"FAIRsharing | \" + this.getTitle, }; }, }; &lt;/script&gt; &lt;style scoped lang=\"scss\"&gt; .left-panel-fixed { position: sticky; top: 0; width: 32vw; } .left-panel-default { position: relative; width: 32vw; } .left-panel-fixed-lg { position: sticky; top: 0; width: 24vw; } .left-panel-default-lg { position: relative; width: 24vw; } .content-custom-new-height { height: calc(100vh - 40px); scroll-behavior: smooth; padding: 0; } .content-custom { height: 100vh; scroll-behavior: smooth; padding: 0; } #banner { display: flex; justify-content: center; flex-direction: column; padding: 1em; } .search-input-mb { margin-bottom: 105px; } &lt;/style&gt; × Search results Close "},"components_Records_Record_RelatedContent.vue.html":{"id":"components_Records_Record_RelatedContent.vue.html","title":"Source: components/Records/Record/RelatedContent.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Record/RelatedContent.vue &lt;template xmlns:v-slot=\"http://www.w3.org/1999/XSL/Transform\"&gt; &lt;v-card v-if=\"!tabsDataExist\" class=\"pa-4 d-flex flex-column\" outlined :color=\"backColor\" tile elevation=\"3\" &gt; &lt;SectionTitle title=\"Related Content\" /&gt; &lt;div class=\"d-flex flex-column ml-2 min-height-40\"&gt; &lt;div class=\"d-flex flex-wrap mt-5\"&gt; &lt;!-- search autocomplete --&gt; &lt;v-autocomplete v-if=\"!tabsDataExist\" v-model=\"selectedValues\" :disabled=\"tabsData.tabs[Object.keys(tabsData.tabs)[tabsData.selectedTab]].data.length&lt;5\" :items=\"getValues\" solo :attach=\"true\" dense clearable prepend-inner-icon=\"fa-search\" :placeholder=\"`Search through ${cleanString(Object.keys(tabsData.tabs)[tabsData.selectedTab])}`\" item-text=\"name\" item-value=\"name\" :filter=\"nameAbbrFilter\" &gt; &lt;template #item=\"data\"&gt; &lt;span class=\"filterValueName\"&gt; {{ data.item.name }} &lt;/span&gt; &lt;/template&gt; &lt;/v-autocomplete&gt; &lt;/div&gt; &lt;!-- tabs --&gt; &lt;v-tabs v-if=\"!tabsDataExist\" v-model=\"tabsData.selectedTab\" :show-arrows=\"$vuetify.breakpoint.mdAndDown\" background-color=\"transparent\" grow color=\"accent3\" slider-color=\"accent3\" class=\"mb-5\" :hide-slider=\"tabsData.tabs[Object.keys(tabsData.tabs)[tabsData.selectedTab]].data.length===0\" &gt; &lt;v-tab v-for=\"(tabName,tabIndex) in Object.keys(tabsData.tabs)\" :key=\"tabName+'_'+tabIndex\" :disabled=\"tabsData.tabs[tabName].data.length===0\" @change=\"selectedValues=null\" &gt; {{ cleanString(tabName) }} ({{ tabsData.tabs[tabName].count }}) &lt;/v-tab&gt; &lt;/v-tabs&gt; &lt;!-- tab content --&gt; &lt;v-tabs-items v-if=\"!tabsDataExist\" v-model=\"tabsData.selectedTab\" class=\"transparent height-430\" &gt; &lt;v-tab-item v-for=\"(tabItem,tabItemIndex) in filterList\" :key=\"tabItem+'_'+tabItemIndex\" &gt; &lt;v-virtual-scroll :items=\"tabItem.data\" height=\"400\" item-height=\"130\" class=\"ma-4 overflow-x-hidden\" &gt; &lt;template #default=\"{ item,index }\"&gt; &lt;router-link :to=\"'/'+item.id\" @click.native=\"()=&gt;$scrollTo('body',0,{})\" &gt; &lt;v-card :key=\"item.id + '_' + index\" class=\"pa-4 d-flex flex-column v-card-hover mx-2 height-120\" flat outlined &gt; &lt;div class=\"d-flex align-center\"&gt; &lt;record-status :record=\"item\" :show-status=\"false\" /&gt; &lt;div class=\"ml-10 underline-effect text-ellipses-height-2lines line-height-20\"&gt; {{ item.name }} &lt;/div&gt; &lt;/div&gt; &lt;p class=\"grey--text relation-style text-ellipses-height-2lines line-height-14 pr-5\"&gt; {{ item.object }} &lt;v-tooltip top&gt; &lt;template #activator=\"{ on }\"&gt; &lt;span v-for=\"(label, indexLabel) in item.recordAssocLabel\" :key=\"label+'_'+ indexLabel\" class=\"red--text mouse-info\" v-on=\"on\" &gt; {{ label }} &lt;span v-if=\"indexLabel !== 0 &amp;&amp; item.recordAssocLabel.length!==1\" style=\"color: black!important\" &gt;and&lt;/span&gt; &lt;/span&gt; &lt;/template&gt; &lt;span v-for=\"(label2,indexHint) in item.recordAssocLabel\" :key=\"label2+'_'+indexHint\" &gt; &lt;span&gt;{{ indexHint !== 0 &amp;&amp; item.recordAssocLabel.length&gt;1?relationDefinition[item.recordAssocLabel[item.recordAssocLabel.length-1-indexHint]].toLowerCase():relationDefinition[item.recordAssocLabel[item.recordAssocLabel.length-1-indexHint]] }} &lt;span v-if=\"indexHint !== item.recordAssocLabel.length-1 &amp;&amp; item.recordAssocLabel.length!==1\" style=\"color: white!important;margin-left: -2px!important;\" &gt;; &lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;/v-tooltip&gt; {{ item.subject }} &lt;/p&gt; &lt;/v-card&gt; &lt;/router-link&gt; &lt;/template&gt; &lt;/v-virtual-scroll&gt; &lt;/v-tab-item&gt; &lt;/v-tabs-items&gt; &lt;/div&gt; &lt;/v-card&gt; &lt;/template&gt; &lt;script&gt; import {mapState} from \"vuex\"; import SectionTitle from '@/components/Records/Record/SectionTitle'; import RecordStatus from \"@/components/Records/Shared/RecordStatus\"; import recordRelationShipsDefinitions from \"@/data/RecordRelationShipsDefinitions.json\"; import recordTabUtils from \"@/utils/recordTabUtils\"; import stringUtils from \"@/utils/stringUtils\"; export default { name: \"RelatedContent\", components: { RecordStatus, SectionTitle, }, mixins:[stringUtils,recordTabUtils], props:{ backColor:{ default:null, type: String, } }, data: () =&gt; { return { relationDefinition: recordRelationShipsDefinitions, selectedValues: null, tabsData: { selectedTab: 0, tabs: { related_standards: {registry: [\"Standard\"], data: [], count:0}, related_databases: {registry: [\"Database\"], data: [], count:0} } } } }, computed: { ...mapState(\"record\", [\"currentRecord\"]), }, methods: { /** Dynamically sets data for each tabs based on the data received from recordAssociations and reverseAssociations*/ // This code is a bit of a mess due to multiple rewrites related to vague/changing requirements. It would be better // off being re-written or replaced with the original plan (a single table for all relations, with filters). prepareTabsData() { const _module = this; // A policy may recommend collections; other records may be collected. if (_module.currentRecord['fairsharingRecord'].registry === 'Policy') { _module.$set(_module.tabsData.tabs, 'related_collections', {registry: [\"Collection\"], data: [], count:0}); } if (Object.keys(_module.currentRecord['fairsharingRecord']).includes('recordAssociations') || Object.keys(_module.currentRecord['fairsharingRecord']).includes('reverseRecordAssociations')) { Object.keys(_module.tabsData.tabs).forEach(tabName =&gt; { _module.tabsData.tabs[tabName].data = _module.prepareAssociations( _module.currentRecord['fairsharingRecord'].recordAssociations, _module.currentRecord['fairsharingRecord'].reverseRecordAssociations ).filter(item =&gt; _module.tabsData.tabs[tabName].registry.includes(item.registry)) // This replacement code is rather clunky, as it performs an operation in three stages, but it is at // least readable (well, by this non-javascript-programmer). // 0. This hack is related to this comment: // https://github.com/FAIRsharing/fairsharing.github.io/pull/2255#issuecomment-1963978178 if (tabName === 'related_collections') { _module.tabsData.tabs['related_collections'].data = _module.tabsData.tabs['related_collections'].data .filter((item) =&gt; item.recordAssociationLabel === 'recommends'); } // 1. Create a hash with keys for each linked record ID of all the relations, containing an // array of all relations. let duplicates = {}; _module.tabsData.tabs[tabName].data.forEach((item) =&gt; { if (!(item.id in duplicates)) { duplicates[item.id] = []; } if (!duplicates[item.id].includes(item.recordAssociationLabel)) { duplicates[item.id].push(item.recordAssociationLabel); } }) // 2. Update the tabs data with the duplicated labels. _module.tabsData.tabs[tabName].data.forEach((item) =&gt; { item.recordAssocLabel = duplicates[item.id]; }) // 3. Delete extraneous entries. // Thanks, Stack Overflow! // https://stackoverflow.com/questions/2218999/how-to-remove-all-duplicates-from-an-array-of-objects#comment72641733_36744732 _module.tabsData.tabs[tabName].data = _module.tabsData.tabs[tabName].data.filter((thing, index, self) =&gt; self.findIndex(t =&gt; t.id === thing.id) === index); // Duplicates removed, now do the count. _module.tabsData.tabs[tabName].count = _module.tabsData.tabs[tabName].data.length; }); } else { return false } }, nameAbbrFilter(item, queryText) { const search = queryText.toLowerCase() const name = item.name.toLowerCase(); if (item.abbreviation == null) { let answer = name.indexOf(search) &gt; -1 return answer; } else { let answer = (name.indexOf(search) &gt; -1 || item.abbreviation.toLowerCase().indexOf(search) &gt; -1) return answer; } } } } &lt;/script&gt; × Search results Close "},"components_Records_Search_Input_SearchInput.vue.html":{"id":"components_Records_Search_Input_SearchInput.vue.html","title":"Source: components/Records/Search/Input/SearchInput.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/SearchInput.vue &lt;template&gt; &lt;v-card id=\"scrollable-holder\" :class=\"['pa-2', ($vuetify.breakpoint.mdAndUp) ? responsiveClassObject : 'fullHeight']\" outlined tile elevation=\"3\" width=\"100%\" &gt; &lt;!-- Search Box --&gt; &lt;string-search v-if=\"showSearchBox\" add-search-terms :search-path=\"searchPath\" placeholder=\"Search through current results.\" /&gt; &lt;hr v-if=\"showSearchBox\" class=\"mb-3 mr-2 ml-2 custom-hr\" &gt; &lt;!-- Filter Buttons --&gt; &lt;FilterButtons /&gt; &lt;!-- expansion Panels --&gt; &lt;v-expansion-panels v-if=\"getFilters.length&gt;0\" v-model=\"panel\" multiple flat hover accordion &gt; &lt;filter-autocomplete v-for=\"filter in setup\" :key=\"filter.filterLabel\" :filter=\"filter\" /&gt; &lt;/v-expansion-panels&gt; &lt;/v-card&gt; &lt;/template&gt; &lt;script&gt; import {mapGetters, mapState} from \"vuex\" import StringSearch from \"@/components/Records/Search/Input/StringSearch\"; import filterMapping from \"@/data/FiltersLabelMapping.json\"; import FilterAutocomplete from \"./FilterAutocomplete\"; import FilterButtons from \"./FilterButtons\"; export default { name: \"SearchInput\", components: {StringSearch, FilterButtons, FilterAutocomplete}, props:{ showSearchBox: {default: true, type: Boolean}, searchPath: {default: '/search', type: String} }, data() { return { panel: [], filterSelected: {}, sortOrder: filterMapping['sort_order'], } }, computed: { ...mapState('uiController', ['UIGeneralStatus']), ...mapGetters(\"searchFilters\", [\"getFilters\"]), setup() { let _module = this; _module.setPanel(); _module.createIndexForFilters(); return _module.getFilters.sort(_module.compareLabels); }, responsiveClassObject: function () { return { 'filters-holder-default': this.UIGeneralStatus.headerVisibilityState, 'filters-holder-after-scroll': !this.UIGeneralStatus.headerVisibilityState, } } }, methods: { setPanel() { this.panel = [...Array(this.getFilters.length).keys()].map((k, i) =&gt; i) }, resetPanel() { this.panel = [] }, createIndexForFilters: function () { this.getFilters.forEach(item =&gt; { this.filterSelected[item.filterName] = []; }); }, /** * This gets the index of the name of the filter from the list above, so that the fields can be sorted on the * users' preferences. But, some terms may not be in the list, so they are given the index of 100 to force * them to appear later. */ compareLabels: function(a, b) { let _module = this; const aIndex = _module.sortOrder.indexOf(a['filterName']); const bIndex = _module.sortOrder.indexOf(b['filterName']); const aOrder = aIndex === -1 ? 100 : aIndex; const bOrder = bIndex === -1 ? 100 : bIndex; let comparison = -1; if (aOrder &gt; bOrder) { comparison = 1; } return comparison; } } } &lt;/script&gt; &lt;style scoped&gt; .filters-holder-default { border-radius: 0; -moz-border-radius: 0; -webkit-border-radius: 0; overflow-x: hidden; height: calc(100vh - 355px); position: sticky; top: 0; transition: height ease-in 500ms; overscroll-behavior: contain; scrollbar-width:thin; } .filters-holder-after-scroll { border-radius: 0; -moz-border-radius: 0; -webkit-border-radius: 0; overflow-x: hidden; height: 100vh; position: sticky; top: 0; transition: height ease-in 500ms; overscroll-behavior: contain; scrollbar-width:thin; } .custom-hr { opacity: .5; } .fullHeight { height: 90vh; overflow: scroll; } &lt;/style&gt; × Search results Close "},"views_Users_Signup.vue.html":{"id":"views_Users_Signup.vue.html","title":"Source: views/Users/Signup.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: views/Users/Signup.vue &lt;template&gt; &lt;Register /&gt; &lt;/template&gt; &lt;script&gt; import Register from \"../../components/Users/Register\"; /** This component handles the sign-up/register page * */ export default { name: \"Signup\", components: {Register} } &lt;/script&gt; × Search results Close "},"components_Records_Search_Header_Sorting.vue.html":{"id":"components_Records_Search_Header_Sorting.vue.html","title":"Source: components/Records/Search/Header/Sorting.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Header/Sorting.vue &lt;template&gt; &lt;v-list&gt; &lt;v-list-item v-for=\"(item, index) in getFilters()\" :key=\"'sorter_' + index\" :class=\"{'v-list-item--active': activeFilter === item.name + ',' + item.order}\" @click=\"applySortQuery(item.name, item.order)\" &gt; &lt;v-list-item-title&gt; {{ item.label }} ({{ item.orderLabel }}) &lt;/v-list-item-title&gt; &lt;/v-list-item&gt; &lt;/v-list&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"Sorting\", data() { return { sortFilters: [ {name: 'name', label: 'name', active: false}, {name: 'abbreviation', label: 'abbreviation', active: false}, {name: '_score', label: 'best-match', active: false}, ], activeFilter: null } }, mounted(){ const _module = this; _module.activeFilter = (_module.$route.query.orderBy) ? _module.$route.query.orderBy : '_score,asc'; }, methods: { /** * Set the orderBy parameter value to the given input for vueJs router * @param {string} activeSortFilterName - sorting under this name * @param {string} sortMethod - can be either ASC or DESC */ applySortQuery: async function (activeSortFilterName, sortMethod) { let _module = this; let inputOrderBy = `${activeSortFilterName},${sortMethod}`; let currentQuery = JSON.parse(JSON.stringify(_module.$route.query)); currentQuery[\"orderBy\"] = inputOrderBy; if (inputOrderBy !== _module.activeFilter){ await _module.$router.push({ name: _module.$route.name, query: currentQuery }); } }, getFilters: function(){ let filters = []; this.sortFilters.forEach(function(filter){ filters.push({ label: filter.label, name: filter.name, order: \"asc\", orderLabel: \"ascending\" }); if (filter.name !== '_score') { filters.push({ label: filter.label, name: filter.name, order: \"desc\", orderLabel: \"descending\" }) } }); return filters; } } } &lt;/script&gt; &lt;style scoped&gt; .highlighted { color: red !important; } &lt;/style&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Subject.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Subject.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Subject.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Subject.vue &lt;template&gt; &lt;div class=\"d-flex width-90\"&gt; &lt;TooltipComponent :tool-tip-text=\"toolTipText\" /&gt; &lt;AutoCompleteComponent v-model=\"model\" :item-value=\"itemValue\" :item-list=\"getSearchSubjects\" :loading=\"getLoadingStatus\" @input=\"selectedValue\" @fetchData=\"getResults\" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapActions, mapGetters } from \"vuex\"; import subjectSearch from \"@/store\"; import AutoCompleteComponent from \"./AutoCompleteComponent.vue\"; import TooltipComponent from \"./TooltipComponent.vue\"; export default { name: \"Subject\", components: { TooltipComponent, AutoCompleteComponent }, props: { value: { type: Array, default: () =&gt; [], }, }, data: () =&gt; { return { itemSelected: [], itemValue: [], toolTipText: \"Tags from the FAIRsharing subject ontology. Multiple selections will be joined with OR. Start typing to see Subject tags.\", }; }, computed: { ...mapGetters(\"subjectSearch\", [\"getSearchSubjects\", \"getLoadingStatus\"]), ...mapGetters(\"advancedSearch\", [\"getEditDialogStatus\"]), model: { get() { return this.itemSelected; }, set(value) { this.$emit(\"input\", value); }, }, }, watch: { itemSelected(newValue) { this.itemValue = newValue; }, /** * Item list for the autocomplete should not be empty * It is assigned with selected values when edit field is opened */ getEditDialogStatus: { handler(open) { if (open) { if (this.value &amp;&amp; this.value.length) { subjectSearch.commit(\"subjectSearch/setSearchSubjects\", this.value); } } }, immediate: true, }, }, mounted() { //Pre-fill selected values on edit advanced search is clicked and open this.itemValue = this.value; }, methods: { ...mapActions(\"subjectSearch\", [\"fetchSearchSubjects\"]), selectedValue(item) { this.itemSelected = item; }, getResults(queryParams) { if (queryParams) this.fetchSearchSubjects(queryParams); }, }, }; &lt;/script&gt; &lt;style lang=\"scss\" scoped&gt; @import \"@/styles/advancedSearchComponents\"; &lt;/style&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Taxonomies.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_Taxonomies.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Taxonomies.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/Taxonomies.vue &lt;template&gt; &lt;div class=\"d-flex width-90\"&gt; &lt;TooltipComponent :tool-tip-text=\"toolTipText\" /&gt; &lt;AutoCompleteComponent v-model=\"model\" :item-value=\"itemValue\" :item-list=\"getSearchTaxonomies\" :loading=\"getLoadingStatus\" @input=\"selectedValue\" @fetchData=\"getResults\" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapActions, mapGetters } from \"vuex\"; import taxonomiesSearch from \"@/store\"; import AutoCompleteComponent from \"./AutoCompleteComponent.vue\"; import TooltipComponent from \"./TooltipComponent.vue\"; export default { name: \"Taxonomies\", components: { TooltipComponent, AutoCompleteComponent }, props: { value: { type: Array, default: () =&gt; [], }, }, data: () =&gt; { return { itemSelected: [], itemValue: [], toolTipText: \"Taxonomy terms (a.k.a 'species') relating to a resource. Multiple selections will be joined with OR. Start typing to see Taxonomy terms.\", }; }, computed: { ...mapGetters(\"taxonomiesSearch\", [\"getSearchTaxonomies\", \"getLoadingStatus\"]), ...mapGetters(\"advancedSearch\", [\"getEditDialogStatus\"]), model: { get() { return this.itemSelected; }, set(value) { this.$emit(\"input\", value); }, }, }, watch: { itemSelected(newValue) { this.itemValue = newValue; }, /** * Item list for the autocomplete should not be empty * It is assigned with selected values when edit field is opened */ getEditDialogStatus: { handler(open) { if (open) { if (this.value &amp;&amp; this.value.length) { taxonomiesSearch.commit( \"taxonomiesSearch/setSearchTaxonomies\", this.value ); } } }, immediate: true, }, }, mounted() { //Pre-fill selected values on edit advanced search is clicked and open this.itemValue = this.value; }, methods: { ...mapActions(\"taxonomiesSearch\", [\"fetchSearchTaxonomies\"]), selectedValue(item) { this.itemSelected = item; }, getResults(queryParams) { if (queryParams) this.fetchSearchTaxonomies(queryParams); }, }, }; &lt;/script&gt; × Search results Close "},"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_UserDefinedTag.vue.html":{"id":"components_Records_Search_Input_AdvancedSearch_QueryBuilderComponents_UserDefinedTag.vue.html","title":"Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/UserDefinedTag.vue","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: components/Records/Search/Input/AdvancedSearch/QueryBuilderComponents/UserDefinedTag.vue &lt;template&gt; &lt;div class=\"d-flex width-90\"&gt; &lt;TooltipComponent :tool-tip-text=\"toolTipText\" /&gt; &lt;AutoCompleteComponent v-model=\"model\" :item-value=\"itemValue\" :item-list=\"getSearchUserDefinedTags\" :loading=\"getLoadingStatus\" @input=\"selectedValue\" @fetchData=\"getResults\" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapActions, mapGetters } from \"vuex\"; import userDefinedTagsSearch from \"@/store\"; import AutoCompleteComponent from \"./AutoCompleteComponent.vue\"; import TooltipComponent from \"./TooltipComponent.vue\"; export default { name: \"UserDefinedTag\", components: { TooltipComponent, AutoCompleteComponent }, props: { value: { type: Array, default: () =&gt; [], }, }, data: () =&gt; { return { itemSelected: [], itemValue: [], toolTipText: \"Tags created by FAIRsharing's user community. Multiple selections will be joined with OR. Start typing to see UserDefined tags.\", }; }, computed: { ...mapGetters(\"userDefinedTagsSearch\", [\"getSearchUserDefinedTags\", \"getLoadingStatus\"]), ...mapGetters(\"advancedSearch\", [\"getEditDialogStatus\"]), model: { get() { return this.itemSelected; }, set(value) { this.$emit(\"input\", value); }, }, }, watch: { itemSelected(newValue) { this.itemValue = newValue; }, /** * Item list for the autocomplete should not be empty * It is assigned with selected values when edit field is opened */ getEditDialogStatus: { handler(open) { if (open) { if (this.value &amp;&amp; this.value.length) { userDefinedTagsSearch.commit( \"userDefinedTagsSearch/setSearchUserDefinedTags\", this.value ); } } }, immediate: true, }, }, mounted() { //Pre-fill selected values on edit advanced search is clicked and open this.itemValue = this.value; }, methods: { ...mapActions(\"userDefinedTagsSearch\", [\"fetchSearchUserDefinedTags\"]), selectedValue(item) { this.itemSelected = item; }, getResults(queryParams) { if (queryParams) this.fetchSearchUserDefinedTags(queryParams); }, }, }; &lt;/script&gt; × Search results Close "},"store_recordData.js.html":{"id":"store_recordData.js.html","title":"Source: store/recordData.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: store/recordData.js import {isEmpty, isEqual} from \"lodash\" import Vue from \"vue\" import RESTClient from \"@/lib/Client/RESTClient.js\" import Client from \"../lib/GraphClient/GraphClient.js\" import recordDataAccessQuery from \"../lib/GraphClient/queries/editor/getRecordDataAccess.json\" import recordRelationsQuery from \"../lib/GraphClient/queries/editor/getRecordRelations.json\" import recordQuery from \"../lib/GraphClient/queries/getRecord.json\" import recordHistory from '../lib/GraphClient/queries/getRecordHistory.json' import recordOrganisationsQuery from \"../lib/GraphClient/queries/getRecordOrganisations.json\" import { initEditorSections } from \"./utils.js\" let client = new Client(); let restClient = new RESTClient(); /** * The record store handles the requests related to record (fairsharingRecord). * @type {Object} */ let recordStore = { namespaced: true, state: { currentRecord: { fairsharingRecord: { metadata: { citations: [] } } }, currentRecordHistory: {}, recordUpdate: { error: false, message: null, id: null }, sections: { generalInformation: initEditorSections(false, [\"generalInformation\"]).generalInformation }, editOrganisationLink: { showOverlay: false, data: {}, id: null }, newRecord: false, currentID: null }, mutations: { setCurrentRecord(state, data){ state.currentRecord = data; let tags = ['subjects', 'domains', 'taxonomies', 'userDefinedTags']; tags.forEach(tag =&gt; { if (state.currentRecord['fairsharingRecord'][tag].length &amp;&amp; state.currentRecord['fairsharingRecord'][tag] ) { state.currentRecord['fairsharingRecord'][tag].forEach(item =&gt; { item.type = tag; }) } }) }, setRecordHistory(state, data){ state.currentRecordHistory = data; }, resetCurrentRecordHistory(state){ state.currentRecordHistory = {}; }, setSections(state, data){ state.currentID = data['fairsharingRecord'].id; let sectionsNames = [ \"generalInformation\", \"support\", \"dataAccess\", \"publications\", \"organisations\", \"additionalInformation\", \"relations\" ]; state.sections = initEditorSections(data['fairsharingRecord'], sectionsNames); }, setGeneralInformation(state, data){ state.sections.generalInformation = initEditorSections( data['fairsharingRecord'], [\"generalInformation\"] ).generalInformation; if(data['fairsharingRecord']) state.sections.generalInformation.message = \"Record successfully updated!\"; }, resetMessage(state, sectionName){ state.sections[sectionName].message = null; state.sections[sectionName].message = false; }, setSectionError(state, error){ state.sections[error.section].message = error.value; state.sections[error.section].error = true; }, setChanges(state, diff){ state.sections[diff.section].changes = diff.value; }, setContacts(state, contacts){ state.sections.generalInformation.data.metadata.contacts = contacts; }, setTags(state, field){ state.sections.generalInformation.data[field.target] = field.value; }, resetRegistry(state){ state.sections.generalInformation.data.type = \"\"; }, setPublications(state, publications) { state.sections.publications.data = publications; }, setAdditionalInformation(state, additionalInformation) { if (!additionalInformation.subfieldName){ Vue.set(state.sections.additionalInformation.data, additionalInformation.fieldName, additionalInformation.fieldValue ); } else { Vue.set(state.sections.additionalInformation.data[additionalInformation.fieldName], additionalInformation.subfieldName, additionalInformation.fieldValue ); } }, setAdditionalInformationSubField(state, additionalInformation) { if (additionalInformation.id !== null) { state.sections.additionalInformation.data[additionalInformation.fieldName][additionalInformation.id] = additionalInformation.fieldValue; } else { if (!state.sections.additionalInformation.data[additionalInformation.fieldName]){ Vue.set(state.sections.additionalInformation.data, additionalInformation.fieldName,[]); } try { Vue.set(state.sections.additionalInformation.data[additionalInformation.fieldName], state.sections.additionalInformation.data[additionalInformation.fieldName].length, additionalInformation.fieldValue ); // eslint-disable-next-line no-empty } catch(e) { // TODO: Investigate comments below. // Github has been failing tests (which are fine locally) here for reasons which // have not so far been determined. // TypeError: Cannot read property 'shallow' of undefined // ...on the Vue.set, above. // eslint-enable-next-line no-empty } } }, removeAdditionalInformationSubField(state, additionalInformation){ state.sections.additionalInformation.data[additionalInformation.fieldName].splice(additionalInformation.id, 1) }, updateOrganisationsLinks(state, links){ state.sections.organisations.data = links; state.sections.organisations.initialData = JSON.parse(JSON.stringify(links)); state.sections.organisations.changes = 0; state.sections.organisations.message = \"Record successfully updated!\"; }, setEditOrganisationLink(state, newLink){ state.editOrganisationLink = newLink; }, setEditOrganisationLinkOrganisation(state, organisation){ state.editOrganisationLink.data.organisation = organisation; }, setEditOrganisationLinkGrant(state, grant) { state.editOrganisationLink.data.grant = grant; }, setDataAccess(state, dataAccess){ let record = { exhaustiveLicences: dataAccess.exhaustiveLicences, licences: dataAccess['licenceLinks'], support_links: dataAccess.metadata.support_links }; state.sections.generalInformation.data.metadata.support_links = JSON.parse(JSON.stringify(record.support_links)); state.sections.dataAccess.data.exhaustiveLicences = record.exhaustiveLicences; state.sections.generalInformation.initialData.metadata.support_links = JSON.parse(JSON.stringify(record.support_links)); record.support_links.forEach(supportLink =&gt; { if (supportLink.name) supportLink.url = {title: supportLink.name, url: supportLink.url} }); state.sections.dataAccess.data = record; state.sections.dataAccess.initialData = JSON.parse(JSON.stringify(record)); state.sections.dataAccess.changes = 0; state.sections.dataAccess.message = \"Record successfully updated!\"; }, updateAdditionalInformation(state, additionalInformation) { let record = {}; Object.keys(additionalInformation.record).forEach(field =&gt; { if (additionalInformation.fields.includes(field)) { record[field] = additionalInformation.record[field]; state.sections.generalInformation.data.metadata[field] = JSON.parse(JSON.stringify(record[field])); state.sections.generalInformation.initialData.metadata[field] = JSON.parse(JSON.stringify(record[field])); } }); state.sections.additionalInformation.data = record; state.sections.additionalInformation.initialData = JSON.parse(JSON.stringify(record)); state.sections.additionalInformation.changes = 0; state.sections.additionalInformation.message = \"Record successfully updated!\"; }, setCreatingNewRecord(state){ state.newRecord = true; }, setEditingRecord(state){ state.newRecord = false; }, setRelations(state, relations){ state.sections.relations.data.recordAssociations = relations; state.sections.relations.initialData.recordAssociations = JSON.parse(JSON.stringify(relations)); state.sections.relations.changes = 0; state.sections.relations.message = \"Record successfully updated!\"; state.sections.relations.error = false; }, setMessage(state, message){ state.sections[message.target].message = message.value; }, setNewRecord(state, id){ state.recordUpdate = { error: false, message: \"success\", id: id } }, setError(state, error){ state.recordUpdate = { error: true, message: error, id: null } }, cleanRecordStore(state){ state.sections = null; state.sections = initEditorSections(false, [ \"generalInformation\", \"support\", \"dataAccess\", \"publications\", \"organisations\", \"additionalInformation\" ]); } }, actions: { async fetchRecord(state, options){ state.commit(\"resetCurrentRecordHistory\"); recordQuery.queryParam = { id: options.id }; if (options.token) { client.setHeader(options.token); } let data = await client.executeQuery(recordQuery); client.initalizeHeader() if (!data[\"fairsharingRecord\"]['metadata']['contacts']) { data[\"fairsharingRecord\"]['metadata']['contacts'] = []; } // Citations should be created if empty. if (!data[\"fairsharingRecord\"]['metadata']['citations']) { data[\"fairsharingRecord\"]['metadata']['citations'] = []; } state.commit('setCurrentRecord', JSON.parse(JSON.stringify(data))); state.commit('setSections', JSON.parse(JSON.stringify(data))); }, async fetchPreviewRecord(state, id){ state.commit(\"resetCurrentRecordHistory\"); recordQuery.queryParam = { id: id }; let data = await client.executeQuery(recordQuery); state.commit('setCurrentRecord', data); }, async fetchRecordHistory(state, options){ recordHistory.queryParam = {id: options.id}; client.setHeader(options.token); let data = await client.executeQuery(recordHistory); state.commit('setRecordHistory', data[\"fairsharingRecord\"]); }, async updateGeneralInformation({ state, commit}, options) { commit(\"resetMessage\", \"generalInformation\"); let { type, countries, userDefinedTags, domains, subjects, taxonomies, status, curator_notes, isHidden, logo, maintainers, watchers, ...record } = JSON.parse(JSON.stringify(state.sections.generalInformation.data)), newTags = [], oldTags = [], tags = []; userDefinedTags.forEach(tag =&gt; { if (Object.keys(tag).indexOf(\"id\") === -1){ newTags.push(tag.label) } else { oldTags.push(tag.id) } }); newTags = await Promise.all(newTags.map(tag =&gt; restClient.createNewUserDefinedTag(tag, options.token)) ); newTags.forEach((tag) =&gt; { if (!tag.error) { tags.push(tag.id); } else { commit(\"setSectionError\", { section: \"generalInformation\", value: tag.error }); return tag.error; } }); isEmpty(logo) ? delete record['logo'] : record.logo = logo record.country_ids = countries.map(obj =&gt; obj.id); if (type.id) record.record_type_id = type.id; record.metadata.status = status; record.curator_notes = curator_notes; record.hidden = isHidden; record.domain_ids = domains.map(obj =&gt; obj.id); record.subject_ids = subjects.map(obj =&gt; obj.id); record.taxonomy_ids = taxonomies.map(obj =&gt; obj.id); record.maintainer_ids = maintainers.map(obj =&gt; obj.id); record.watcher_ids = watchers.map(obj =&gt; obj.id); record.user_defined_tag_ids = tags.concat(oldTags.filter(function (el) {return el != null;})); if (options.change) { record.remove_additional_properties = true } let response = await restClient.updateRecord({ record: record, token: options.token, id: options.id }); if (response.error){ commit(\"setSectionError\", { section: \"generalInformation\", value: response.error }); return response.error; } else { let newRecord = JSON.parse(JSON.stringify(state.sections.generalInformation.data)); let userDefinedTags = []; newRecord.userDefinedTags.forEach(obj =&gt; { if (Object.keys(obj).indexOf(\"id\") === -1) { obj.id = newTags.filter(tag =&gt; {tag.label = obj.label})[0]; userDefinedTags.push(obj); } else userDefinedTags.push(obj); }); newRecord.userDefinedTags = userDefinedTags; commit('setGeneralInformation', {fairsharingRecord: newRecord}); } }, async updatePublications({ state, commit }, options) { commit(\"resetMessage\", \"publications\"); let publications = JSON.parse(JSON.stringify(state.sections.publications.data)); let record_data = { publication_ids: [], citation_ids: [] }; publications.forEach(function (publication) { record_data.publication_ids.push(publication.id); if (publication.isCitation) { record_data.citation_ids.push(publication.id); } delete publication.isCitation; }); const record = { record: record_data, token: options.token, id: options.id }; let response = await restClient.updateRecord(record); if (response.error) { commit(\"setSectionError\", { section: \"publications\", value: response.error }); return response.error; } else { commit(\"setMessage\", {target: \"publications\", value: \"Record successfully updated!\"}); } }, async updateOrganisations({state, commit}, userToken){ commit(\"resetMessage\", \"organisations\"); let deleteItems = [], updateItems = [], createItems = []; state.sections.organisations.initialData.forEach((obj) =&gt; { let found = state.sections.organisations.data.filter(org =&gt; org.id === obj.id)[0]; if (!found) { deleteItems.push(obj); } }); state.sections.organisations.data.forEach(function(obj) { let query = { fairsharing_record_id: state.currentRecord['fairsharingRecord'].id, organisation_id: obj.organisation.id, relation: obj.relation, grant_id: (obj.grant) ? obj.grant.id : null, is_lead: obj.isLead }; if (Object.prototype.hasOwnProperty.call(obj, 'id')) updateItems.push({query: query, id: obj.id}); else createItems.push(query); }); let queries = await Promise.all([ ...deleteItems.map(organisation =&gt; restClient.deleteOrganisationLink(organisation.id, userToken)), ...createItems.map(organisation =&gt; restClient.createOrganisationLink(organisation, userToken)), ...updateItems.map(organisation =&gt; restClient.updateOrganisationLink(organisation.query, organisation.id, userToken)) ]); queries.forEach((org) =&gt; { if (org.error) { commit(\"setSectionError\", { section: \"organisations\", value: org.error }); } }); recordOrganisationsQuery.queryParam = {id: state.currentRecord.fairsharingRecord.id}; client.setHeader(userToken); let organisations = await client.executeQuery(recordOrganisationsQuery); commit('updateOrganisationsLinks', organisations.fairsharingRecord.organisationLinks); }, async updateAdditionalInformation({ state, commit}, options){ commit(\"resetMessage\", \"additionalInformation\"); let newRecord = { metadata: state.sections.generalInformation.initialData.metadata, }; options.fields.forEach(field =&gt; { if (state.sections.additionalInformation.data[field]) { Object.keys(state.sections.additionalInformation.data[field]).forEach(key =&gt; { if (state.sections.additionalInformation.data[field][key] === \"\") { delete state.sections.additionalInformation.data[field][key] } }) newRecord.metadata[field] = state.sections.additionalInformation.data[field] } else if (state.sections.additionalInformation.data[field] === null) { // if its the case that there is a single string textInput only state.sections.additionalInformation.data[field] = \"\"; newRecord.metadata[field] = state.sections.additionalInformation.data[field] } }); let response = await restClient.updateRecord({ record: newRecord, token: options.token, id: options.id }); if (response.error) { commit(\"setSectionError\", { section: \"additionalInformation\", value: response.error }); return response.error; } else { commit(\"setMessage\", {target: \"additionalInformation\", value: \"Record successfully updated!\"}); commit('updateAdditionalInformation', {record: newRecord.metadata, fields: options.fields}); } }, async updateDataAccess({state, commit}, options){ commit(\"resetMessage\", \"dataAccess\"); let newRecord = { metadata: state.sections.generalInformation.initialData.metadata, }; newRecord.metadata.support_links = state.sections.dataAccess.data.support_links; newRecord.metadata.support_links.forEach(supportLink =&gt; { if (typeof supportLink.url !== 'string') { supportLink.url = supportLink.url.url; } }); let initialLicences = state.sections.dataAccess.initialData.licences, currentLicences = state.sections.dataAccess.data.licences, toDelete = [], toUpdate = [], toCreate = []; initialLicences.forEach(licence =&gt; { let found = currentLicences.filter(obj =&gt; obj.id === licence.id)[0]; if (!found) toDelete.push(licence.id); }); currentLicences.forEach(licence =&gt; { let found = initialLicences.filter(obj =&gt; obj.id === licence.id)[0], newLicence = prepareLicence(licence); if (!found){ toCreate.push(newLicence); } else if (found &amp;&amp; !isEqual(licence, found)) { toUpdate.push(newLicence); } }); newRecord.exhaustive_licences = state.sections.dataAccess.data.exhaustiveLicences; let responses = await Promise.all([ restClient.updateRecord({ record: newRecord, token: options.token, id: options.id }), ...toCreate.map(licence =&gt; restClient.createLicenceLink(licence, options.token)), ...toUpdate.map(licence =&gt; restClient.updateLicenceLink(licence, options.token)), ...toDelete.map(licence =&gt; restClient.deleteLicenceLink(licence, options.token)) ]); responses.forEach((response) =&gt; { if (response.error) { commit(\"setSectionError\", { section: \"dataAccess\", value: response.error }); return response.error; } }); recordDataAccessQuery.queryParam = {id: state.currentRecord.fairsharingRecord.id}; client.setHeader(options.token); let dataAccess = await client.executeQuery(recordDataAccessQuery); commit('setDataAccess', dataAccess.fairsharingRecord); }, async updateRelations({state, commit}, options){ commit(\"resetMessage\", \"relations\"); let newAssociations = [], deleteAssociations = [], oldAssociations = []; state.sections.relations.data.recordAssociations.forEach(association =&gt; { if (association.new) { const newAssociation = { fairsharing_record_id: options.source, linked_record_id: association.linkedRecord.id, record_assoc_label_id: association.recordAssocLabel.id }; newAssociations.push(newAssociation); } else { // Using a combination of record_id and label_id as this should be unique. // Using only record_id produced: // https://github.com/FAIRsharing/fairsharing.github.io/issues/1620 let id = association.linkedRecord.id + \"_\" + association.recordAssocLabelId; oldAssociations.push(id); } }); state.sections.relations.initialData.recordAssociations.forEach(oldAssociation =&gt; { // Same unique ID as above. let id = oldAssociation.linkedRecord.id + \"_\" + oldAssociation.recordAssocLabelId; if (id &amp;&amp; !oldAssociations.includes(id)) { deleteAssociations.push({ id: oldAssociation.id, _destroy: 1 }); } }); let responses = await Promise.all([ restClient.saveRelations({ token: options.token, relations: newAssociations, target: options.source }), restClient.deleteRelations({ token: options.token, relations: deleteAssociations, target: options.source }) ]); let error = false; for (let response of responses) { if (response.error) { commit(\"setSectionError\", { section: \"relations\", value: response.error }); error = true; } } if (!error){ recordRelationsQuery.queryParam = {id: options.source}; client.setHeader(options.token); let relations = await client.executeQuery(recordRelationsQuery); commit('setRelations', relations['fairsharingRecord'].recordAssociations); } }, resetRecord(state){ state.commit('setGeneralInformation', {fairsharingRecord: false}); }, async updateRecord(state, newRecord){ let response = await restClient.updateRecord(newRecord); if (response.error){ state.commit(\"setError\", response.error.response) } else { state.commit(\"setNewRecord\", response) } } }, getters: { getField: (state) =&gt; (fieldName) =&gt; { return state.currentRecord['fairsharingRecord'][fieldName]; }, getSection: (state) =&gt; (sectionName) =&gt; { return state.sections[sectionName]; }, getChanges: (state) =&gt; { let changes = {}; Object.keys(state.sections).forEach(section =&gt; { changes[section] = state.sections[section].changes }); return changes; }, getAllChanges: (state) =&gt; { let changes = 0; Object.keys(state.sections).forEach(section =&gt; { changes += state.sections[section].changes; }); return changes; }, getCreatingNewRecord: (state) =&gt; { return state.newRecord; }, getRecordType: (state) =&gt; { return state.sections['generalInformation'].initialData.type } } }; function prepareLicence(rawLicence){ let preparedLicence = { relation: rawLicence.relation }; preparedLicence.fairsharing_record_id = (rawLicence.fairsharingRecord) ? rawLicence.fairsharingRecord.id : rawLicence.fairsharing_record_id; if (rawLicence.id) preparedLicence.id = rawLicence.id; if (rawLicence.licence.id){ preparedLicence.licence_id = rawLicence.licence.id } else { preparedLicence.licence_attributes = rawLicence.licence; } return preparedLicence; } export default recordStore; × Search results Close "},"utils_recordTabUtils.js.html":{"id":"utils_recordTabUtils.js.html","title":"Source: utils/recordTabUtils.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: utils/recordTabUtils.js const recordTabUtils = { computed: { /** Fetch content related to each tab and feed search autocomplete*/ getValues() { let selectedTabKey = Object.keys(this.tabsData.tabs) return this.tabsData.tabs[selectedTabKey[this.tabsData.selectedTab]].data; }, /** Deactivate the section if none of the tabs hold data*/ tabsDataExist() { let inactiveTabs = true for (const [key] of Object.entries(this.filterList)) { if (this.filterList[key].data.length &gt;= 1) { inactiveTabs = false break } } return inactiveTabs }, /** Filter down list if search box value changes unless it returns the whole data in a list*/ filterList() { const _module = this // here I deep copied object so the references are gone and my object is a new object with unique reference const output = JSON.parse(JSON.stringify(_module.tabsData.tabs)); if (this.selectedValues !== null &amp;&amp; this.selectedValues !== \"\" &amp;&amp; this.selectedValues !== undefined) { let foundItem = output[Object.keys(_module.tabsData.tabs)[_module.tabsData.selectedTab]].data.find(item =&gt; item.name === _module.selectedValues) if (foundItem) { output[Object.keys(output)[_module.tabsData.selectedTab]].data = [] output[Object.keys(output)[_module.tabsData.selectedTab]].data.push(foundItem) } return output } return output } }, methods: { /** Combines associations and reserveAssociations into a single array and prepare the data for the search table */ /* * This results in a bit of a mess as it camouflages which direction a relationship goes. * TODO: Refactor, somehow. */ prepareAssociations(associations, reverseAssociations) { let _module = this; let recordAssociations = [] let joinedArrays = associations.concat(reverseAssociations); const properties = ['fairsharingRecord', 'linkedRecord']; joinedArrays.forEach((item) =&gt; { let object = {recordAssocLabel:[]}; properties.forEach(prop =&gt; { if (Object.prototype.hasOwnProperty.call(item, prop)) { object.recordAssocLabel[0] = _module.cleanString(item.recordAssocLabel); object.recordAssociationLabel = _module.cleanString(item.recordAssocLabel) object.id = item[prop].id; object.registry = item[prop].registry; object.abbreviation = item[prop].abbreviation; object.type = item[prop].type; object.linkType = prop; object.name = item[prop].name; // Though both conditions are tested in Collections.spec.js, they don't register. /* istanbul ignore else */ if (prop === 'linkedRecord') { object.object = _module.currentRecord['fairsharingRecord'].name; object.subject = item[prop].name; } else if (prop === 'fairsharingRecord') { object.object = item[prop].name; object.subject = _module.currentRecord['fairsharingRecord'].name; } } }); recordAssociations.push(object); }); return recordAssociations; }, /** active the very first tab that contains at least one item */ getFirstActiveTab() { let firstActiveTabIndex = 0; let index = -1 for (const [key] of Object.entries(this.filterList)) { index++ if (this.filterList[key].data.length &gt;= 1) { firstActiveTabIndex = index break } } this.tabsData.selectedTab = firstActiveTabIndex } }, beforeMount() { this.prepareTabsData(); this.getFirstActiveTab(); } } export const prepareAssociations = (context, associations, reverseAssociations) =&gt; { let _module = context; let recordAssociations = [] let joinedArrays = associations.concat(reverseAssociations); const properties = ['fairsharingRecord', 'linkedRecord']; joinedArrays.forEach((item) =&gt; { let object = {recordAssocLabel: []}; properties.forEach(prop =&gt; { if (Object.prototype.hasOwnProperty.call(item, prop)) { object.recordAssocLabel[0] = item.recordAssocLabel; object.id = item[prop].id; object.registry = item[prop].registry; object.name = item[prop].name; object.abbreviation = item[prop].abbreviation; object.subject = _module.currentRecord['fairsharingRecord'].name; object.type = item[prop].type; object.linkType = prop; } }); recordAssociations.push(object); }); return recordAssociations; } export default recordTabUtils; × Search results Close "},"utils_advancedSearchUtils.js.html":{"id":"utils_advancedSearchUtils.js.html","title":"Source: utils/advancedSearchUtils.js","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Source: utils/advancedSearchUtils.js import { uniqWith } from \"lodash\"; import { mapGetters } from \"vuex\"; /** * Removes duplicate values in a set and returns unique values * @returns {Array} Array with non-duplicate values */ const uniqueValues = (item) =&gt; { let merged = uniqWith(item, (pre, cur) =&gt; { if (pre.identifier === cur.identifier) { cur[\"value\"] = cur[\"value\"] + \",\" + pre[\"value\"]; //Combine string values from different text-fields in same set and convert in into array /*istanbul ignore else */ if (typeof cur[\"value\"] === \"string\") { cur[\"value\"] = cur[\"value\"].split(\",\"); } //Remove duplicates and create unique array cur[\"value\"] = [...new Set(cur[\"value\"])]; return true; } return false; }); return merged; }; /** * Removes an item from the array * @param item * @param arrayList * @returns {Array} - updated array without the item */ const removeItem = (item, arrayList) =&gt; { const index = arrayList.indexOf(item); if (index &gt;= 0) arrayList.splice(index, 1); }; /** * Mixin to filter the records types based on the registry * {{computed: {getRecordTypes: Computed}, methods: {filteredRecordTypes(*): *[]}}} * @param {String} registryname * @return {Array} - recordTypes filtered by registryname */ const recordTypes = { computed: { ...mapGetters(\"recordTypes\", [\"getRecordTypes\"]), }, methods: { filteredRecordTypes(registry) { let filteredRecordTypes = []; this.getRecordTypes.filter(({ name, fairsharingRegistry }) =&gt; { if (fairsharingRegistry[\"name\"] === registry) { filteredRecordTypes.push(name); } }); return filteredRecordTypes; }, }, }; export { recordTypes, removeItem, uniqueValues }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Global Members &lt;constant&gt; buildFacets Given an object containing the raw facets coming from the client and a mapping object , build the ready to use facets for usage by the Vue components. Source: store/recordSearch.js, line 192 &lt;constant&gt; buildFilters Given a searchFairsharingRecords aggregations array, build the values used by the advanced search widgets Source: store/searchFilters.js, line 134 filtersStore :Object The searchFilters store trigger a single field query to searchFairsharingRecords, gets the aggregation array and builds the filtering system to be used by advanced search functions. Type: Object Source: store/searchFilters.js, line 112 introspectionStore :Object The introspection store is related to the introspection query that let us know which fields/types are allowed by the searchFairsharingRecords query Type: Object Source: store/introspector.js, line 107 &lt;constant&gt; paramsAreExpired Compares the given date with now and returns true if it greater than the given timer Source: store/introspector.js, line 154 recordStore :Object The record store handles the requests related to record (fairsharingRecord). Type: Object Source: store/recordData.js, line 21 &lt;constant&gt; recordTypes Mixin to filter the records types based on the registry {{computed: {getRecordTypes: Computed}, methods: {filteredRecordTypes(*): *[]}}} Source: utils/advancedSearchUtils.js, line 43 recordsStore :Object The records store handles the requests related to records (searchFairsharingRecords and fairsharingRecord). Type: Object Source: store/recordSearch.js, line 167 states :Object Type: Object Properties: Name Type Description errors String collects errors while introspecting. searchQueryParameters object filters query parameters object coming from API. Source: store/introspector.js, line 109 Methods hackSearch() Convert a prop from the old system into that used by the new. Useful when old search links have been deployed elsewhere in the internet or in print (as long as we know about them). Source: router/hackSearch.js, line 16 Returns: String - new form of the old prop hasValue(val) Assess if the string is of a certain value (useful to compare passwords) Parameters: Name Type Description val String the value to evaluate the string against Source: utils/rules.js, line 6 Returns: Type function isAllowedSize() Assess if the given file has the correct allowed size Source: utils/rules.js, line 107 Returns: Type function isEmail() Assess email patterns. Source: utils/rules.js, line 14 Returns: Type function isEmailOrUrl() Assess email or email patterns. Source: utils/rules.js, line 58 Returns: Type function isImage() Assess if the given file has the correct extension Source: utils/rules.js, line 96 Returns: Type function isLongEnough(length) Assess if the string is long enough. Parameters: Name Type Description length Number the length to evaluate the string against. Source: utils/rules.js, line 72 Returns: Type function isMastodon() Assess mastodon username @user@server. Source: utils/rules.js, line 25 Returns: Type function isOrcid() Assess ORCID patterns. Can be empty if required is false. Source: utils/rules.js, line 84 Returns: Type function isRequired() Assess the presence of the field Source: utils/rules.js, line 38 Returns: Type function isUrl() Assess URL patterns. Source: utils/rules.js, line 46 Returns: Type function parseParam(param, paramVal) Given a type and a value, parse the value with the expected type. Parameters: Name Type Description param Object the parameter types allowed paramVal String the value to be parsed Source: store/introspector.js, line 137 Returns: paramVal - the parse value Type String | Number | Boolean Example Example usage of parseParam parseParam({name: \"Boolean\"}, \"true\"); // return True removeItem(item, arrayList) Removes an item from the array Parameters: Name Type Description item arrayList Source: utils/advancedSearchUtils.js, line 32 Returns: updated array without the item Type Array uniqueValues() Removes duplicate values in a set and returns unique values Source: utils/advancedSearchUtils.js, line 8 Returns: Array with non-duplicate values Type Array × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Modules Classes ExternalRESTClients GraphQLClient RESTClient Namespaces Static Members &lt;constant&gt; buildFacets Given an object containing the raw facets coming from the client and a mapping object , build the ready to use facets for usage by the Vue components. Source: store/recordSearch.js, line 192 &lt;constant&gt; buildFilters Given a searchFairsharingRecords aggregations array, build the values used by the advanced search widgets Source: store/searchFilters.js, line 134 filtersStore :Object The searchFilters store trigger a single field query to searchFairsharingRecords, gets the aggregation array and builds the filtering system to be used by advanced search functions. Type: Object Source: store/searchFilters.js, line 112 introspectionStore :Object The introspection store is related to the introspection query that let us know which fields/types are allowed by the searchFairsharingRecords query Type: Object Source: store/introspector.js, line 107 &lt;constant&gt; paramsAreExpired Compares the given date with now and returns true if it greater than the given timer Source: store/introspector.js, line 154 recordStore :Object The record store handles the requests related to record (fairsharingRecord). Type: Object Source: store/recordData.js, line 21 &lt;constant&gt; recordTypes Mixin to filter the records types based on the registry {{computed: {getRecordTypes: Computed}, methods: {filteredRecordTypes(*): *[]}}} Source: utils/advancedSearchUtils.js, line 43 recordsStore :Object The records store handles the requests related to records (searchFairsharingRecords and fairsharingRecord). Type: Object Source: store/recordSearch.js, line 167 states :Object Type: Object Properties: Name Type Description errors String collects errors while introspecting. searchQueryParameters object filters query parameters object coming from API. Source: store/introspector.js, line 109 Methods hackSearch() Convert a prop from the old system into that used by the new. Useful when old search links have been deployed elsewhere in the internet or in print (as long as we know about them). Source: router/hackSearch.js, line 16 Returns: String - new form of the old prop hasValue(val) Assess if the string is of a certain value (useful to compare passwords) Parameters: Name Type Description val String the value to evaluate the string against Source: utils/rules.js, line 6 Returns: Type function isAllowedSize() Assess if the given file has the correct allowed size Source: utils/rules.js, line 107 Returns: Type function isEmail() Assess email patterns. Source: utils/rules.js, line 14 Returns: Type function isEmailOrUrl() Assess email or email patterns. Source: utils/rules.js, line 58 Returns: Type function isImage() Assess if the given file has the correct extension Source: utils/rules.js, line 96 Returns: Type function isLongEnough(length) Assess if the string is long enough. Parameters: Name Type Description length Number the length to evaluate the string against. Source: utils/rules.js, line 72 Returns: Type function isMastodon() Assess mastodon username @user@server. Source: utils/rules.js, line 25 Returns: Type function isOrcid() Assess ORCID patterns. Can be empty if required is false. Source: utils/rules.js, line 84 Returns: Type function isRequired() Assess the presence of the field Source: utils/rules.js, line 38 Returns: Type function isUrl() Assess URL patterns. Source: utils/rules.js, line 46 Returns: Type function parseParam(param, paramVal) Given a type and a value, parse the value with the expected type. Parameters: Name Type Description param Object the parameter types allowed paramVal String the value to be parsed Source: store/introspector.js, line 137 Returns: paramVal - the parse value Type String | Number | Boolean Example Example usage of parseParam parseParam({name: \"Boolean\"}, \"true\"); // return True removeItem(item, arrayList) Removes an item from the array Parameters: Name Type Description item arrayList Source: utils/advancedSearchUtils.js, line 32 Returns: updated array without the item Type Array uniqueValues() Removes duplicate values in a set and returns unique values Source: utils/advancedSearchUtils.js, line 8 Returns: Array with non-duplicate values Type Array × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Classes Classes ExternalRESTClients GraphQLClient RESTClient Namespaces Static Members &lt;constant&gt; buildFacets Given an object containing the raw facets coming from the client and a mapping object , build the ready to use facets for usage by the Vue components. Source: store/recordSearch.js, line 192 &lt;constant&gt; buildFilters Given a searchFairsharingRecords aggregations array, build the values used by the advanced search widgets Source: store/searchFilters.js, line 134 filtersStore :Object The searchFilters store trigger a single field query to searchFairsharingRecords, gets the aggregation array and builds the filtering system to be used by advanced search functions. Type: Object Source: store/searchFilters.js, line 112 introspectionStore :Object The introspection store is related to the introspection query that let us know which fields/types are allowed by the searchFairsharingRecords query Type: Object Source: store/introspector.js, line 107 &lt;constant&gt; paramsAreExpired Compares the given date with now and returns true if it greater than the given timer Source: store/introspector.js, line 154 recordStore :Object The record store handles the requests related to record (fairsharingRecord). Type: Object Source: store/recordData.js, line 21 &lt;constant&gt; recordTypes Mixin to filter the records types based on the registry {{computed: {getRecordTypes: Computed}, methods: {filteredRecordTypes(*): *[]}}} Source: utils/advancedSearchUtils.js, line 43 recordsStore :Object The records store handles the requests related to records (searchFairsharingRecords and fairsharingRecord). Type: Object Source: store/recordSearch.js, line 167 states :Object Type: Object Properties: Name Type Description errors String collects errors while introspecting. searchQueryParameters object filters query parameters object coming from API. Source: store/introspector.js, line 109 Methods hackSearch() Convert a prop from the old system into that used by the new. Useful when old search links have been deployed elsewhere in the internet or in print (as long as we know about them). Source: router/hackSearch.js, line 16 Returns: String - new form of the old prop hasValue(val) Assess if the string is of a certain value (useful to compare passwords) Parameters: Name Type Description val String the value to evaluate the string against Source: utils/rules.js, line 6 Returns: Type function isAllowedSize() Assess if the given file has the correct allowed size Source: utils/rules.js, line 107 Returns: Type function isEmail() Assess email patterns. Source: utils/rules.js, line 14 Returns: Type function isEmailOrUrl() Assess email or email patterns. Source: utils/rules.js, line 58 Returns: Type function isImage() Assess if the given file has the correct extension Source: utils/rules.js, line 96 Returns: Type function isLongEnough(length) Assess if the string is long enough. Parameters: Name Type Description length Number the length to evaluate the string against. Source: utils/rules.js, line 72 Returns: Type function isMastodon() Assess mastodon username @user@server. Source: utils/rules.js, line 25 Returns: Type function isOrcid() Assess ORCID patterns. Can be empty if required is false. Source: utils/rules.js, line 84 Returns: Type function isRequired() Assess the presence of the field Source: utils/rules.js, line 38 Returns: Type function isUrl() Assess URL patterns. Source: utils/rules.js, line 46 Returns: Type function parseParam(param, paramVal) Given a type and a value, parse the value with the expected type. Parameters: Name Type Description param Object the parameter types allowed paramVal String the value to be parsed Source: store/introspector.js, line 137 Returns: paramVal - the parse value Type String | Number | Boolean Example Example usage of parseParam parseParam({name: \"Boolean\"}, \"true\"); // return True removeItem(item, arrayList) Removes an item from the array Parameters: Name Type Description item arrayList Source: utils/advancedSearchUtils.js, line 32 Returns: updated array without the item Type Array uniqueValues() Removes duplicate values in a set and returns unique values Source: utils/advancedSearchUtils.js, line 8 Returns: Array with non-duplicate values Type Array × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Namespaces Classes ExternalRESTClients GraphQLClient RESTClient Namespaces Static Members &lt;constant&gt; buildFacets Given an object containing the raw facets coming from the client and a mapping object , build the ready to use facets for usage by the Vue components. Source: store/recordSearch.js, line 192 &lt;constant&gt; buildFilters Given a searchFairsharingRecords aggregations array, build the values used by the advanced search widgets Source: store/searchFilters.js, line 134 filtersStore :Object The searchFilters store trigger a single field query to searchFairsharingRecords, gets the aggregation array and builds the filtering system to be used by advanced search functions. Type: Object Source: store/searchFilters.js, line 112 introspectionStore :Object The introspection store is related to the introspection query that let us know which fields/types are allowed by the searchFairsharingRecords query Type: Object Source: store/introspector.js, line 107 &lt;constant&gt; paramsAreExpired Compares the given date with now and returns true if it greater than the given timer Source: store/introspector.js, line 154 recordStore :Object The record store handles the requests related to record (fairsharingRecord). Type: Object Source: store/recordData.js, line 21 &lt;constant&gt; recordTypes Mixin to filter the records types based on the registry {{computed: {getRecordTypes: Computed}, methods: {filteredRecordTypes(*): *[]}}} Source: utils/advancedSearchUtils.js, line 43 recordsStore :Object The records store handles the requests related to records (searchFairsharingRecords and fairsharingRecord). Type: Object Source: store/recordSearch.js, line 167 states :Object Type: Object Properties: Name Type Description errors String collects errors while introspecting. searchQueryParameters object filters query parameters object coming from API. Source: store/introspector.js, line 109 Methods hackSearch() Convert a prop from the old system into that used by the new. Useful when old search links have been deployed elsewhere in the internet or in print (as long as we know about them). Source: router/hackSearch.js, line 16 Returns: String - new form of the old prop hasValue(val) Assess if the string is of a certain value (useful to compare passwords) Parameters: Name Type Description val String the value to evaluate the string against Source: utils/rules.js, line 6 Returns: Type function isAllowedSize() Assess if the given file has the correct allowed size Source: utils/rules.js, line 107 Returns: Type function isEmail() Assess email patterns. Source: utils/rules.js, line 14 Returns: Type function isEmailOrUrl() Assess email or email patterns. Source: utils/rules.js, line 58 Returns: Type function isImage() Assess if the given file has the correct extension Source: utils/rules.js, line 96 Returns: Type function isLongEnough(length) Assess if the string is long enough. Parameters: Name Type Description length Number the length to evaluate the string against. Source: utils/rules.js, line 72 Returns: Type function isMastodon() Assess mastodon username @user@server. Source: utils/rules.js, line 25 Returns: Type function isOrcid() Assess ORCID patterns. Can be empty if required is false. Source: utils/rules.js, line 84 Returns: Type function isRequired() Assess the presence of the field Source: utils/rules.js, line 38 Returns: Type function isUrl() Assess URL patterns. Source: utils/rules.js, line 46 Returns: Type function parseParam(param, paramVal) Given a type and a value, parse the value with the expected type. Parameters: Name Type Description param Object the parameter types allowed paramVal String the value to be parsed Source: store/introspector.js, line 137 Returns: paramVal - the parse value Type String | Number | Boolean Example Example usage of parseParam parseParam({name: \"Boolean\"}, \"true\"); // return True removeItem(item, arrayList) Removes an item from the array Parameters: Name Type Description item arrayList Source: utils/advancedSearchUtils.js, line 32 Returns: updated array without the item Type Array uniqueValues() Removes duplicate values in a set and returns unique values Source: utils/advancedSearchUtils.js, line 8 Returns: Array with non-duplicate values Type Array × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues FAIRsharing.org Welcome to the new FAIRsharing.org website. Compiles and hot-reloads for development npm run serve Test with vue-cli &amp; generate coverage npm run test:unit Generate the documentation locally npm run doc:full × Search results Close "},"ExternalRESTClients.html":{"id":"ExternalRESTClients.html","title":"Class: ExternalRESTClients","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Class: ExternalRESTClients ExternalRESTClients new ExternalRESTClients() The RESTClient is a singleton class that handles the connection and data exchange from the back-end REST API. Source: lib/Client/ExternalClients.js, line 9 Methods &lt;async&gt; executeQuery(query) Trigger the given query with Axios Parameters: Name Type Description query Source: lib/Client/ExternalClients.js, line 82 Returns: Type Promise.&lt;*&gt; × Search results Close "},"GraphQLClient.html":{"id":"GraphQLClient.html","title":"Class: GraphQLClient","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Class: GraphQLClient GraphQLClient new GraphQLClient() The GraphQLClient retrieves data from the FAIRSharing API and sends it to the front-end. Be careful, this is a singleton and trying to cast new instances will return the existing instance. Be also careful, its constructor is async !! Source: lib/GraphClient/GraphClient.js, line 11 Returns: to use this object you need to do \"await new ClassName()\" or use .then(callback) Type Promise Methods buildQuery(query) Transform the JSON query into a string for graphQL Parameters: Name Type Description query Object the query coming from the JSON file Source: lib/GraphClient/GraphClient.js, line 59 Returns: {query: queryString} - a valid graphQL query string to execute Type Object &lt;async&gt; executeQuery(query) Execute the given query (coming from a json file, see /queries/getRecords.json) Parameters: Name Type Description query Object the query coming from the JSON file sending to the API. Source: lib/GraphClient/GraphClient.js, line 26 Returns: Type Promise &lt;async&gt; getData(queryString) Takes the query, post it with axios and returns the raw data Parameters: Name Type Description queryString Object processed request coming out of buildQuery() or a GraphQL query string Source: lib/GraphClient/GraphClient.js, line 43 Returns: an axios promise representing the server response. Type Promise setHeader(jwt) Add the authorization token to the headers Parameters: Name Type Description jwt String the user json web token Source: lib/GraphClient/GraphClient.js, line 133 × Search results Close "},"RESTClient.html":{"id":"RESTClient.html","title":"Class: RESTClient","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Class: RESTClient RESTClient new RESTClient() The RESTClient is a singleton class that handles the connection and data exchange from the back-end REST API. Source: lib/Client/RESTClient.js, line 9 Methods auth_headers(jwt) Method to add authorisation to the headers. Parameters: Name Type Description jwt the user's json web token Source: lib/Client/RESTClient.js, line 30 Returns: headers with authorisation field added Type JSON &lt;async&gt; canClaim(recordID, userToken) Determine if a user has permission to create a MaintenanceRequest for a FairsharingRecord. Parameters: Name Type Description recordID Integer ID for the relevant FairsharingRecord. userToken String JWT of the logged in user Source: lib/Client/RESTClient.js, line 373 Returns: Type Promise &lt;async&gt; canEdit(recordID, userToken) Determine if a user has permission to edit this record. Parameters: Name Type Description recordID Integer ID for the relevant FairsharingRecord. userToken String JWT of the logged in user Source: lib/Client/RESTClient.js, line 340 Returns: Type Promise &lt;async&gt; claimRecord(recordID, userToken) Attempt to create a MaintenanceRequest for a user for a FairsharingRecord. Parameters: Name Type Description recordID Integer ID for the relevant FairsharingRecord. userToken String JWT of the logged in user Source: lib/Client/RESTClient.js, line 356 Returns: Type Promise &lt;async&gt; confirmAccount(token) Validate the account given the corresponding token Parameters: Name Type Description token String the account token to validate Source: lib/Client/RESTClient.js, line 96 Returns: Type Promise &lt;async&gt; createAccount(userLogin) Method to create a new user Parameters: Name Type Description userLogin Object the user account to create Source: lib/Client/RESTClient.js, line 80 Returns: response - server response Type Promise &lt;async&gt; createGrant(grant, userToken) Create a given grant Parameters: Name Type Description grant Object userToken String the user jwt Source: lib/Client/RESTClient.js, line 652 Returns: Type Promise &lt;async&gt; createLicenceLink(licenceLink, token) Create new a licence link Parameters: Name Type Description licenceLink Object the licence link to create token String the user token Source: lib/Client/RESTClient.js, line 471 Returns: Type Promise &lt;async&gt; createMessage(message, userToken) Update the given message Parameters: Name Type Description message Object the message to create userToken String the user jwt Source: lib/Client/RESTClient.js, line 847 Returns: Type Promise &lt;async&gt; createNewUserDefinedTag(term, token) Create a new user defined tag in the database for users to tag their records. Parameters: Name Type Description term String the string value of the term token String the user JWT Source: lib/Client/RESTClient.js, line 452 Returns: Type Promise &lt;async&gt; createOrganisation(organisation, userToken) Create a given organisation Parameters: Name Type Description organisation Object userToken String the user jwt Source: lib/Client/RESTClient.js, line 598 Returns: Type Promise &lt;async&gt; createOrganisationLink(organisationLink, userToken) Create a new link between an organisation, a record and an optional grant. Parameters: Name Type Description organisationLink Object the organisation link to create userToken String the user jwt Source: lib/Client/RESTClient.js, line 670 Returns: Type Promise &lt;async&gt; createRecord(record, jwt) Post the given object to the API to create the corresponding record. Parameters: Name Type Description record jwt String JWT of the logged in user Source: lib/Client/RESTClient.js, line 306 Returns: Type Promise &lt;async&gt; deleteLicenceLink(id, token) Delete the given licence Parameters: Name Type Description id Number id of the licence link to delete token String the user token Source: lib/Client/RESTClient.js, line 489 Returns: Type Promise &lt;async&gt; deleteMessage(messageId, userToken) Update the given message Parameters: Name Type Description messageId String the ID of the message to delete userToken String the user jwt Source: lib/Client/RESTClient.js, line 864 Returns: Type Promise &lt;async&gt; deleteOrganisation(organisationId, userToken) Delete the given organisation link Parameters: Name Type Description organisationId Number the id of the link to remove userToken String the user jwt Source: lib/Client/RESTClient.js, line 635 Returns: Type Promise &lt;async&gt; deleteOrganisationLink(linkID, userToken) Delete the given organisation link Parameters: Name Type Description linkID Number the id of the link to remove userToken String the user jwt Source: lib/Client/RESTClient.js, line 707 Returns: Type Promise &lt;async&gt; deletePublicUser(userID, jwt) Delete the user Parameters: Name Type Description userID jwt String JWT of the logged in user Source: lib/Client/RESTClient.js, line 274 Returns: Type Promise &lt;async&gt; deleteRecord(id, token) Delete Record Parameters: Name Type Description id Number id of the record link to delete token String the user token Source: lib/Client/RESTClient.js, line 765 Returns: Type Promise &lt;async&gt; deleteRelations(options) Deletes the relationships as an array of items containing a targetID, a sourceID and a labelID Parameters: Name Type Description options Object the options to pass as {token: String, relations: Array} Source: lib/Client/RESTClient.js, line 573 Returns: Type Promise &lt;async&gt; editOrganisation(organisation, id, userToken) Edit a given organisation Parameters: Name Type Description organisation Object id Number userToken String the user jwt Source: lib/Client/RESTClient.js, line 617 Returns: Type Promise &lt;async&gt; editPublicUser(newUser, jwt) Edit the current logged in user profile Parameters: Name Type Description newUser Object the new values for the logged in user jwt String JWT of the logged in user Source: lib/Client/RESTClient.js, line 258 Returns: Type Promise &lt;async&gt; editUser(newUser, jwt) Edit the current logged in user profile Parameters: Name Type Description newUser Object the new values for the logged in user jwt String JWT of the logged in user Source: lib/Client/RESTClient.js, line 242 Returns: Type Promise &lt;async&gt; executeQuery(query) Trigger the given query with Axios Parameters: Name Type Description query Source: lib/Client/RESTClient.js, line 881 Returns: Type Promise.&lt;*&gt; &lt;async&gt; extraMetadataFields(type, userToken) Get the extra metadata fields for a RecordType Parameters: Name Type Description type String name of the record type. userToken String the user jwt Source: lib/Client/RESTClient.js, line 724 Returns: Type Promise &lt;async&gt; getEditByMonth(token) Get count of edits by month Parameters: Name Type Description token String the user token that needs to be a curator Source: lib/Client/RESTClient.js, line 926 Returns: Type Promise &lt;async&gt; getHomepageJsonld() Get JSON+LD for homepage. Source: lib/Client/RESTClient.js, line 991 Returns: Type Promise &lt;async&gt; getProfileTypes() Get the list of available profile types for a user. Source: lib/Client/RESTClient.js, line 795 Returns: Type Promise &lt;async&gt; getPublicUser(jwt, id) Get the current user data Parameters: Name Type Description jwt id Source: lib/Client/RESTClient.js, line 211 Returns: Type Promise &lt;async&gt; getRecordCreatedByMonth(token) Get count of records created by month Parameters: Name Type Description token String the user token that needs to be a curator Source: lib/Client/RESTClient.js, line 910 Returns: Type Promise &lt;async&gt; getRecordsWoDOIs(token) Get records without DOIS Parameters: Name Type Description token String the user token that needs to be a curator Source: lib/Client/RESTClient.js, line 894 Returns: Type Promise &lt;async&gt; getStatisticsData() Get statistics data without users Source: lib/Client/RESTClient.js, line 977 Returns: Type Promise &lt;async&gt; getUser(jwt) Get the current user data Parameters: Name Type Description jwt Source: lib/Client/RESTClient.js, line 195 Returns: Type Promise &lt;async&gt; getUsersList(jwt) Get all users list Parameters: Name Type Description jwt Source: lib/Client/RESTClient.js, line 226 Returns: Type Promise &lt;async&gt; getZenodoSearch(call, userToken) Get Zenodo call Parameters: Name Type Description call String userToken String the user jwt Source: lib/Client/RESTClient.js, line 942 Returns: Type Promise &lt;async&gt; login(username, password) Method to log in the user Parameters: Name Type Description username name of the user password password of the user Source: lib/Client/RESTClient.js, line 42 Returns: the response of the server Type Promise &lt;async&gt; logout(jwt) Logout the user from the back, expiring the current jwt. Parameters: Name Type Description jwt String the user token to expire. Source: lib/Client/RESTClient.js, line 65 Returns: Type Promise &lt;async&gt; requestResetPwd(email) Method to send a reset password link to the given email address Parameters: Name Type Description email String to send the link to Source: lib/Client/RESTClient.js, line 111 Returns: Type Promise &lt;async&gt; resendConfirmation(user) Resend the validation link for a given user Parameters: Name Type Description user Object contains the email of the user. Source: lib/Client/RESTClient.js, line 129 Returns: Type Promise &lt;async&gt; resetPassword(user) Reset the password of the given user Parameters: Name Type Description user Object contains the new pwd, repeated pwd and token. Source: lib/Client/RESTClient.js, line 145 Returns: Type Promise &lt;async&gt; resetPasswordWithoutToken(jwt, user) Changes the password of the logged in user Parameters: Name Type Description jwt String the user token user Object contains the current, new and repeated new password Source: lib/Client/RESTClient.js, line 162 Returns: Type Promise &lt;async&gt; reviewRecord(recordID, userToken) Attempt to create a RecordReview for a user for a FairsharingRecord. Parameters: Name Type Description recordID Integer ID for the relevant FairsharingRecord. userToken String JWT of the logged in user Source: lib/Client/RESTClient.js, line 433 Returns: Type Promise &lt;async&gt; saveRelations(options) Saves the relationships as an array of items containing a targetID, a sourceID and a labelID Parameters: Name Type Description options Object the options to pass as {token: String, relations: Array} Source: lib/Client/RESTClient.js, line 550 Returns: Type Promise &lt;async&gt; sendOrcidVerification(user) Send the verification link for a given user Parameters: Name Type Description user Object contains the email, uid, identifier of the user. Source: lib/Client/RESTClient.js, line 1006 Returns: Type Promise &lt;async&gt; updateLicenceLink(licenceLink, token) Update the licenceLink Parameters: Name Type Description licenceLink Object the new values for the licence link token String the user token Source: lib/Client/RESTClient.js, line 506 Returns: Type Promise &lt;async&gt; updateMessage(message, userToken) Update the given message Parameters: Name Type Description message Object the message to update containing the ID to target and the new values userToken String the user jwt Source: lib/Client/RESTClient.js, line 830 Returns: Type Promise &lt;async&gt; updateOrganisationLink(organisationLink, linkID, userToken) Update the organisationLink given from linkID input with the given organisationLink Parameters: Name Type Description organisationLink Object the new organisation link value linkID Number ID of the organisationLink to update userToken String the user jwt Source: lib/Client/RESTClient.js, line 689 Returns: Type Promise &lt;async&gt; updateRecord(record) Update the given record Parameters: Name Type Description record Object the record to update containing the ID to target, the new values and the user token Source: lib/Client/RESTClient.js, line 323 Returns: Type Promise &lt;async&gt; updateStatusMaintenanceRequest(maintenanceRequest, newStatus, userToken) Update the maintenanceRequest given the new status value Parameters: Name Type Description maintenanceRequest Number ID of the maintenanceRequest to update newStatus string new status to update userToken String the user jwt Source: lib/Client/RESTClient.js, line 743 Returns: Type Promise &lt;async&gt; validateToken(jwt) Verify that the given JWT is still valid Parameters: Name Type Description jwt String the token to validate Source: lib/Client/RESTClient.js, line 288 Returns: Type Promise &lt;async&gt; verifyPassword(password) Verify the validity of the given password Parameters: Name Type Description password String the password to test Source: lib/Client/RESTClient.js, line 178 Returns: Type Promise × Search results Close "},"Static.html":{"id":"Static.html","title":"Namespace: Static","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Namespace: Static Static All static pages will be handle through this namespace Source: views/Static/Community/Community.vue, line 2 Members Community :module This component handles the sign-up/register page Type: module Source: views/Static/Community/Community.vue, line 11 Timeline :module This component handles the sign-up/register page Type: module Source: views/Static/Timeline/Timeline.vue, line 2 × Search results Close "},"module-Curator.html":{"id":"module-Curator.html","title":"Module: Curator","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Module: Curator Data Name Type Default value Description hideFields Object - an array of field to NOT display × Search results Close "},"module-Home.html":{"id":"module-Home.html","title":"Module: Home","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Module: Home Component to handle the front page (landing page) Source: views/Home/Home.vue, line 15 × Search results Close "},"module-Login.html":{"id":"module-Login.html","title":"Module: Login","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Module: Login This component handles the login page Source: views/Users/Login/Login.vue, line 11 × Search results Close "},"module-NewRecord.html":{"id":"module-NewRecord.html","title":"Module: NewRecord","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Module: NewRecord Component to generate the new record page and its buttons to redirect to new collection, standard, policy and database Source: views/CreateRecord/NewRecord.vue, line 16 × Search results Close "},"module-Pagination.html":{"id":"module-Pagination.html","title":"Module: Pagination","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Module: Pagination Component to handle the advanced search filters for the searchFairsharingRecords query. Props Name Type Default value Required? Description totalPages Number 0 No the total number of pages to display Data Name Type Default value Description currentQuery Number null the current page number Methods disableThrottle(disable) Set the environment ready for testing or development Parameters: Name Type Description disable Boolean should disable or not the throttle for the next call Source: components/Records/Search/Header/Pagination.vue, line 102 paginate(pageNumber) Set the current query page parameter value to the given input for vueJs router Parameters: Name Type Description pageNumber Number the page to go to Source: components/Records/Search/Header/Pagination.vue, line 73 × Search results Close "},"module-Signup.html":{"id":"module-Signup.html","title":"Module: Signup","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Module: Signup This component handles the sign-up/register page Source: views/Users/Signup.vue, line 6 × Search results Close "},"module-User.html":{"id":"module-User.html","title":"Module: User","body":" FAIRsharing.org Namespaces Static Modules CuratorHomeLoginNewRecordPaginationSignupUser Classes ExternalRESTClientsGraphQLClientRESTClient Global buildFacetsbuildFiltersfiltersStorehackSearchhasValueintrospectionStoreisAllowedSizeisEmailisEmailOrUrlisImageisLongEnoughisMastodonisOrcidisRequiredisUrlparamsAreExpiredparseParamrecordStorerecordTypesrecordsStoreremoveItemstatesuniqueValues Module: User Data Name Type Default value Description hideFields Object - an array of field to NOT display × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
